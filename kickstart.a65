; MEGA65 Kick Start ROM.
; Paul Gardner-Stephen, 2014-2016.
;
; Purpose: 
; 1. Verify checksum of ROM area of slow RAM.
; 1. If checksum fails, load complete ROM from SD card.
; 2. Select default disk image for F011 emulation.
;
; The kickstart ROM is 16KB in length, and maps at $8000-$BFFF
; in hypervisor mode.
;
; Kickstart modifies RAM from $0000-$07FFF (ZP, stack, 40-column
; screen, 16-bit text mode) during normal boot.
;
; If Kickstart needs to load the ROM from SD card, then it may
; modify the first 64KB of fast ram.
;
; We will use the convention of C=0 means failure, and C=1 means
; success.
;
	.include "kickstart_machine.a65"

; scratch space in ZP space usually used by kernel
; we try to use address space not normally used by C64 kernel, so that
; it is possible to make calls to kickstart after boot.  Eventually
; the desire is to have an SYS call that brings up a menu that lets
; you choose a disk image from a list.
	.data 

	.org $ce00
	.space romslab 1
	.space screenrow 1

	.space checksum 4
	.space file_pagesread 2

	; variables for testing of D81 boot image
	.space d81_clusternumber 4
	.space d81_clustersneeded 2
	.space d81_clustercount 2

	; make sure that we don't go past the 256 byte page reserved for hypervisor scratch space
	.checkpc $CEFF

	.text

	.org $8000
;;; ----------------------------------------------------------------------------
;;; CPU Hypervisor Trap entry points.
;;; 64 x 4 byte entries for user-land traps.
;;; some more x 4 byte entries for system traps (reset, page fault etc)
;;; ----------------------------------------------------------------------------
trap_entry_points:
	; Traps $00-$07 (user callable)
	jmp dos_and_process_trap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	; Traps $08-$0F (user callable)
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	; Traps $10-$17 (user callable)
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	; Traps $18-$1F (user callable)
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	; Traps $20-$27 (user callable)
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	; Traps $28-$2F (user callable)
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	; Traps $30-$37
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	; Traps $38-$3F (user callable)
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	; Traps $40-$4F (reset, page fault and other system-generated traps)
	jmp reset_entry_allow_etherkick  ; Trap #$40 (power on / reset)
	nop
	jmp page_fault   ; Trap #$41 (page fault)
	nop
	jmp double_restore_trap   ; Trap #$42 (double-tap RESTORE key)
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop

	; Leave room for traps to $7E
	.checkpc $81F8
	.advance $81F8
	; Then we have relocated CPU vectors
	.word reset_entry_allow_etherkick ; unused vector
	.word hypervisor_nmi ; NMI
	.word reset_entry_allow_etherkick ; RESET
	.word hypervisor_irq ; IRQ

	.advance $8200

;;; ----------------------------------------------------------------------------
;;; Hypervisor traps
;;; ----------------------------------------------------------------------------
	

;;; ----------------------------------------------------------------------------
;;; Illegal trap / trap sub-function handlers
;;; ----------------------------------------------------------------------------
; Traps are triggered by writing to $D640-$D67F
; and trap to $8000+((address & $3F)*4) in the hypervisor

; Routine for unimplemented/reserved traps
; (Consider replacing with trap to hypervisor error screen with option
;  to return?)
nosuchtrap:
	; Clear C flag for caller to indicate failure
	lda hypervisor_flags
	and #$FE   ; C flag is bit 0
	sta hypervisor_flags
	; set A to $FF
	lda #$ff
	sta hypervisor_a
	; return from hypervisor
	sta hypervisor_enterexit_trigger

; Return from trap with C flag clear to indicate success
return_from_trap_with_success:
	jsr sd_unmap_sectorbuffer	
	; set C flag for caller to indicate success
	lda hypervisor_flags
	ora #$01   ; C flag is bit 0
	sta hypervisor_flags

	jsr checkpoint
	.byte 0,"return_from_trap_with_success",0

	; return from hypervisor
	sta hypervisor_enterexit_trigger

return_from_trap_with_failure:
	jsr sd_unmap_sectorbuffer	
	; report error in A
	sta hypervisor_a
	lda hypervisor_flags
	and #$fe   ; C flag is bit 0
	sta hypervisor_flags

	jsr checkpoint
	.byte 0,"return_from_trap_with_failure",0

	; return from hypervisor
	sta hypervisor_enterexit_trigger	

invalid_subfunction:
	jmp nosuchtrap

;;; ----------------------------------------------------------------------------
;;; DOS, process control and related functions trap
;;; ----------------------------------------------------------------------------
		.include "kickstart_dos.a65"
;;; ----------------------------------------------------------------------------
;;; Virtual memory and memory management
;;; ----------------------------------------------------------------------------
		.include "kickstart_mem.a65"
;;; ----------------------------------------------------------------------------
;;; Task (process) management
;;; ----------------------------------------------------------------------------
		.include "kickstart_task.a65"
;;; ----------------------------------------------------------------------------
;;; CPU Hypervisor Entry Point on reset
;;; ----------------------------------------------------------------------------
reset_machine_state:
		; get CPU state sensible
		sei
		cld
		see

		; disable IRQ/NMI sources
		lda #$7f
		sta $DC0D
		sta $DD0D
		LDA #$00
		STA $D019

		sec
		jsr enhanced_io

		lda $d60d

		; switch to fast mode
		; 1. C65 fast-mode enable
		lda $d031
		ora #$40
		sta $d031
		; 2. MEGA65 48MHz enable (requires C65 or C128 fast mode to truly enable, hence the above)
		lda $d054
		ora #$40
		sta $d054

		; sprites off
		lda #$00
		sta $d017

		lda #$7f
		sta $DC0D
		sta $DD0D
		lda #$00
		sta $D01A

		; We DO NOT need to mess with $01, because
		; the 4510 starts up with kickstart mapped at $8000-$BFFF 
		; enhanced ($FFD3xxx) IO page mapped at $D000,
		; and fast RAM elsewhere.

		; Disable reset watchdog, enable flat 32-bit addressing, don't engage
		; ROM write protect (yet), do make ASC/DIN / CAPS LOCK control CPU speed.
		; also force 4502 CPU personality (6502 personality is still incomplete)
		; and clear any pending IRQ or NMI event.
		; (The watchdog was added to catch reset problems where the machine
		; would run off somewhere odd instead of resetting properly. Now it
		; will auto-reset after 65535 cycles if the watchdog is not cleared).
		lda #$2a
		sta hypervisor_feature_enables

		jsr resetdisplay
		jsr erasescreen
		jsr resetpalette

		jsr checkpoint
		.byte 0,"reset_machine_state",0

		rts

;;; ----------------------------------------------------------------------------
;;; CPU Hypervisor reset/trap routines
;;; ----------------------------------------------------------------------------

reset_entry_allow_etherkick:
		sei
		lda #$00
		sta kickstart_boot_flags
		jmp reset_entry_common

reset_entry_no_etherkick:
		sei
		lda #$80
		sta kickstart_boot_flags
		jmp reset_entry_common

reset_entry_common:

		jsr reset_machine_state

		; display welcome screen
		ldx #<msg_kickstart
		ldy #>msg_kickstart
		jsr printbanner
		; leave a blank line below kickstart banner
		ldx #<msg_blankline
		ldy #>msg_blankline
		jsr printmessage

		; Display GIT commit
		ldx #<msg_gitcommit
		ldy #>msg_gitcommit
		jsr printmessage

		; check keyboard for 0-9 down to select alternate rom
		jsr keyboardread

		; If switch 8 and 9 are set, and etherkick mode is not disabled
		; then wait forever for ethernet packets
		lda kickstart_boot_flags
		bmi normalboot
		lda $d6f1
		and #$02
		beq normalboot
etherboot:
		ldx #<msg_etherkick
		ldy #>msg_etherkick
		jsr printmessage
		jsr setupethernet
etherloop:
		jsr checkethernet
		.byte 0,"etherloop",0
		jmp etherloop

normalboot:
		; Try to read the MBR from the SD card to ensure SD card is
		; happy
		ldx #<msg_tryingsdcard
		ldy #>msg_tryingsdcard
		jsr printmessage
tryreadmbr:
		jsr readmbr
		bcs gotmbr

		jmp tryreadmbr
		
gotmbr:
		; Scan SD card for partitions and mount them.
		jsr dos_clearall
		jsr dos_read_partitiontable
		ldx #<msg_diskcount
		ldy #>msg_diskcount
		jsr printmessage
		ldy #$00
		ldz dos_disk_count
		jsr printhex		

		; Go to root directory on default disk
		ldx dos_default_disk
		jsr dos_cdroot
		bcs mountsystemdiskok

		ldx #<msg_cdrootfailed
		ldy #>msg_cdrootfailed
		jsr printmessage
		ldy #$00
		ldz dos_error_code
		jsr printhex
		
mountsystemdiskok:

		; Load and display boot logo
		; Prepare 32-bit pointer for loading boot logo @ $0004000
		lda #$00
		sta <dos_file_loadaddress+0
		lda #$40
		sta <dos_file_loadaddress+1
		lda #$00
		sta <dos_file_loadaddress+2
		lda #$00
		sta <dos_file_loadaddress+3

		ldx #<txt_bootlogo
		ldy #>txt_bootlogo
		jsr dos_setname		
		
		jsr dos_readfileintomemory
		bcs logook
		
		ldx #<msg_nologo
		ldy #>msg_nologo
		jsr printmessage
		ldy #$00
		ldz dos_error_code
		jsr printhex

logook:
		; iterate through directory entries looking for ordinary file 
		; KICKUP.M65 to load into hypervisor memory ...
		; ... but only if we are not running a kick-up'd kickstart now.
		lda $d67e
		beq nextdirectoryentry3

		; already kicked
		ldx #<msg_alreadykicked
		ldy #>msg_alreadykicked
		jsr printmessage
		jmp postkickup

nextdirectoryentry3:
		; Prepare 32-bit pointer for loading boot logo @ $0004000
		lda #$00
		sta <dos_file_loadaddress+0
		lda #$40
		sta <dos_file_loadaddress+1
		lda #$00
		sta <dos_file_loadaddress+2
		lda #$00
		sta <dos_file_loadaddress+3

		ldx #<txt_kickupfile
		ldy #>txt_kickupfile
		jsr dos_setname
		
		jsr dos_readfileintomemory
		bcc nokickup

		; We have loaded kickup file, so jump into it.

		ldx #<msg_kickuploaded
		ldy #>msg_kickuploaded
		jsr printmessage
		ldy #$00
		ldz <zptempv32+3
		jsr printhex
		ldz <zptempv32+2
		jsr printhex
		ldz <zptempv32+1
		jsr printhex
		ldz <zptempv32+0
		jsr printhex

		; Use DMAgic to copy $0004000-$0007FFF to $FFF8000-$FFFBFFF
		; (We have to copy the routine to do this to RAM, since we will
		; be replacing ourselves)
		ldx #$00
krc:		lda kickuproutine,x
		sta $3000,x
		inx
		bne krc
		jmp $3000

kickuproutine:
		; The following routine gets copied as-is to $3000 and run from there.
		; The DMA list is still available in the kickstart ROM when it gets
		; called, so we can just use it there, instead of working out where
		; it gets copied to

		; Set bottom 22 bits of DMA list address as for C65
		; (8MB address range).  Kickstart ROM is at $FFF8000, so $FF goes
		; in high-byte area
		lda #$ff
		sta $d702
		lda #$ff   
		sta $d704  ; dma list is in top MB of address space
		sta $d706  ; similarly destination of copy is top MB of address space
		lda #$00
		sta $d705  ; source of copy is bottom MB of address space
		lda #>kickupdmalist
		sta $d701
		lda #<kickupdmalist
		sta $d700
		; clear source/destination MB so that C65 ROM doesn't go bananas
		lda #$00
		sta $d706

		; copy complete, so mark ourselves upgraded, and jump into hypervisor
		; as though we were just reset.

		sta $d67e   ; mark ourselves as having kicked up
		jmp $8100

kickupdmalist:
		; copy $0004000-$0007FFF to $FFF8000-$FFFBFFF
		; (MB offsets get set in routine)
		.byte $00 ; copy + last request in chain
		.word $4000 ; size of copy is 16KB
		.word $4000 ; starting at $4000
		.byte $00   ; of bank $0
		.word $8000 ; destination address is $8000
		.byte $0F   ; of bank $F
		.word $0000 ; modulo (unused)

couldntopenkickup:

nokickup:
		ldx #<msg_nokickup
		ldy #>msg_nokickup
		jsr printmessage
postkickup:

		; MILESTONE: Have file system properties.

		; Look for MEGA65.D81 to mount for F011 emulation
		
		; for now indicate that there is no disk in drive
		lda #$00
		sta $d68b

		jsr dos_cdroot
		bcc sdcarderror

		; set name of file we are looking for
		ldx #<txt_c65gsd81
		ldy #>txt_c65gsd81
		jsr dos_setname

		jsr dos_findfile
		bcc nod81
		jsr dos_closefile

		jsr dos_d81attach
		bcc d81attachfail
		
		ldx #<msg_d81mounted
		ldy #>msg_d81mounted
		jsr printmessage

		; all done, move on to loading the ROM
		jmp findrom

d81attachfail:
		; we couldn't find the D81 file, so tell the user
		ldx #<msg_nod81
		ldy #>msg_nod81
		jsr printmessage
		ldy #$00
		ldz dos_error_code
		jsr printhex

findrom:
		; Check state of current ROM
		jsr checkromok
		bcc loadrom

		; ROM is loaded and ready, so transfer control
		; to it.
		ldx #<msg_romok
		ldy #>msg_romok
		jsr printmessage
		jmp go64

loadrom:
		; ROM is not loaded, so try to load it, or prompt
		; for user to insert SD card
		ldx #<msg_rombad
		ldy #>msg_rombad
		jsr printmessage


		; Load CHARROM.M65 into character ROM
		ldx #<txt_c65gscharrom
		ldy #>txt_c65gscharrom
		jsr dos_setname
		
		; Prepare 32-bit pointer for loading whole ROM ($FF7E000)
		lda #$00
		sta <dos_file_loadaddress+0
		lda #$E0
		sta <dos_file_loadaddress+1
		lda #$F7
		sta <dos_file_loadaddress+2
		lda #$0F
		sta <dos_file_loadaddress+3

		jsr dos_readfileintomemory
		bcs loadedcharromok

		ldx #<msg_charrombad
		ldy #>msg_charrombad
		jsr printmessage
		jmp loadc65rom

loadedcharromok:
		ldx dos_current_file_descriptor_offset
		lda dos_file_descriptors+dos_filedescriptor_offset_fileoffset+0,x
		sta file_pagesread
		lda dos_file_descriptors+dos_filedescriptor_offset_fileoffset+1,x
		sta file_pagesread+1

		ldx #<msg_charromloaded
		ldy #>msg_charromloaded
		jsr printmessage
		ldy #$00
		ldz file_pagesread+1
		jsr printhex
		ldz file_pagesread
		jsr printhex
		
		
loadc65rom:
		ldx #<txt_c65gsrom
		ldy #>txt_c65gsrom
		jsr dos_setname

		; Prepare 32-bit pointer for loading whole ROM ($0020000)
		lda #$00
		sta <dos_file_loadaddress+0
		sta <dos_file_loadaddress+1
		sta <dos_file_loadaddress+3
		lda #$02
		sta <dos_file_loadaddress+2

		jsr dos_readfileintomemory
		bcs loadedok

		; ROM not found: indicate which ROM we were looking for
		ldx #$0b
l17d:		lda txt_c65gsrom,x
		sta msg_romnotfound+19,x
		dex
		bne l17d
		ldx #<msg_romnotfound
		ldy #>msg_romnotfound
		jsr printmessage
		jsr sdwaitawhile
		jsr sdwaitawhile
		jsr sdwaitawhile
		jsr sdwaitawhile

		jmp sdcarderror
loadedok:
		ldx dos_current_file_descriptor_offset
		lda dos_file_descriptors+dos_filedescriptor_offset_fileoffset+0,x
		sta file_pagesread
		lda dos_file_descriptors+dos_filedescriptor_offset_fileoffset+1,x
		sta file_pagesread+1

		lda file_pagesread
		bne romfiletooshort
		lda file_pagesread+1
		cmp #$00
		beq romfiletooshort
		cmp #$02
		bne romfiletoolong

		; need to store checksum
		jsr storeromsum
		
		; ROM file loaded, transfer control
		ldx #<msg_romok
		ldy #>msg_romok
		jsr printmessage
		jmp go64		

romfiletoolong:
		ldx #<msg_romfilelongerror
		ldy #>msg_romfilelongerror
		jsr printmessage
		ldz file_pagesread+1
		jsr printhex
		ldz file_pagesread
		jsr printhex
		jsr sdwaitawhile
		jmp reset_entry_allow_etherkick
romfiletooshort:
		ldx #<msg_romfileshorterror
		ldy #>msg_romfileshorterror
		jsr printmessage
		ldz file_pagesread+1
		jsr printhex
		ldz file_pagesread
		jsr printhex
		jsr sdwaitawhile
		jmp reset_entry_allow_etherkick

fileopenerror:
		ldx #<msg_fileopenerror
		ldy #>msg_fileopenerror
		jsr printmessage

sdcarderror:	ldx #<msg_sdcarderror
		ldy #>msg_sdcarderror
		jsr printmessage
		jsr sdwaitawhile
		jmp reset_entry_allow_etherkick

badfs:		ldx #<msg_badformat
		ldy #>msg_badformat
		jsr printmessage
		jsr sdwaitawhile
		jmp reset_entry_allow_etherkick
;;; ----------------------------------------------------------------------------
;;; FAT file system routines
;;; ----------------------------------------------------------------------------
toupper:	; convert ASCII character to upper case
		cmp #$60
		bcc tu1
		cmp #$7a
		bcs tu1
		and #$5f
tu1:		rts

;;; ----------------------------------------------------------------------------
;;; MBP / partition routines
;;; ----------------------------------------------------------------------------

; read master boot record. Does not sanity check anything.
readmbr:
		; begin by resetting SD card
		jsr sdreset
		bcs l7
		rts

l7:		ldx #<msg_foundsdcard
		ldy #>msg_foundsdcard
		jsr printmessage

		; MBR is sector 0	
		lda #$00
		sta $D681
		sta $d682
		sta $d683
		sta $d684

		jmp sd_readsector

;;; ----------------------------------------------------------------------------
;;; SD Card access routines
;;; ----------------------------------------------------------------------------
sdreset:
		; try SD-HC mode first
;		lda #$41
;		sta $D680
;		jsr sd_resetsequence
;		bcc sdr1
;		rts
sdr1:		; fall back to SD mode
		lda #$42
		sta $d680
		; fall through		

sd_resetsequence:
		; write $00 to $D680 to start reset
		lda #$00
		sta $D680
		jsr sdtimeoutreset
re1:		jsr sdreadytest
		bcs re1done	; success, so return
		bne re1		; not timed out, so keep trying
		rts 		; timeout, so return
re1done:	
		; write $01 to $D680 to complete reset
		lda #$01
		sta $D680
		jsr sdtimeoutreset
re2:		jsr sdreadytest
		bcs re2done	; success, so return
		bne re2		; not timed out, so keep trying
		rts 		; timeout, so return
re2done:
		; give card some time to settle after reset, otherwise 
		; reading sectors will fail
		jsr sdwaitawhile

		jsr sd_map_sectorbuffer

		; write $02 to $D680 to read MBR as a test of reset
		lda #$02
		sta $D680
		jsr sdtimeoutreset
		
re3:		; allow time for read to happen
		lda $d680
		jsr sdreadytest
		bcs redone	; success, so return
		bne re3		; not timed out, so keep trying
		; timeout -- so call reset again
		rts
redone:		
		sec
		rts

		
		; Watch for ethernet packets while waiting for the SD card.
		; this allows loading of code into the hypervisor for testing and
		; bare-metal operation.
sdwaitawhile:	jsr sdtimeoutreset

sw1:		
		inc $d020
		jsr checkethernet
		dec $d020

		inc $0300
		bne sw1
		inc $0301
		bne sw1
		inc $0302
		bne sw1
		rts

		; count to timeout value when trying to read from SD card
		; (if it is too short, the SD card won't reset)
sdtimeoutreset:
		lda #$00
		sta $0300
		sta $0301
		lda #$f7
		sta $0302
		rts

sdreadytest:	; check if SD card is ready, or if timeout has occurred
		; C is set if ready.
		; Z is set if timeout has occurred.
		lda $d680
		and #$03
		beq sdisready
		inc $0300
		bne sr1
		inc $0301
		bne sr1
		inc $0302
		bne sr1

		; timeout
		lda #$00 ; set Z

sr1:		clc
		rts
sdisready:	sec
		rts

sd_map_sectorbuffer:
		lda #$81
		sta $D680
		sec
		rts

sd_unmap_sectorbuffer:
		pha
		lda #$82
		sta $D680
		pla
		sec
		rts

sd_readsector:
		; Assumes fixed sector number (or byte address in case of SD cards)
		; is loaded into $D681 - $D684		

		; check if sd card is busy
		lda $d680
		and #$01
		bne rsbusyfail

		; try reading sector fast the first time
		jmp rs4

redoread:	
		; when retrying, introduce a delay.  This seems to be needed often
		; when reading the first sector after SD card reset.  
		ldx #$f0
		ldy #$00
		ldz #$00
r1:		inz
		bne r1
		iny
		bne r1
		inx
		bne r1

rs4:
		; ask for sector to be read
		lda #$02
		sta $d680

		; wait for sector to be read
		jsr sdtimeoutreset
rs3:		
		jsr sdreadytest
		bcs rsread
		bne rs3
		jmp rereadsector

rsread:
		lda $d680
		and #$01
		bne rs3

		; check that we read 512 bytes
		lda $d688
		lda $d689

		cmp #$02
		bne redoread

		sec
		rts

		; reset sd card and try again
rereadsector:
		jsr sdreset		
		jmp rs4

rsbusyfail:     ; fail
		lda #dos_errorcode_read_timeout
		sta dos_error_code

		clc 
		rts

printsectoraddress:
		ldx #<msg_sectoraddress
		ldy #>msg_sectoraddress
		jsr printmessage
		ldy #$00
		ldz $D681+3
		jsr printhex
		ldz $D681+2
		jsr printhex
		ldz $D681+1
		jsr printhex
		ldz $D681+0
		jmp printhex

sd_inc_fixedsectornumber:
		; increment fixed sector number.
		; if SDHC, then increment is simple.
		; if SD, then we add $200
		lda $D680
		and #$10
		bne sdhc1
		; sd card mode: add $200
		lda $d682
		clc
		adc #$02
		sta $d682
		lda $d683
		adc #$00
		sta $d683
		lda $d684
		adc #$00
		sta $d684
		rts

sdhc1:		; SDHC card mode: add 1
		inc $d681
		bcc s1
		inc $d682
s2:		bcc s1
		inc $d683
		bcc s1
		inc $d684
s1:		
		rts

sd_fix_sectornumber:
		; assumes sector number has been loaded into 
		; $D681 - $D684
		; We need to check if the card is SDHC or SD.
		; If SD, we need to shift sector number left 9 bits,
		; as SD cards address by byte, not sector.
		; If card is SD, then shift it all left nine bits
		; We detect SD versus SDHC by reading whether SD controller is
		; in SDHC or SD mode.
		lda $D680
		and #$10
		beq sdcardmode
		; SDHC mode, so nothing to do
		rts
sdcardmode:     
		; shift left 8 bits first
		lda $D683
		sta $D684
		lda $D682
		sta $D683
		lda $D681
		sta $D682
		lda #$00
		sta $D681
		; now shift it all left one bit
		lda $D682
		asl
		sta $D682
		lda $D683
		rol
		sta $D683
		lda $D684
		rol
		sta $D684
		rts

;;; ----------------------------------------------------------------------------
;;; ROM loading and manipulation routines
;;; ----------------------------------------------------------------------------

checkromok:
		; read switch 13.  If set, assume ROM is invalid
		lda $d6f1
		and #$20
		bne checksumfails
		; or if loading a ROM other than MEGA65.ROM, then assume ROM
		; is invalid
		lda txt_c65gsrom+6
		cmp #'.
		bne checksumfails
	
		; calculate checksum of loaded ROM ...
		jsr calcromsum
		; ... then fall through to testing it
testromsum:
		; have checksum for all slabs.

		jsr mapromchecksumrecord
		lda $4000
		cmp checksum
		bne checksumfails
		lda $4001
		cmp checksum+1
		bne checksumfails
		lda $4002
		cmp checksum+2
		bne checksumfails

		jsr resetmemmap

		sec
		rts

		; check failed
checksumfails:	clc
		rts

storeromsum:
		jsr mapromchecksumrecord
		lda checksum
		sta $4000
		lda checksum+1
		sta $4001
		lda checksum+2
		sta $4002
		rts

mapromchecksumrecord:
		; Map in ROM load record, and compare checksum
		; Here we have to use our extension to MAP to access >1MB
		; as only 128KB of slow ram is shadowed to $20000.
		; again, we have to take the relative nature of MAP, so
		; we ask for $FC000 to be mapped at $0000, which means that
		; $4000 will correspond to $0000 (MAP instruction address
		; space wraps around at the 1MB mark)
		
		; select 128MB mark for mapping lower 32KB of address space
		lda #$80
		ldx #$0f
		ldy #$00   ; keep kickstart mapped at $8000-$BFFF
		ldz #$3f
		map
		; then map $FC000 + $4000 = $00000 at $4000-$7FFF
		lda #$c0
		ldx #$cf
		ldy #$00   ; keep kickstart mapped at $8000-$BFFF
		ldz #$3f
		map
		eom
		
		rts

calcromsum:	; calculate checksum of 128KB ROM
		
		; use MAP to map C65 ROM address space in 16KB
		; slabs at $4000-$7FFF.  Check sum each, and
		; then compare checksum to ROM load record.
		; ROMs get loaded into slow RAM at $8020000-$803FFFF,
		; which is shadowed for reading using C65 MAP instruction to
		; C65 address space $20000-$3FFFF.
		; Checksum and ROM load record are stored in
		; $8000000 - $800FFFF, i.e., the first 64KB of
		; slow RAM.
		;
		; The 4510 MAP instruction does not normally provide access to the
		; full 28-bit address space, so we need to use a trick.
		; We do this by interpretting a MAP instruction that says to
		; map none of the 8KB pages, but provides an offset in the range
		; $F0000 - $FFF00 to set the "super page" register for that 32KB
		; moby to bits 8 to 15 of the offset.  In practice, this means
		; to allow mapping of memory above 1MB, the MB of memory being
		; selected is chosen by the contents of A and Y registers when 
		; X and Z = $0F.
		; 
				
		; reset checksum
		; checksum is not all zeroes, so that if RAM initialises with
		; all zeroes, including in the checksum field, the checksum will
		; not pass.
		lda #$03
		sta checksum
		sta checksum+1
		sta checksum+2
		sta checksum+3

		; start with bottom 16KB of ROM
		; we count in 16KB slabs, and ROM starts at 128KB mark,
		; so we want to check from the 8th to 15th slabs inclusive.
		lda #$08
		sta romslab

		; Summing can be done using normal use of MAP instruction,
		; since slow RAM is shadowed as ROM to $20000-$3FFFF

sumslab:	; romcheckslab indicates which 16KB piece.
		; MAP uses 256-byte granularity, so we need to shift left
		; 6 bits into A, and right 2 bits into X.
		; We then set the upper two bits in X to indicate that the mapping
		; applies to blocks 2 and 3.
		; BUT MAP is relative, and since we are mapping at the 16KB mark,
		; we need to subtract 1 lot of 16KB from the result.
		; this is easy -- we just sbc #$01 from romslab before using it.
		lda romslab
		sec 
		sbc #$01
		lsr
		lsr
		ora #$c0
		tax
		lda romslab
		sec
		sbc #$01
		asl
		asl
		asl
		asl
		asl
		asl
		ldy #$00   ; keep kickstart mapped at $8000-$BFFF
		ldz #$3f
		map
		eom
		
		; sum contents of 16KB slab
		lda #$00
		sta <zptempv
		lda #$40
		sta <zptempv+1
		
sumpage:	ldy #$00
sumbyte:	lda checksum
		clc
		adc (<zptempv),y
		sta checksum
		bcc l6
		inc checksum+1
		bcc l6
		inc checksum+2
l6:		iny
		bne sumbyte
		inc <zptempv+1
		lda <zptempv+1
		cmp #$80
		bne sumpage
		
		inc romslab
		lda romslab
		cmp #$10
		bne sumslab

		jmp resetmemmap

;;; ----------------------------------------------------------------------------
;;; Display and basic IO routines
;;; ----------------------------------------------------------------------------

resetdisplay:
		; reset screen
		lda #$40
		sta $d030
		lda $d031
		and #$40
		sta $d031
		lda #$00
		sta $D020
		sta $D021
		sta $D054
		; We use VIC-II style registers as this resets video frame in
		; least instructions, and 40 columns is fine for us.
		lda #$14
		sta $D018
		lda #$1B
		sta $D011
		lda #$C8
		sta $D016
		; point VIC-IV to bottom 16KB of display memory
		lda #$ff
		sta $DD01
		sta $DD00

		; Now switch to 16-bit text mode so that we can use proportional
		; characters and full-colour characters for chars >$FF for the logo
		lda #$05
		sta $d054
		; and 80 bytes (40 16-bit characters) per row.
		lda #<80
		sta $d058
		lda #>80
		sta $d059
		
		rts

resetpalette:
		; reset VIC-IV palette to sensible defaults.
		; load C64 colours into palette bank 3 for use when
		; PAL bit in $D030 is set.
		lda #$04
		sta $D030	; enable PAL bit in $D030
		lda #$ff
		sta $D070	; select palette bank 3 for display and edit

		; C64 colours designed to look like C65 colours on an
		; RGBI screen.
                lda #$00
                sta $D100
                sta $D200
                sta $D300
                lda #$ff
                sta $D101
                sta $D201
                sta $D301
                lda #$ba
                sta $D102
                lda #$13
                sta $D202
                lda #$62
                sta $D302
                lda #$66
                sta $D103
                lda #$ad
                sta $D203
                lda #$ff
                sta $D303
                lda #$bb
                sta $D104
                lda #$f3
                sta $D204
                lda #$8b
                sta $D304
                lda #$55
                sta $D105
                lda #$ec
                sta $D205
                lda #$85
                sta $D305
                lda #$d1
                sta $D106
                lda #$e0
                sta $D206
                lda #$79
                sta $D306
                lda #$ae
                sta $D107
                lda #$5f
                sta $D207
                lda #$c7
                sta $D307
                lda #$9b
                sta $D108
                lda #$47
                sta $D208
                lda #$81
                sta $D308
                lda #$87
                sta $D109
                lda #$37
                sta $D209
                lda #$00
                sta $D309
                lda #$dd
                sta $D10a
                lda #$39
                sta $D20a
                lda #$78
                sta $D30a
                lda #$b5
                sta $D10b
                sta $D20b
                sta $D30b
                lda #$b8
                sta $D10c
                sta $D20c
                sta $D30c
                lda #$0b
                sta $D10d
                lda #$4f
                sta $D20d
                lda #$ca
                sta $D30d
                lda #$aa
                sta $D10e
                lda #$d9
                sta $D20e
                lda #$fe
                sta $D30e
                lda #$8b
                sta $D10f
                sta $D20f
                sta $D30f

		; put a colour cube in other entries
		ldx #$10
paletteloop:
		; R = upper 3 bits
		txa
		lsr
		lsr
		lsr
		and #$0e
		sta $d100,x

		; G = next 3 bits
		txa
		lsr
		and #$0e
		sta $d200,x
		
		; B = lowest 2 bits
		txa
		asl
		asl
		and #$0c
		sta $d300,x

		inx
		bne paletteloop

		rts

; erase standard 40-column screen
erasescreen:
		; bank in 2nd KB of colour RAM
		lda #$01
		tsb $D030

		; use DMA to clear screen and colour RAM
		; The screen is in 16-bit bit mode, so we actually need to fill
		; with $20,$00, ...
		; We will cheat by setting the first four bytes, and then copying from
		; there, and it will then read from the freshly written bytes.
		; (two bytes might not be enough to allow the write from the last DMA
		;  action to be avaialble for reading because of how the DMAgic is
		;  pipelined).
		lda #$20
		sta $0400
		sta $0402
		lda #$00
		sta $0401
		sta $0403
		
		; Set bottom 22 bits of DMA list address as for C65
		; (8MB address range)
		lda #$ff
		sta $d702
		; Kickstart ROM is at $FFFE000 - $FFFFFFF, so
		; we need to tell DMAgic that DMA list is in $FFxxxxx.
		; this has to be done AFTER writing to $d702, as $d702
		; clears bits 27 - 22 of the DMA list address to help with
		; compatibility.
		lda #$ff
		sta $d704
		; copy from MB $00 for screen clearing
		lda #$00
		sta $d705
		; destination MB is $00, since we are writing to C64 RAM space.
		lda #$00
		sta $d706

		lda #>erasescreendmalist
		sta $d701
		; set bottom 8 bits of address and trigger DMA.
		lda #<erasescreendmalist
		sta $d700

		; Kickstart ROM is at $FFFE000 - $FFFFFFF, so
		; we need to tell DMAgic that DMA list is in $FFxxxxx.
		; this has to be done AFTER writing to $d702, as $d702
		; clears bits 27 - 22 of the DMA list address to help with
		; compatibility.
		lda #$ff
		sta $d704
		; similarly we need to tell DMAgic that we are copying data from
		; MB $FF (this is for copying the disk chooser)
		sta $d705
		; destination MB is $00, since we are writing to C64 RAM space.
		lda #$00
		sta $d706

		lda #>copydiskchooserdmalist
		sta $d701
		; set bottom 8 bits of address and trigger DMA.
		lda #<copydiskchooserdmalist
		sta $d700

		; clear source/destination MB so that C65 ROM doesn't go bananas
		lda #$00
		sta $d705

		; bank 2nd KB of colour RAM back out
		lda #$01
		trb $D030

		; move cursor back to top of the screen
		; (but leave 8 rows for logo and banner text)
		lda #$08
		sta screenrow

		; draw 8x8 char block for logo
		ldx #$00
		ldy #$00
logo1:		txa
		sta $0400+[80*0],y
		ora #$08
		sta $0400+[80*1],y
		txa
		ora #$10
		sta $0400+[80*2],y
		txa
		ora #$18
		sta $0400+[80*3],y
		txa
		ora #$20
		sta $0400+[80*4],y
		txa
		ora #$28
		sta $0400+[80*5],y
		txa
		ora #$30
		sta $0400+[80*6],y
		txa
		ora #$38
		sta $0400+[80*7],y
		iny
		iny
		inx
		cpx #$08		
		bne logo1
		; then write the high bytes for these (all $01, so char range will be
		; $100-$140. $100 x $40 = $4000-$4FFF
		ldx #$00
		lda #$01
logo2:		sta $0401+[80*0],x
		sta $0401+[80*1],x
		sta $0401+[80*2],x
		sta $0401+[80*3],x
		sta $0401+[80*4],x
		sta $0401+[80*5],x
		sta $0401+[80*6],x
		sta $0401+[80*7],x
		inx
		inx
		cpx #$10
		bne logo2

		; finally work around the VIC-IV bug where the first normal character
		; following a full-colour character gets skipped by inserting early
		; end of line terminator markers on the lines. Without this, the first
		; character of the next line would show
		lda #$ff
		sta $044e
		sta $044f
		sta $049e
		sta $049f
		sta $04ee
		sta $04ef
		sta $053e
		sta $053f
		sta $058e
		sta $058f
		sta $05de
		sta $05df
		sta $062e
		sta $062f
		sta $067e
		sta $067f

		rts

erasescreendmalist:
		; Clear screen RAM
		.byte $04 ; COPY + chained request
		.word 1996 ; 40x25x2-4 = 1996
		.word $0400 ; copy from start of screen at $0400
		.byte $00 ; source bank 00
		.word $0404 ; ... to screen at $0402
		.byte $00   ; screen is in bank $00
		.word $0000 ; modulo (unused)
		; Clear colour RAM
		.byte $07 ; fill + chained request
		.word 2000 ; 40x25x2 = 2000
		.byte $01 ; fill with white = $01
		.byte $00,$00 ; rest of source address is ignored in fill
		.word $d800 ; screen is at $0400
		.byte $80   ; screen is in IO, so bank IO in to DMA context
		.word $0000 ; modulo (unused)
		; Clear $4000-$4FFF (for logo display) 
		.byte $03 ; fill + last request
		.word $1000 ; 64x64 = $1000
		.byte $00 ; fill with black = $00
		.byte $00,$00 ; rest of source address is ignored in fill
		.word $4000 ; logo sits at $4000
		.byte $00   ; ... in bottom half of chipram, so bank $00
		.word $0000 ; modulo (unused)

copydiskchooserdmalist:
		; also copy diskchooser from $FFFE000-$FFFEFFF to $000C000-$000CFFF
		.byte $00 ; copy + last request in chain
		.word $1000
		.word diskchooserstart ; source address 
		.byte $0F ; source bank
		.word $c000 ; destination address
		.byte $00   ; destination bank
		.word $0000 ; modulo (unused)

printmessage:
		stx <zptempp
		sty <zptempp+1
		lda #$00
		sta <zptempp2
		lda #$04
		sta <zptempp2+1
		ldx screenrow

		; if we have reached the bottom of the screen, start writing again
		; from the top of the screen (but don't touch the top 8 rows for
		; logo and banner)
		cpx #25
		bne pm2
		ldx #$08
		stx screenrow

		; work out the screen address
pm2:		cpx #$00
		beq pm1
		clc
		lda <zptempp2
		adc #$50          ; 40 columns x 16 bit
		sta <zptempp2
		lda <zptempp2+1
		adc #$00
		sta <zptempp2+1
		; if reached bottom of screen, then loop back to top of screen
		cmp #$0b
		bcc pm5
		lda <zptempp2
		cmp #$d0
		bcc pm5
	
		lda #$80
		sta <zptempp2
		lda #$06
		sta <zptempp2+1
pm5:		dex
		bne pm2
pm1:

		; Clear line (16-bit chars, so write #$0020 to each word
		ldy #$00
pm1b:		lda #$20
		sta (<zptempp2),y
		iny
		lda #$00
		sta (<zptempp2),y		
		iny
		cpy #$50
		bne pm1b		

writestring:
		phz
		ldy #$00
		ldz #$00
pm3:		lda (<zptempp),y
		beq endofmessage
		; convert ASCII/PETSCII to screen codes
		cmp #$40
		bcc pm4
		and #$1f
pm4:		; write 16-bit character code
		sta (<zptempp2),z
		inz
		pha
		lda #$00
		sta (<zptempp2),z
		pla
		iny
		inz
		bne pm3
endofmessage:
		inc screenrow

		plz
		rts

printbanner:
		stx <zptempp
		sty <zptempp+1
		lda #<$0504
		sta zptempp2
		lda #>$0504
		sta zptempp2+1
		jsr writestring
		dec screenrow
		rts
		
printhex:	
		; output contents of Z on last written screen line
		tza
		lsr
		lsr
		lsr
		lsr
		jsr printhexdigit		
		tza
		and #$0f
printhexdigit:
		; find next $ sign to replace with hex digit
		tax
phd3:		lda (<zptempp2),y
		cmp #$24
		beq phd2
		iny
		iny
		cpy #$50
		bne phd3
		rts
phd2:		txa

		ora #$30
		cmp #$3a
		bcc phd1
		sbc #$39
phd1:		sta (<zptempp2),y
		iny
		iny
		rts



; Transfer control to C64 kernel.
; (This also allows entry to C65 mode, because the
;  C64-mode kernel on the C65 checks if C65 mode
;  should be entered.)
go64:
		; Check if hold boot switch is set (switch 15)?
		lda $d6f1
		bpl l42      ; no, so continue		

		; yes, display message
		ldx #<msg_releasesw15
		ldy #>msg_releasesw15
		jsr printmessage

l41:		lda $d6f1
		bmi l41
l42:

		; unmap sector buffer so C64 can see CIAs
		lda #$82
		sta $D680

		; copy routine to stack to switch to
		; C64 memory map and enter via reset
		; vector.  
	
		; erase kickstart ROM copy from RAM
		; (well, at least enough so that BASIC doesn't get upset)
		; XXX - use DMA
		ldx #$00
		txa
g61:		sta $0800,x
		inx
		bne g61		

		; reset video mode to normal
		lda #$00
		sta $d054
		lda #<40
		sta $d058
		lda #>40
		sta $d059


		jsr task_set_c64_memorymap
		jsr task_set_pc_to_reset_vector
		jsr task_dummy_nmi_vector

		; Exit hypervisor and transfer control to ROM
		sta hypervisor_enterexit_trigger
	
longpeek:
		; Use DMAgic to read any byte of RAM in 28bit address space.
		; Value gets read into $BC00 (kickstart_scratchbyte0)
		; ($FFFBC00 - $FFFBDFF)

		; Patch DMA list
		sta $d705 ; DMAgic source MB
		lda #$ff
		sta $d706 ; DMAgic destination MB
		stx longpeekdmalist+3
		sty longpeekdmalist+4
		stz longpeekdmalist+5
		; Set DMA list address
		lda #>longpeekdmalist
		sta $d701
		lda #$0f
		sta $d702 ; DMA list address is $xxFxxxx
		lda #$ff
		sta $d704 ; DMA list address is $FFxxxxx
		; set bottom bits of DMA list address and trigger DMA
		lda #<longpeekdmalist
		sta $d700
		rts

longpeekdmalist:
		.byte $00 ; COPY, no chain
 		; 1 byte
		.word $0001
		; source address
		.word $0000
		.byte $00
		; destination address ($xxFBC00)
		.word kickstart_scratchbyte0
		.byte $0F 
		.byte $00,00 ; Modulo
		
; reset memory map to default
resetmemmap:
		; clear memory MAP MB offset register
		lda #$00
		ldx #$0f
		ldy #$00   ; keep kickstart mapped at $8000-$BFFF
		ldz #$3f
		map
		; and clear all mapping
		tax
		ldy #$00   ; keep kickstart mapped at $8000-$BFFF
		ldz #$3f
		map
		eom
		rts


; If C=1, enable enhanced IO bank, else return to
; C64 standard IO map.
enhanced_io:
		bcs l1
		; Return to VIC-II / C64 IO
		lda #$00
		sta VICIV_MAGIC
		rts
l1:		; Enable VIC-IV / MEGA65 IO
		lda #$47
		sta VICIV_MAGIC
		lda #$53
		sta VICIV_MAGIC
		RTS

; Check for digits 0 - 9 on keyboard, and change which ROM we intend to read
; based on that.
keyboardread:
		lda #$ff
		sta $dc03
		lda #$00
		sta $dc02
		lda #$fe
		sta $dc01
		lda #$20
		ldx $dc00
		cpx #$7f
		bne k1
		lda #$31
k1:		cpx #$ef
		bne k9
		lda #$39
k9:		cpx #$f7
		bne k7
		lda #$37
k7:		cpx #$fb
		bne k5
		lda #$35
k5:		cpx #$fd
		bne k3
		lda #$33
k3:		ldx #$f7
		stx $dc01
		ldx $dc00
		cpx #$7f
		bne k0
		lda #$32
k0:		cpx #$ef
		bne k8
		lda #$30
k8:		cpx #$f7
		bne k6
		lda #$38
k6:		cpx #$fb
		bne k4
		lda #$36
k4:		cpx #$fd
		bne k2
		lda #$34
k2:		
		; put character into 6th byte position of ROM file name.
		; so no key looks for MEGA65.ROM, where as 0-9 will look
		; for MEGA65x.ROM, where x is the number.
		ldx #6
		cmp #$20
		beq default_rom
		sta txt_c65gsrom,x
		inx
default_rom:
		lda #'.
		sta txt_c65gsrom,x
		inx
		lda #'R
		sta txt_c65gsrom,x
		inx
		lda #'O
		sta txt_c65gsrom,x
		inx
		lda #'M
		sta txt_c65gsrom,x
		inx
		lda #0
   		sta txt_c65gsrom,x    

		rts

;-----------------------------------------------------------------------------
	; This is an adaption of the etherload code, to allow loading of memory
	; while waiting at the kickstart ROM.  Since this is an amazing security
	; hole, we only do it if switch 8 is set.

setupethernet:
	; only do it if switch 8 is on
	lda $d6f1
	and #$01
	bne e1
	rts
e1:
	; C65GS io
	lda #$47
	sta viciv_magic
	lda #$53
	sta viciv_magic

	; Map ethernet registers at $6000 - $7FFF
	
	; Ethernet controller really lives $FFDE000 - $FFDEFFF, so select $FF megabyte section for MAP LO
	lda #$ff
	ldx #$0f
	ldy #$00   ; keep kickstart mapped at $8000-$BFFF
	ldz #$3f
	map
	eom

	; now enable mapping of $DE000-$DFFFF at $6000
	; MAPs are offset based, so we need to subtract $6000 from the target address
	; $DE000 - $6000 = $D8000
	lda #$80
	ldx #$8d
	ldy #$00   ; keep kickstart mapped at $8000-$BFFF
	ldz #$3f
	map
	eom

	; Ethernet registers should now be visible from $6000 - $6FFF
	; read buffer will be at $6800 - $6FFF
	; length of frame is in $6FFE / $6FFF in little-endian byte order
	; so LDA $6FFE ; LDX $6FFF ; jsr $BDCD should print packet length to screen

	; make sure ethernet transceiver is on and not generating IRQs
	; (we will poll it).
	; also make sure that we acknowledge the last received packet so that the
	; ethernet controller knows it can receive.
	lda $d6e1
	lsr
	and #$02
	ora #$01
	sta $d6e1

	rts

checkethernet:
	; only do it if switch 8 is on
	lda $d6f1
	and #$01
	bne e2
	rts
e2:

	lda $d6e1
	and #$20
	bne gotpacket
	rts
gotpacket:
	; clear eth RX signal, and leave ethernet tranceiver on
	; and make last used RX buffer visible
	lda $d6e1
	and #$04
	lsr
	ora #$01
	sta $d6e1


	; Got a packet.
	; check whether it is UDP port 4510
	; or whether it is an ARP request

	; Here we want to check that $680E - $6817 =
	; 08 06 00 01 08 00 06 04 00 01

	ldx #$09
arploop0:
	lda $680e,x
	cmp arptemplate,x
	bne notarp
	dex
	bpl arploop0

	; check that IP address asked for ends in .65
	lda $682b
	cmp #65
	bne notarp

	; ok, so we have an ARP request.
	; now we need to build the ARP reply and send it.
	; We should copy the sender's 

	; XXX for now just increment border colour

	; set output packet size
	; 6+6+2 bytes ethernet header + 28 bytes of ARP reply = 42
	lda #<42
	sta $d6e2
	lda #>42
	sta $d6e3

	; copy fixed ARP fields (we will overwrite some later)
	; (note that TX buffer lacks 2 byte RX buffer header)
	ldx #$14
arploop1:
	lda $6802,x
	sta $6800,x
	dex
	bpl arploop1
	; Copy ethernet source to ethernet destination in TX buffer
	; Set our mac address in ethernet source address field in TX buffer
	ldx #$05
arploop2:
	lda $6808,x    ; requestors mac from RX ethernet header
	sta $6800,x    ; requestors mac into TX ethernet header
	lda #$40
	sta $6806,x    ; our mac in ethernet header
	sta $6816,x    ; our mac in ARP payload
	dex
	bpl arploop2
	; set packet as ARP reply
	lda #$02     ; $02 = reply, $01 = request
	sta $6815

	ldx #$03
	; copy requested IP address into reply IP address field
arploop3:
	lda $6828,x
	sta $681c,x
	dex
	bpl arploop3
	; copy requestors MAC+IP into target MAC+IP fields
	ldx #9
arploop4:
	lda $6818,x
	sta $6820,x
	dex
	bpl arploop4
	
	; packet should now all be ready - hit TX button
	lda #$01
	sta $d6e4
notarp:

	; is it IPv4?
	lda $6810
	cmp #$45
	bne badpacket
	; is it UDP?
	lda $6819
	cmp #$11
	bne badpacket
	; UDP port #4510
	lda $6826
	cmp #>4511
	bne badpacket
	lda $6827
	cmp #<4511
	bne badpacket

	; packet body begins at $0444 / $682C.
	; if it begins with $A9 = LDA immediate, then jsr to the packet body.
	; packet body can do whatever is required to load data, keeping this
	; programme very simple.
	lda $682c
	cmp #$a9
	bne badpacket
	jsr $682C

badpacket:
	rts

arptemplate:
	.byte $08,$06,$00,$01,$08,$00,$06,$04,$00,$01

nybltohex:
	cmp #$a
	bcs nth1
	ora #$30
	rts
nth1:	sec
	sbc #9
	rts

debug_wait_for_switch_toggle:	
		php
		phz
		phy
		phx
		pha
		
		and #$0f
		jsr nybltohex
		sta $0682
		pla
		pha
		lsr
		lsr
		lsr
		lsr
		jsr nybltohex
		sta $0680

		lda dos_error_code
		lsr
		lsr
		lsr
		lsr
		jsr nybltohex
		sta $0684
		lda dos_error_code
		and #$f
		jsr nybltohex
		sta $0686

		; Show current sector number as well.
		lda $d684
		lsr
		lsr
		lsr
		lsr
		jsr nybltohex
		sta $068a
		lda $d684
		and #$f
		jsr nybltohex
		sta $068c
		lda $d683
		lsr
		lsr
		lsr
		lsr
		jsr nybltohex
		sta $068e
		lda $d683
		and #$f
		jsr nybltohex
		sta $0690
		lda $d682
		lsr
		lsr
		lsr
		lsr
		jsr nybltohex
		sta $0692
		lda $d682
		and #$f
		jsr nybltohex
		sta $0694
		lda $d681
		lsr
		lsr
		lsr
		lsr
		jsr nybltohex
		sta $0696
		lda $d681
		and #$f
		jsr nybltohex
		sta $0698

		lda $d6f1
		ldx $d6f0
dwfst_loop:
		cmp $d6f1
		bne dwfst_done
		cpx $d6f0
		bne dwfst_done
		inc $d020
		jmp dwfst_loop
dwfst_done:
		; now wait a bit for de-bounce
		ldx #0
		ldy #0
		ldz #$f0
d1:		inx
		bne d1
		iny
		bne d1
		inz
		bne d1
		

		pla
		plx
		ply
		plz
		plp
		rts

hypervisor_nmi:
hypervisor_irq:
		; Default interrupt handlers for hypervisor: for now just mask the
		; interrupt source.  Later we can have raster splits in the boot
		; display if we so choose.
		sei
		rti

hypervisor_setup_copy_region:
	; Hypervisor copy region sit entirely within the first 32KB of
	; mapped address space. Since we allow a 256 byte copy region,
	; we limit the start address to the range $0000-$7EFF
	; XXX - We should also return an error if there is an IO
	; region mapped there, so that the hypervisor can't be tricked
	; into doing privileged IO operations as part of the copy-back
	
	lda hypervisor_y
	bmi hscr1
	cmp #$7f
	beq hscr1
	sta hypervisor_userspace_copy_vector+1
	lda #$00
	sta hypervisor_userspace_copy_vector

	jsr checkpoint
	.byte 0,"hypervisor_setup_copy_region <success>",0

	sec
	rts
hscr1:
	jsr checkpoint
	.byte 0,"hypervisor_setup_copy_region <failure>",0

	lda #dos_errorcode_invalid_address
	jmp dos_return_error		

checkpoint:
	; Routine to record the progress of code through the hypervisor for
	; debugging problems in the hypervisor.
	; If the JSR checkpoint is followed by $00, then a text string describing the
	; checkpoint is inserted into the checkpoint log.
	; Checkpoint data is recorded in the 2nd 16KB of colour RAM.

	; Save all registers and CPU flags
	sta checkpoint_a
	stx checkpoint_x
	sty checkpoint_y
	stz checkpoint_z
	php
	pla
	sta checkpoint_p

	; pull PC return address from stack
	; (JSR pushes return_address-1, so add one)
	pla
	clc
	adc #$01
	sta checkpoint_pcl
	pla
	adc #$00
	sta checkpoint_pch

	; Only do checkpoints visibly if switch 12 is set
	lda $d6f1
	and #$10
	beq cp9

	inc $d020

	; Write checkpoint byte values out as hex into message template
	ldx checkpoint_a
	jsr checkpoint_bytetohex
	sty msg_checkpoint_a+0
	stx msg_checkpoint_a+1
	ldx checkpoint_x
	jsr checkpoint_bytetohex
	sty msg_checkpoint_x+0
	stx msg_checkpoint_x+1
	ldx checkpoint_y
	jsr checkpoint_bytetohex
	sty msg_checkpoint_y+0
	stx msg_checkpoint_y+1
	ldx checkpoint_z
	jsr checkpoint_bytetohex
	sty msg_checkpoint_z+0
	stx msg_checkpoint_z+1
	ldx checkpoint_p
	jsr checkpoint_bytetohex
	sty msg_checkpoint_p+0
	stx msg_checkpoint_p+1
	ldx checkpoint_pch
	jsr checkpoint_bytetohex
	sty msg_checkpoint_pc+0
	stx msg_checkpoint_pc+1
	ldx checkpoint_pcl
	jsr checkpoint_bytetohex
	sty msg_checkpoint_pc+2
	stx msg_checkpoint_pc+3

	; Clear out checkpoint message
	ldx #39
	lda #$20
cp4:	sta msg_checkpointmsg,x
	dex
	bpl cp4
cp9:
	; Read next byte following the return address to see if it is $00,
	; if so, then also store the $00-terminated text message that follows.
	; e.g.:
	; jsr checkpoint
	; .byte 0,"OPEN DIRECTORY",0
	; to record a checkpoint with the string "OPEN DIRECTORY"	
	ldy #$00
	lda (<checkpoint_pcl),y

	bne nocheckpointmessage

	; Copy null-terminated checkpoint string
	ldx #$00
	iny
cp3:	lda (<checkpoint_pcl),y
	beq endofcheckpointmessage
	sta msg_checkpointmsg,x
	inx
	iny
	cpy #40
	bne cp3
	; flush out any excess bytes at end of message
cp44:	lda (<checkpoint_pcl),y
	beq endofcheckpointmessage
	iny
	bra cp44
	

endofcheckpointmessage:
	; Skip $00 at end of message
	iny
	
nocheckpointmessage:

	; Advance return address following any checkpoint message
	tya
	clc	
	adc checkpoint_pcl
	sta checkpoint_pcl
	lda checkpoint_pch
	adc #$00
	sta checkpoint_pch

	; Only do checkpoints visibly if switch 12 is set
	lda $d6f1
	and #$10
	beq checkpoint_return

	; output checkpoint message to serial monitor
	ldx #0
cp5:	lda msg_checkpoint,x
	sta hypervisor_write_char_to_serial_monitor
	inx

	; delay at least 2,000 cycles to allow character to be written
	; each inner loop is 2 + 256 * (2+3) = ~1,250 cycles
	; so 2 such loops should take long enough
	ldy #2
	ldz #0
cp6:	inz
	bne cp6
	dey
	bpl cp6

	cmp #10
	bne cp5
checkpoint_return:
	; restore registers
	lda checkpoint_p
	php
	lda checkpoint_a
	ldx checkpoint_x
	ldy checkpoint_y
	ldz checkpoint_z
	plp

	; return by jumping to the 
	jmp (checkpoint_pcl)

checkpoint_bytetohex:
	txa
	and #$f0
	lsr
	lsr
	lsr
	lsr
	jsr checkpoint_nybltohex
	tay
	txa
	and #$0f
	jsr checkpoint_nybltohex
	tax	
	rts
checkpoint_nybltohex:
	and #$0f
	ora #$30
	cmp #$3a
	bcs cpnth1
	rts
cpnth1:	adc #$06
	rts

; checkpoint message
msg_checkpoint:	      .byte "Checkpoint @ $"
msg_checkpoint_pc:    .byte "%%%% A:$"
msg_checkpoint_a:     .byte "%%, X:$"
msg_checkpoint_x:     .byte "%%, Y:$"
msg_checkpoint_y:     .byte "%%, Z:$"
msg_checkpoint_z:     .byte "%%, P:$"
msg_checkpoint_p:     .byte "%% :"
msg_checkpointmsg:    .byte "                                        "
		      .byte 13,10  ; CR/LF
msg_checkpoint_eom:		     

; messages.  All have to be <=40 bytes long
msg_kickstart:        .byte "MEGA65 KICKSTART V00.04",0
msg_romok:            .byte "ROM CHECKSUM OK - BOOTING",0
msg_rombad:	      .byte "ROM CHECKSUM FAIL - LOADING ROM",0
msg_charrombad:	      .byte "COULD NOT LOAD CHARROM.M65",0
msg_charromloaded:    .byte "LOADED CHARROM.M65 ($$$$ PAGES)",0
msg_tryingsdcard:     .byte "LOOKING FOR SDCARD...",0
msg_foundsdcard:      .byte "FOUND AND RESET SDCARD",0
msg_sdcarderror:      .byte "ERROR READING FROM SD CARD",0

msg_badformat:	      .byte "BAD MBR OR DOS BOOT SECTOR.",0
msg_sdcardfound:      .byte "READ PARTITION TABLE FROM SDCARD",0
msg_foundromfile:     .byte "FOUND ROM FILE. START CLUSTER = $$$$$$$$",0
msg_diskcount:	      .byte "MOUNTED $$ PARTITIONS",0
msg_filelengths:      .byte "LOOKING FOR $$ BYTES, I SEE $$ BYTES",0

msg_fileopenerror:    .byte "COULD NOT OPEN ROM FILE FOR READING",0
msg_readingfile:      .BYTE "READING ROM FILE...",0
msg_romfilelongerror: .byte "ROM TOO LONG: (READ $$$$ PAGES)",0
msg_romfileshorterror:.byte "ROM TOO SHORT: (READ $$$$ PAGES)",0
msg_clusternumber:    .byte " NEXT CLUSTER=$$$$$$$$",0
msg_sectoraddress:    .byte " NEXT SECTOR=$$$$$$$$",0
msg_nod81:	      .byte "CANNOT MOUNT MEGA65.D81 - (ERRNO: $$)",0
msg_d81mounted:	      .byte "MEGA65.D81 SUCCESSFULLY MOUNTED",0
msg_releasesw15:      .byte "RELEASE SW15 TO CONTINUE BOOTING.",0
msg_romnotfound:      .byte "COULD NOT FIND ROM MEGA65XXROM",0
msg_foundkickup:      .byte "LOADING KICKUP.M65 INTO HYPERVISOR",0
msg_nokickup:         .byte "NO KICKUP.M65 TO LOAD (OR BROKEN)",0
msg_kickuploaded:     .byte "KICKUP LOADED TO 00004000 - $$$$$$$$",0
msg_alreadykicked:    .byte "RUNNING KICKED HYPERVISOR",0
msg_etherkick:	      .byte "BOOTING VIA ETHERKICK: UDP PORT 4511",0
msg_lookingfornextsector:
		      .byte "LOOKING FOR NEXT SECTOR OF FILE",0
msg_nologo:	      .byte "COULD NOT LOAD BOOTLOGO.M65 (ERRNO:$$)",0
msg_cdrootfailed:     .byte "COULD NOT CHDIR TO / (ERRNO:$$)",0
		      .include "version.a65"

msg_blankline:	      .byte 0

; filename of character ROM
txt_c65gscharrom:     .byte "CHARROM.M65",0
; filename of ROM we want to load in FAT directory format
; (the two zero bytes are so that we can insert an extra digit after
; the 5, when a user presses a key, so that they can choose a
; different ROM to load).
txt_c65gsrom:	      .byte "MEGA65.ROM",0,0
; filename of 1581 disk image we mount by default
txt_c65gsd81:	      .byte "MEGA65.D81",0
; filename of kickstart update file
txt_kickupfile:	      .byte "KICKUP.M65",0
; filename containing boot logo
txt_bootlogo:	      .byte "BOOTLOGO.M65",0

diskchooserstart:
	; Pre-compiled disk chooser
	.incbin "diskchooser"
	;.incbin "diskmenu_c000.bin"
diskchooserend:

		.checkpc $BB00
		.advance $BB00

; Table of available disks.
; This includes native FAT32 disks, as well as (in the future at least)
; mounted .D41, .D71, .D81 and .DHD files using Commodore DOS filesystems.
; But for now, we are supporting only FAT32 as the filesystem.
; See kickstart_dos.a65 for information on how the table is used.
; Entries are 32 bytes long, so we can have 8 of them.
dos_disk_table:
		

		; Hypervisor DOS work area and scratch pad at $BC00-$BDFF

		.checkpc $BC00
		.advance $BC00

kickstart_scratchbyte0:
		.byte $00		

; The number of disks we have
dos_disk_count:
		.byte $00
; The default disk
dos_default_disk:
		.byte $00
; The current disk
dos_disk_current_disk:
		.byte $00
; Offset of current disk entry in disk table
dos_disk_table_offset:
		.byte $00
; cluster of current directory of current disk
dos_disk_cwd_cluster:
		.byte 0,0,0,0

; Current point in open directory
dos_opendir_cluster:
		.byte 0,0,0,0
dos_opendir_sector:
		.byte 0
dos_opendir_entry:
		.byte 0

; WARNING: dos_readdir_read_next_entry uses carnal knowledge about the following
; structure, particularly the length as calculated here:
		.alias dos_dirent_structure_length 64+1+11+4+4+1
; Current long filename (max 64 bytes)
dos_dirent_longfilename:
		.byte "Venezualen casaba melon productio"
		.byte "n statistics (2012-2015).txt  "
		.byte 0
dos_dirent_longfilename_length:
		.byte 0
dos_dirent_shortfilename:
		.byte "FILENAME.EXT",0		
dos_dirent_cluster:
		.byte 0,0,0,0
dos_dirent_length:
		.byte 0,0,0,0
dos_dirent_type_and_attribs:
		.byte 0

; Requested file name and length
dos_requested_filename_len:
		.byte 0
dos_requested_filename:
		.byte "Venezualen casaba melon productio"
		.byte "n statistics (2007-2011).txt     "

; Details about current DOS request
dos_sectorsread: .word 0

dos_current_sector:    .word 0,0
dos_current_cluster:   .word 0,0
dos_current_sector_in_cluster: .byte 0

; Current file descriptors
; Each descriptor has:
;   disk id : 1 byte ($00-$07 = file open, $FF = file closed)
;   access mode : 1 byte ($00 = read only)
;   start cluster : 4 bytes
;   current cluster : 4 bytes
;   current sector in cluster : 1 byte
;   offset in sector: 2 bytes
;   file offset / $100 : 3 bytes
    .alias dos_filedescriptor_max 4
    .alias dos_filedescriptor_offset_diskid 0    
    .alias dos_filedescriptor_offset_mode 1    
    .alias dos_filedescriptor_offset_startcluster 2    
    .alias dos_filedescriptor_offset_currentcluster 6
    ; These last three fields must be contiguous, as dos_open_current_file
    ; relies on it.
    .alias dos_filedescriptor_offset_sectorincluster 10
    .alias dos_filedescriptor_offset_offsetinsector 11
    .alias dos_filedescriptor_offset_fileoffset 13
dos_file_descriptors:
	.byte $FF,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	.byte $FF,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	.byte $FF,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	.byte $FF,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
; The current file descriptor
dos_current_file_descriptor:
	.byte 0
; Offset of current file descriptor
dos_current_file_descriptor_offset:
	.byte 0

; For providing feedback on why DOS calls have failed
; There is a set of error codes defined in kickstart_dos.a65
dos_error_code:
		.byte $00

		.checkpc $BD00
		.advance $BD00,$00
		.include "kickstart_process_descriptor.a65"

		; Kickstart stack (8-bit)
		.checkpc $BE00
		.advance $BE00,$3d

		; Kickstart ZP at $BF00-$BFFF
		.checkpc $BF00
		.advance $BF00,$3e

kickstart_boot_flags:
			; $80 = disable etherkick this boot only
			.byte 0
			
; Temporary vector storage for DOS
dos_scratch_vector: .word 0,0
dos_scratch_byte_1: .byte 0
dos_scratch_byte_2: .byte 0

; Vectors for copying data between hypervisor and user-space
hypervisor_userspace_copy_vector:    .word 0
    
; general kickstart temporary variables
zptempv:	    .word 0
zptempv2:	    .word 0
zptempp: 	    .word 0
zptempp2: 	    .word 0
zptempv32:	    .word 0,0
zptempv32b:	    .word 0,0
dos_file_loadaddress: .word 0,0

; Used for checkpoint debug system of hypervisor
checkpoint_a:	      .byte 0
checkpoint_x:	      .byte 0
checkpoint_y:	      .byte 0
checkpoint_z:	      .byte 0
checkpoint_p:	      .byte 0
checkpoint_pcl:	      .byte 0
checkpoint_pch:	      .byte 0

		.checkpc $C000
		.advance $C000, $3f

		 .outfile "kickstart65gs.bin"
