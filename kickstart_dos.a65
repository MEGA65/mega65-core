; XXX - Track down why 2nd and subsequent LFN blocks are not used.

	.alias os_version  $0101
	.alias dos_version $0101
	.alias constant_partition_type_fat32_chs $0b
	.alias constant_partition_type_fat32_lba $0c

	; DOS error codes
	.alias dos_errorcode_partition_not_interesting $01
	.alias dos_errorcode_bad_signature $02
	.alias dos_errorcode_is_small_fat $03
	.alias dos_errorcode_too_many_reserved_clusters $04
	.alias dos_errorcode_not_two_fats $05
	.alias dos_errorcode_too_few_clusters $06
	.alias dos_errorcode_read_timeout $07
	.alias dos_errorcode_partition_error $08

	.alias dos_errorcode_invalid_address $10
	.alias dos_errorcode_illegal_value $11

	.alias dos_errorcode_no_such_disk $80
	.alias dos_errorcode_name_too_long $81
	.alias dos_errorcode_not_implemented $82
	.alias dos_errorcode_file_too_long $83
	.alias dos_errorcode_too_many_open_files $84
	.alias dos_errorcode_invalid_cluster $85
	.alias dos_errorcode_is_a_directory $86
	.alias dos_errorcode_not_a_directory $87
	.alias dos_errorcode_file_not_found $88
	.alias dos_errorcode_invalid_file_descriptor $89
	.alias dos_errorcode_image_wrong_length $8A
	.alias dos_errorcode_image_fragmented $8B

	.alias dos_errorcode_eof $FF

	; FAT directory entry constants
	.alias fs_fat32_dirent_offset_attributes 11
	.alias fs_fat32_dirent_offset_shortname 0
	.alias fs_fat32_dirent_offset_create_tenthsofseconds 13
	.alias fs_fat32_dirent_offset_create_time 14
	.alias fs_fat32_dirent_offset_create_date 16
	.alias fs_fat32_dirent_offset_access_date 18
	.alias fs_fat32_dirent_offset_clusters_high 20
	.alias fs_fat32_dirent_offset_modify_time 22
	.alias fs_fat32_dirent_offset_modify_date 24
	.alias fs_fat32_dirent_offset_clusters_low 26
	.alias fs_fat32_dirent_offset_file_length 28

	; VFAT long file name entry constants
	.alias fs_fat32_dirent_offset_lfn_part_number 0
	.alias fs_fat32_dirent_offset_lfn_type 12
	.alias fs_fat32_dirent_offset_lfn_checksum 13
	.alias fs_fat32_dirent_offset_lfn_part1_chars 5
	.alias fs_fat32_dirent_offset_lfn_part1_start 1
	.alias fs_fat32_dirent_offset_lfn_part2_chars 6
	.alias fs_fat32_dirent_offset_lfn_part2_start 14
	.alias fs_fat32_dirent_offset_lfn_part3_chars 2
	.alias fs_fat32_dirent_offset_lfn_part3_start 28

	.alias fs_fat32_attribute_isreadonly $01
	.alias fs_fat32_attribute_ishidden $02
	.alias fs_fat32_attribute_issystem $04
	.alias fs_fat32_attribute_isvolumelabel $08
	.alias fs_fat32_attribute_isdirectory $10
	.alias fs_fat32_attribute_archiveset $20

	; Possible file modes
	.alias dos_filemode_directoryaccess $80
	.alias dos_filemode_end_of_directory $81
	.alias dos_filemode_readonly 0
	.alias dos_filemode_readwrite 1
	; 256-byte fixed size records for REL emulaton
	.alias dos_filemode_relative 2
	

dos_and_process_trap:
	; XXX - Machine is being updated to automatically disable IRQs on trapping
	; to hypervisor, but for now, we need to do this explicitly.
	; Should be able to be removed after 20160103
	sei
	; Sub-function is selected by A.
	; Bits 6-1 are the only ones used.
	; Mask out bit 0 so that indirect jmp's are valid.
	and #$FE
	; to save memory we only allow this table to be 128 bytes long,
	; thus we have to check that bit 7 is clear.
	bmi invalid_subfunction
	tax
	jmp (dos_and_process_trap_table,x)
dos_and_process_trap_table:
	; $00 - $0E
	.word trap_dos_getversion
	.word trap_dos_getdefaultdrive
	.word trap_dos_getcurrentdrive
	.word trap_dos_selectdrive
	.word trap_dos_getdisksize
	.word trap_dos_getcwd
	.word trap_dos_chdir
	.word trap_dos_mkdir
	; $10 - $1E
	.word trap_dos_rmdir
	.word trap_dos_opendir
	.word trap_dos_readdir
	.word trap_dos_closedir
	.word trap_dos_openfile
	.word trap_dos_readfile
	.word trap_dos_writefile
	.word trap_dos_mkfile
	; $20 - $2E
	.word trap_dos_closefile
	.word trap_dos_closeall
	.word trap_dos_seekfile
	.word trap_dos_rmfile
	.word trap_dos_fstat
	.word trap_dos_rename
	.word trap_dos_filedate
	.word trap_dos_setname
	; $30 - $3E
	.word trap_dos_findfirst
	.word trap_dos_findnext
	.word trap_dos_findfile
	.word trap_dos_loadfile
	.word trap_dos_geterrorcode
	.word invalid_subfunction
	.word invalid_subfunction
	.word invalid_subfunction
	; $40 - $4E
	.word trap_dos_d81attach
	.word trap_dos_d81detach
	.word trap_dos_d81writeen
	.word invalid_subfunction
	.word invalid_subfunction
	.word invalid_subfunction
	.word invalid_subfunction
	.word invalid_subfunction
	; $50 - $5E
	.word trap_dos_gettasklist
	.word trap_dos_sendmessage
	.word trap_dos_receivemessage
	.word trap_dos_writeintotask
	.word trap_dos_readoutoftask
	.word invalid_subfunction
	.word invalid_subfunction
	.word invalid_subfunction
	; $70 - $7E
	.word trap_dos_terminateothertask
	.word trap_dos_create_task_native
	.word trap_dos_load_into_task
	.word trap_dos_create_task_c64
	.word trap_dos_create_task_c65
	.word trap_dos_exit_and_switch_to_task
	.word trap_dos_switch_to_task
	.word trap_dos_exit_task

; Return OS and DOS version.
; A/X = OS Version major/minor
; Z/Y = DOS Version major/minor
trap_dos_getversion:
	lda #<os_version
	sta hypervisor_x
	lda #>os_version
	sta hypervisor_a
	lda #<dos_version
	sta hypervisor_z
	lda #>dos_version
	sta hypervisor_y
	jmp return_from_trap_with_success

trap_dos_getdefaultdrive:
	lda dos_default_disk
	sta hypervisor_a
	jmp return_from_trap_with_success

trap_dos_selectdrive:
	jsr dos_set_current_disk
return_from_trap_with_carry_flag:
	bcs return_from_trap_with_success
	bcc return_from_trap_with_failure

trap_dos_closeall:
	jsr dos_clear_filedescriptors
	jmp return_from_trap_with_success	

trap_dos_loadfile:
	; Only allow loading into lower 16MB to avoid possibility of writing
	; over hypervisor
	lda hypervisor_x
	sta dos_file_loadaddress
	lda hypervisor_y
	sta dos_file_loadaddress+1
	lda hypervisor_z
	sta dos_file_loadaddress+2
	lda #$00
	sta dos_file_loadaddress+3
	jsr dos_readfileintomemory
	jmp return_from_trap_with_carry_flag

trap_dos_setname:
	; read file name from any where in bottom 32KB of RAM, as mapped on entry
	; to the hypervisor (this prevents the user from setting the filename to some
	; piece of the hypervisor, and thus leaking hypervisor data to user-land if the
	; user were to later query the filename).

	jsr checkpoint
	.byte 0,"trap_dos_setname",0

	jsr hypervisor_setup_copy_region
	bcc tdsnfailure

	ldy #$3f
tdsn1:	lda (<hypervisor_userspace_copy_vector),y
	sta dos_requested_filename,y
	dey
	bpl tdsn1
	; now set length
	lda hypervisor_z
	cmp #$3f
	bcc tdsn2
	lda #dos_errorcode_name_too_long
	sta dos_error_code
	jmp return_from_trap_with_failure
tdsn2:
	; setname succeeded
	stz dos_requested_filename_len

	; upper case the filename for comparison
	jsr dos_requested_filename_to_uppercase

	; clear out checkpoint message to make sure there are no $00 chars hiding
	; to cause grief.
	lda #$20
	ldy #39
tdsn6:		
	sta setnamemsg,y
	dey
	cpy #11
	bne tdsn6
tdsn5:

	; display name length in checkpoint message
	tza
	tax
	jsr checkpoint_bytetohex
	sty setnamemsglen+0
	stx setnamemsglen+1

	; Display filename in checkpoint message
	cpz #24
	bcc tdsn3
	ldz #24
tdsn3:
	tza
	tay
	dey
tdsn4:	lda dos_requested_filename,y
	bne tdsn7
	lda #$3f ; ? mark in place of $00 chars
tdsn7:
	sta setnamemsgname,y
	dey
	bpl tdsn4
	tza
	tay
	lda #'\)
	sta setnamemsgname,y

	jsr checkpoint
	.byte 0
setnamemsg:
	.byte "setname($"
setnamemsglen:
	.byte "%%,"
setnamemsgname:
	.byte "                            "
	.byte 0

	jmp return_from_trap_with_success

tdsnfailure:
	lda dos_error_code
	jmp return_from_trap_with_failure

illegalvalue:

;	tya
;	tax
;	jsr checkpoint_bytetohex
;	sty iv1+0
;	stx iv1+1
;
;	jsr checkpoint
;	.byte 0,"Filename contains $00 @ position $"
;iv1:	.byte "%%",0

	lda #dos_errorcode_illegal_value
	sta dos_error_code
	jmp return_from_trap_with_failure

trap_dos_getcurrentdrive:
	lda dos_disk_current_disk
	sta hypervisor_a
	jmp return_from_trap_with_success

trap_dos_opendir:
	; Open the current working directory for iteration.
	jsr dos_opendir
	bcs tdod1
	; Something has gone wrong. Assume dos_opendir will
	; have set error code
	lda dos_error_code
	jmp return_from_trap_with_failure
tdod1:
	; Directory opened ok.
	lda dos_current_file_descriptor
	sta hypervisor_a
	jmp return_from_trap_with_success
    
trap_dos_readdir:
	; Read next directory entry from file descriptor $XX
	; Return dirent structure to $YY00
	; in first 32KB of mapped address space

	jsr checkpoint
	.byte 0,"trap_dos_readdir",0

	jsr sd_map_sectorbuffer

	; Get offset to current file descriptor
	; (we can't use X register, as has been clobbered in the jump
	; table dispatch code)
	ldx hypervisor_x
	stx dos_current_file_descriptor

	jsr dos_get_file_descriptor_offset
	bcc tdrd1
	sta dos_current_file_descriptor_offset

	jsr dos_readdir
	bcc tdrd1

	; Read the directory entry, now copy it to userland
	jsr hypervisor_setup_copy_region
	bcc tdrd1

	; We can now copy the bytes of the dirent to user-space
	ldy #dos_dirent_structure_length-1
tdrd2:
	lda dos_dirent_longfilename,y
	sta (<hypervisor_userspace_copy_vector),y
	dey
	bpl tdrd2

	jsr checkpoint
	.byte 0,"trap_dos_readdir <success>",0

	jmp return_from_trap_with_success
tdrd1:
	jsr checkpoint
	.byte 0,"trap_dos_readdir <failure>",0
	
	lda dos_error_code
	jmp return_from_trap_with_failure
	
trap_dos_closedir:
	jmp trap_dos_closefile

trap_dos_openfile:
	; Opens file in current dirent structure
	; XXX - This means we must preserve the dirent struct when
	; context-switching to avoid a race-condition
	
	jsr dos_openfile
	bcc tdof1

	jsr checkpoint
	.byte 0,"trap_dos_openfile <success>",0
	jmp return_from_trap_with_success
tdof1:
	jsr checkpoint
	.byte 0,"trap_dos_openfile <failure>",0
	
	lda dos_error_code
	jmp return_from_trap_with_failure

trap_dos_closefile:
	ldx hypervisor_x
	stx dos_current_file_descriptor

	jsr dos_get_file_descriptor_offset
	bcc tdcf1
	jsr dos_closefile
	bcc tdcf1

	jsr checkpoint
	.byte 0,"trap_dos_closefile <success>",0

	jmp return_from_trap_with_success
tdcf1:
	jsr checkpoint
	.byte 0,"trap_dos_closefile <failure>",0
	
	lda dos_error_code
	jmp return_from_trap_with_failure

trap_dos_findfile:
	jsr dos_findfile
	jmp return_from_trap_with_carry_flag
trap_dos_findfirst:
	jsr dos_findfirst
	jmp return_from_trap_with_carry_flag
	
trap_dos_findnext:
	jsr dos_findnext
	jmp return_from_trap_with_carry_flag

trap_dos_geterrorcode:

	lda dos_error_code
	sta hypervisor_a

	tax
	jsr checkpoint_bytetohex
	sty tdgec1+0
	stx tdgec1+1

	jsr checkpoint
	.byte 0,"dos_geterrorcode <=$"
tdgec1:	.byte "%%>",0

	jmp return_from_trap_with_success

trap_dos_d81attach:
	jsr checkpoint
	.byte 0,"trap_dos_d81attach",0

	lda #$00
	sta $d68b
	jsr dos_d81attach
	jmp return_from_trap_with_carry_flag
	
trap_dos_d81detach:
	lda #$00
	sta $d68b
	jmp return_from_trap_with_success
	
trap_dos_d81writeen:	
	lda $d68b
	and #$03
	cmp #$03
	bne td81we1
 	ora #$04
	sta $d68b
	jmp return_from_trap_with_success
td81we1:
	; No disk image mounted
	lda #dos_errorcode_no_such_disk
	sta dos_error_code
	jmp return_from_trap_with_failure


trap_dos_readfile:
trap_dos_getdisksize:
trap_dos_getcwd:
trap_dos_chdir:
trap_dos_mkdir:
trap_dos_rmdir:
trap_dos_mkfile:
trap_dos_writefile:
trap_dos_seekfile:
trap_dos_rmfile:
trap_dos_fstat:
trap_dos_rename:
trap_dos_filedate:
trap_dos_gettasklist:
trap_dos_sendmessage:
trap_dos_receivemessage:
trap_dos_writeintotask:
trap_dos_readoutoftask:
trap_dos_terminateothertask:
trap_dos_create_task_native:
trap_dos_load_into_task:
trap_dos_create_task_c64:
trap_dos_create_task_c65:
trap_dos_exit_and_switch_to_task:
trap_dos_switch_to_task:
trap_dos_exit_task:
	jmp invalid_subfunction;



; Clear all file descriptors.
; This just consists of setting the drive number to $ff,
; which indicates "no such drive"
; Drive number field is first byte of file descriptor for convenience
dos_clear_filedescriptors:

	; XXX - This doesn't close the underlying file descriptors!
	lda #$ff
	sta currenttask_filedescriptor0
	sta currenttask_filedescriptor1
	sta currenttask_filedescriptor2
	sta currenttask_filedescriptor3
	sec
	rts

; Read partition table from SD card.
; Add all FAT32 partitions to our list of known disks.
; This routine assumes that the SD card has been reset and is ready to
; service requests.
; XXX - We don't support extended partition tables! Only the old-fashion
; 4 DOS partitions.  We might get excited and add support for them later,
; but 
dos_read_partitiontable:

	; clear error code
	lda #0
	sta dos_error_code

	; Clear the list of known disks
	jsr dos_initialise_disklist

	jsr dos_read_mbr
	bcc drpt_fail

	; Make the sector buffer visible
	jsr sd_map_sectorbuffer

	lda #dos_errorcode_bad_signature
	sta dos_error_code
	; check for $55AA MBR signature
	lda [sd_sectorbuffer+$1FE]
	cmp #$55
	bne drpt_fail
	lda [sd_sectorbuffer+$1FF]
	cmp #$AA
	bne drpt_fail

	; Partitions start at offsets $1BE, $1CE, $1DE, $1EE
	; so consider each in turn.  Opening the partition causes other sectors to
	; be read, so we must re-read the MBR between each

	; get pointer to second half of sector buffer so that we can access the
	; partition entries as we see fit.
	lda #<[sd_sectorbuffer+$1BE]
	sta dos_scratch_vector
	lda #>[sd_sectorbuffer+$1BE]
	sta dos_scratch_vector+1
	jsr dos_consider_partition_entry
	
	jsr dos_read_mbr
	bcc drpt_fail
	lda #<[sd_sectorbuffer+$1CE]
	sta dos_scratch_vector
	jsr dos_consider_partition_entry

	jsr dos_read_mbr
	bcc drpt_fail
	lda #<[sd_sectorbuffer+$1DE]
	sta dos_scratch_vector
	jsr dos_consider_partition_entry

	jsr dos_read_mbr
	bcc drpt_fail
	lda #<[sd_sectorbuffer+$1EE]
	sta dos_scratch_vector
	jsr dos_consider_partition_entry

	lda #0
	sta dos_error_code
	sec
	rts

dos_read_mbr:
	; Offset zero  on disk
	lda #0
	sta sd_address_byte0
	sta sd_address_byte1
	sta sd_address_byte2
	sta sd_address_byte3

	; Read sector
	jsr sd_readsector
	bcc drpt_fail
	rts

dos_initialise_disklist:
	lda #0
	sta dos_disk_count
	rts

dos_consider_partition_entry:

	lda #$00
	sta dos_error_code

	; Offset within partition table entry of partition type
	ldy #$04
	; Get partition type byte
	lda (<dos_scratch_vector),y

	; We like FAT32 partitions, whether LBA or CHS addressed, although we actually
	; use LBA addressing.  XXX - Can this cause problems for CHS partitions?
	; (SD cards which must really use LBA, can still show up with CHS partitions!
	;  this is really annoying.)
	cmp #constant_partition_type_fat32_lba
	beq partitionisinteresting
	cmp #constant_partition_type_fat32_chs
	beq partitionisinteresting
	lda #dos_errorcode_partition_not_interesting
	sta dos_error_code
	jmp partitionisnotinteresting

partitionisinteresting:
	; Partition is FAT32, so add it to the list

	; Disk structures in dos_disk_table are 32 bytes long, so shift count left
	; 5 times to get offset in dos disk list table
	lda dos_disk_count
	asl
	asl
	asl
	asl
	asl
	tax

	; Copy relevant fields into place
	; These are start of partition and length of partition (both in sectors)
	; XXX - This requires that our dos_disk_table has these two fields together
	; at the start of the structure.
	ldy #$08
dcpe1:	lda (<dos_scratch_vector),y
	sta dos_disk_table,x
	inx
	iny
	cpy #$10
	bne dcpe1

	; Examine the internals of the partition to get the remaining fields.
	; At this point we no longer use the contents of the MBR
	lda dos_disk_count
	jsr dos_disk_openpartition
	bcc partitionerror

	; Check if partition is bootable (or the only partition)
	; If so, make the partition the default disk
	lda dos_disk_count
	beq makethispartitionthedefault
	ldy #$00
	lda (<dos_scratch_vector),y
	bpl dontmakethispartitionthedefault
makethispartitionthedefault:
	lda dos_disk_count
	sta dos_default_disk
dontmakethispartitionthedefault:

partitionisnotinteresting:
	; return OK
	sec
	rts

drpt_fail:
	; error code will already be set	
partitionerror:
	; return ERROR
	clc
	rts

; Examine a partition to see if we can mount it.
; This routine fills in the missing fields for the disk entry as required.
; It assumes that fs_start_sector and fs_sector_count have been correctly set.
; Each disk entry consists of;
; Offset $00 - starting sector (4 bytes)
  	 .alias fs_start_sector $00
; Offset $04 - sector count (4 bytes)
  	 .alias fs_sector_count $04
; Offset $08 - Filesystem type & media source ($0x = FAT32, $xF = SD card, others reserved for now)
  	 .alias fs_type_and_source $08
; Remaining bytes are filesystem dependent:
; For FAT32:
; Offset $09 - length of fat (4 bytes) (FAT starts at fs_fat32_system_sectors)
  	 .alias fs_fat32_length_of_fat $09
; Offset $0D - system sectors (2 bytes)
  	 .alias fs_fat32_system_sectors $0D
; Offset $0F - reserved clusters (1 byte)
  	 .alias fs_fat32_reserved_clusters $0F
; Offset $10 - root dir cluster (2 bytes) 
  	 .alias fs_fat32_root_dir_cluster $10
; Offset $12 - cluster count (4 bytes)
  	 .alias fs_fat32_cluster_count $12
; Offset $16 - sectors per cluster
  	 .alias fs_fat32_sectors_per_cluster $16
; Offset $17 - copies of FAT
  	 .alias fs_fat32_fat_copies $17
; Offset $18 - first sector of cluster zero (4 bytes)
  	 .alias fs_fat32_cluster0_sector $18
; Offset $1C - Four spare bytes.
dos_disk_openpartition:
	; A contains the disk number we are trying to open.
	lda #$00
	sta dos_error_code

	; Load first sector of file system and parse.
	; This is the Volume Boot Record

	; Get offset of disk entry in our disk table structure 
	asl
	asl
	asl
	asl
	asl
	sta dos_disk_table_offset

	; Now pull the start sector from the structure and get ready to request
	; that structure from the SD card.
	ora #fs_start_sector
	tay
	ldx #$00
ddop1:	lda dos_disk_table,y
	sta sd_address_byte0,x
	iny
	inx
	cpx #$04
	bne ddop1
	; Convert sector number to byte offset for non-HC SD cards
	jsr sd_fix_sectornumber
	jsr sd_readsector
	bcc partitionerror

	; We now have the sector, so parse.

	jsr sd_map_sectorbuffer

	; Check for 55/AA singature
	lda #dos_errorcode_bad_signature
	sta dos_error_code
	lda [sd_sectorbuffer+$1FE]
	cmp #$55
	bne partitionerror
	lda [sd_sectorbuffer+$1FF]	
	cmp #$AA
	bne partitionerror

	; Start populating fields

	; Filter out obviously FAT16/FAT12 file systems
	lda #dos_errorcode_is_small_fat
	sta dos_error_code
	lda [sd_sectorbuffer+$11]
	bne partitionerror

	; get # copies of fat
	lda dos_disk_table_offset
	ora #fs_fat32_fat_copies
	tay
	lda [sd_sectorbuffer+$10]
	sta dos_disk_table,y

	; With root directory entries = 0, the reserved sector count
	; is the number of reserved sectors, plus (copies of fat) *
	; (sectors in one copy of the fat).
	; the first FAT begins immediately after the reserved sectors

	; Determine system sector count
	; (= reserved sectors + fat_count * fat_sectors)
	; $20 + $EE5 + $EE5 = $1DEA
	; plus partition offset = $81 = $1E6B
	; partition length = $3BAF7F
	; $08 sectors / cluster
	; so data sectors in partition = $3BAF7F - $1DEA = $3B9195
	; = $77232 clusters
	
	; Reserved sector field on disk is only 2 bytes!
	lda dos_disk_table_offset
	ora #fs_fat32_system_sectors	
	tay
	ldx #$00
ddop10:	lda [sd_sectorbuffer+$0E],x
	sta dos_disk_table,y
	iny
	inx
	cpx #$02
	bne ddop10

	; Store length of one copy of the FAT
	lda dos_disk_table_offset
	ora #fs_fat32_length_of_fat
	tay
	ldx #$00
ddop11:	lda [sd_sectorbuffer+$24],x
	sta dos_disk_table,y
	iny
	inx
	cpx #$04
	bne ddop11

	; Get number of reserved clusters.  We only allow upto 255 reserved
	; clusters, so report an error if the upper two bytes are not both zero
	lda #dos_errorcode_too_many_reserved_clusters
	sta dos_error_code
	lda [sd_sectorbuffer+$2C+1]
	ora [sd_sectorbuffer+$2C+2]
	ora [sd_sectorbuffer+$2C+3]
	; XXX - 16 bit BNE should be fine here! Why doesn't it work?
	;	bne partitionerror
	beq ddop11ok
	jmp partitionerror
ddop11ok:
	; <64K reserved clusters, so file system passes this test -- just copy number
	ldy dos_disk_table_offset
	lda [sd_sectorbuffer+$2C]
	sta [dos_disk_table+fs_fat32_reserved_clusters],y

	; Now work out the sector of cluster 0, by adding the length of
	; each FAT to fs_fat32_system_sectors to start of partition.
	; For efficiency, we pull the fields we need out of the sector buffer,
	; instead of working out their offsets in the disk entry structure.

	; Start with fs_fat32_system_sectors (which is 16 bits)
	lda dos_disk_table_offset
	ora #fs_fat32_system_sectors
	tay	
	lda dos_disk_table_offset
	ora #fs_fat32_cluster0_sector
	tax
	ldz #$02
ddop2:	lda dos_disk_table,y
	sta dos_disk_table,x
	iny
	inx
	dez
	bne ddop2
	; clear top 16 bits of cluster0_sector
	tza
	sta [dos_disk_table+0],x
	sta [dos_disk_table+1],x
	
	; Now add length of fat for each copy of the fat
	lda #dos_errorcode_not_two_fats
	sta dos_error_code
	ldz [sd_sectorbuffer+$10]     ; # of FAT copies
	beq partitionerror ; There must be at least one copy of the FAT!
	cpz #2
	bne partitionerror
ddop_addnextfatsectors:
	lda dos_disk_table_offset
	ora #fs_fat32_cluster0_sector
	tay
	ldx #$00
	clc
	php
ddop12:	plp
	lda dos_disk_table,y           ; cluster0_sector
	adc [sd_sectorbuffer+$24],x    ; sectors per fat
	sta dos_disk_table,y           ; cluster0_sector
	php
	iny
	inx
	cpx #$04
	bne ddop12
	plp
	dez
	bne ddop_addnextfatsectors

	; Next, we temporarily need the number of data sectors, so that we can work
	; out the number of clusters in the file system.
	; This is the total number of sectors in the partition, minus the number of
	; reserved sectors.

	; Subtract (cluster 0 sector = 32 bits) from
	; (length of filesystem in sectors = 32 bits)

	lda dos_disk_table_offset
	ora #fs_fat32_cluster0_sector
	tax
	lda dos_disk_table_offset
	ora #fs_fat32_cluster_count
	tay
	sec
	lda [sd_sectorbuffer+$20+0]
	sbc [dos_disk_table+0],x
	sta [dos_disk_table+0],y
	lda [sd_sectorbuffer+$20+1]
	sbc [dos_disk_table+1],x
	sta [dos_disk_table+1],y
	lda [sd_sectorbuffer+$20+2]
	sbc [dos_disk_table+2],x
	sta [dos_disk_table+2],y
	lda [sd_sectorbuffer+$20+3]
	sbc [dos_disk_table+3],x
	sta [dos_disk_table+3],y
	

	; Get sectors per cluster (and store in dos_disk_table entry)
	; (this gets destoryed below, so we have to re-read it again after) 
	lda dos_disk_table_offset
	ora #fs_fat32_sectors_per_cluster
	tay
	lda [sd_sectorbuffer+$0D]
	sta dos_disk_table,y

	; Now divide number of sectors available for clusters by the number of
	; sectors per cluster to obtain the number of actual clusters in the file
	; system.  Since clusters must contain a power-of-two number of sectors,
	; we can implement the division using a simple shift.

	; copy number of sectors into number of sectors ready for shifting down
	

	; Put number of sectors per cluster into Z, and don't shift if there is only
	; one sector per cluster.
	taz
	and #$fe
	beq ddop_gotclustercount

ddop14:
	; Divide cluster count by two.  This is a 32-bit value, so we have to use
	; ROR to do the shift, and propagate the carry bits between the bytes.
	; This also entails doing it from the last byte, backwards.

	; Get offset of start of (sectors_per_cluster) field
	lda dos_disk_table_offset
	ora #fs_fat32_cluster_count
	; get offset of last byte in this field
	clc 
	adc #$03  
	tay

	ldx #$03
	clc
ddop15:	lda dos_disk_table,y
	ror
	sta dos_disk_table,y
	dey
	dex
	bpl ddop15

	tza
	lsr
	taz
	and #$fe
	bne ddop14
ddop_gotclustercount:

	; Re-get sectors per cluster (and store in dos_disk_table entry)
	; (this was destroyed in the calculation above)
	lda dos_disk_table_offset
	ora #fs_fat32_sectors_per_cluster
	tay
	lda [sd_sectorbuffer+$0D]
	sta dos_disk_table,y

	; filter out non-FAT32 filesystems
	; NOTE: FAT32 can have as few as 65525 clusters, but we do not support
	; such file systems, which should be rare, anyway.

	lda dos_disk_table_offset
	ora #fs_fat32_sectors_per_cluster
	tay
	lda #dos_errorcode_too_few_clusters
	sta dos_error_code
	lda dos_disk_table+3,y
	ora dos_disk_table+2,y
	beq partitionerror

	; Now get cluster of root directory.
	lda dos_disk_table_offset
	ora #fs_fat32_root_dir_cluster
	tay
	ldx #$03
ddop16:	lda [sd_sectorbuffer+$2C],x
	sta dos_disk_table,y
	dex
	bpl ddop16

	; We have now set the following fields:
	; fs_fat32_length_of_fat
	; fs_fat32_system_sectors
	; fs_fat32_reserved_clusters
	; fs_fat32_root_dir_cluster
	; fs_fat32_sectors_per_cluster
	; fs_fat32_fat_copies
	; fs_fat32_cluster0_sector
	; Our caller has set:
	; fs_start_sector
	; fs_sector_count
	; So all that is left for us is to set fs_type_and_source to $0F
	; to indicate FAT32 filesystem on the SD card ...
	lda dos_disk_table_offset
	ora #fs_type_and_source
	tay
	lda #$0f
	sta dos_disk_table,y

	; ... and increment the number of disks we know
	inc dos_disk_count

dos_return_success:
	; Return success
	lda #$00
	sta dos_error_code
	sec
	rts

dos_return_error:
	sta dos_error_code
dos_return_error_already_set:
	clc
	rts

dos_set_current_disk:
	; Is disk number valid?
	lda #dos_errorcode_no_such_disk
	cpx dos_disk_count
	bcs partitionerror

	stx dos_disk_current_disk
	txa
	asl
	asl
	asl
	asl
	asl
	sta dos_disk_table_offset
	
	sec
	rts

dos_cdroot:
	; Change to root directory on specified disk
	; (Changes current disk if required)
	; X = disk

	jsr dos_set_current_disk
	bcc dos_return_error_already_set

	; get offset of disk entry
	ldx dos_disk_table_offset
	lda [dos_disk_table+fs_fat32_root_dir_cluster+0],x
	sta dos_disk_cwd_cluster
	lda [dos_disk_table+fs_fat32_root_dir_cluster+1],x
	sta dos_disk_cwd_cluster+1
	lda #$00
	sta dos_disk_cwd_cluster+2
	sta dos_disk_cwd_cluster+3

	; Nothing else to do, as it doesn't actually affect any existing DOS activity,
	; only future file/directory operations.

	jmp dos_return_success

dos_cluster_to_sector:
	; convert a cluster number in dos_current_cluster into a sector number
	; pre-loaded into SD address registers
	; It is assumed to be on the current disk

	ldx #$03
dcts0:	lda dos_current_cluster,x
	sta $d681,x
	dex
	bpl dcts0

	; subtract 2 from the cluster number (clusters 0 and 1 don't actually exist
	; on FAT32).
	lda $d681
	sec
	sbc #$02
	sta $d681
	lda $d682
	sbc #0
	sta $d682
	lda $d683
	sbc #0
	sta $d683
	lda $d684
	sbc #0
	sta $d684
	
	; now shift it left according to fs_sectors_per_cluster
	ldx dos_disk_table_offset	
	lda dos_disk_table+fs_fat32_sectors_per_cluster,x
	tay
	and #$fe
	beq multipliedclusternumber
dcts1:	clc
	rol $D681
	rol $D682
	rol $D683
	rol $D684
	tya
	lsr
	tay
	and #$fe
	bne dcts1
multipliedclusternumber:
	ldx #$00
mmm1:	lda $d681,x
	inx
	cpx #$04
	bne mmm1

	; skip over filesystem reserved and FAT sectors
	lda dos_disk_table_offset	
	ora #fs_fat32_cluster0_sector
	tay
	ldx #$00
	clc
	php
l23:	plp
	lda $D681,x
	adc dos_disk_table,y
	sta $D681,x
	php
	iny
	inx
	cpx #$04
	bne l23
	plp	

	; add start sector of partition
	lda dos_disk_table_offset	
	ora #fs_start_sector
	tay
	ldx #$00
	clc
	php
l24:	plp
	lda $D681,x
	adc dos_disk_table,y
	sta $D681,x
	php
	iny
	inx
	cpx #$04
	bne l24
	plp

	; XXX - Check that result does not exceed fs_start_sector+fs_sector_count
	; and run over into another partition

	; return success
	sec
	rts


dos_requested_filename_to_uppercase:
	; Convert filename to upper case for comparison
	ldx dos_requested_filename_len
	cpx #$3f
	lda #dos_errorcode_name_too_long
	bcs dos_return_error
drftu1:	lda dos_requested_filename,x
	jsr toupper
	sta dos_requested_filename,x
	inx
	cpx dos_requested_filename_len
	bne drftu1
	sec
	rts

dos_get_free_descriptor:

	ldx #$00
dgfd1:	txa
	asl
	asl
	asl
	asl
	tay
	lda [dos_file_descriptors+dos_filedescriptor_offset_diskid],y
	cmp #$FF
	beq dgfd_found_free
	inx
	cpx #dos_filedescriptor_max
	bne dgfd1
	lda #dos_errorcode_too_many_open_files
	jmp dos_return_error
dgfd_found_free:
	; Clear descriptor entry
	ldy #$0f
	lda #$00
dgfd2:	sta dos_file_descriptors,y
	dey
	bne dgfd2

	; Return file descriptor in X
	stx dos_current_file_descriptor
	txa
	asl
	asl
	asl
	asl
	sta dos_current_file_descriptor_offset
	sec
	rts

dos_clearall:
	; Free all file descriptors with extreme prejudice
	lda #$ff
	sta dos_file_descriptors
	sta dos_file_descriptors+$10
	sta dos_file_descriptors+$20
	sta dos_file_descriptors+$30
	sec
	rts	

dos_closefile:
	; Close the current file/directory
	; If the file is read-only, we can just free the file descriptor and return.
	; XXX - If the file is open for write, we might have a buffer to flush.
	; (Worry about this when we implement writing. Opening files for write will
	; probably require the caller to nominate a 512 byte buffer in user-space
	; memory so that the convenience write-byte routine can work.  The other case,
	; writing a sector at a time, should just be synchronous, so that there is no
	; buffering required.)

	ldx dos_current_file_descriptor_offset
	lda dos_file_descriptors+dos_filedescriptor_offset_mode,x
	cmp #dos_filemode_readwrite
	bne dcf_simple

	; This is where we would flush the write buffer, and update file length in
	; directory, if required.  Note that to save space, we don't actually keep the
	; location of the directory entry of the file in the file descriptor.  This
	; complicates things somewhat, and we might need to change this.  However, the
	; file descriptor table must be a power of two in length, and there isn't any
	; space to double its' size.  Thus we will need a separate table that holds the
	; directory sector and entry for any file being written to.  We might save a
	; few bytes by allowing less than dos_filedescriptor_max files to be open for
	; writing at any point in time.

dcf_simple:
	ldx dos_current_file_descriptor_offset
	lda #$ff ; not allocated flag for file descriptor
	sta dos_file_descriptors+dos_filedescriptor_offset_diskid,x
	sec
	rts

dos_openfile:
	; Open the file that is in the dirent structure
	; (to open a file by arbitrary name, you must first call dos_findfile)

	; Check if the file is a directory, if so, refuse to open it.
	lda dos_dirent_type_and_attribs
	and #fs_fat32_attribute_isdirectory
	beq dof_not_a_directory

	lda #dos_errorcode_is_a_directory
	jmp dos_return_error

dof_not_a_directory:

	jsr dos_set_current_file_from_dirent
	bcc dos_return_error_already_set

	jmp dos_open_current_file

dos_findfile:
	; Convenience wrapper around dos_findfirst to make sure that we don't
	; leave any hanging file descriptors.

	jsr dos_findfirst
	php
	jsr dos_closefile
	plp
	bcc dos_return_error_already_set
	sec
	rts

dos_findfirst:
	; Search for file in current directory	

	; Convert name to upper case for searching
	jsr dos_requested_filename_to_uppercase
	bcc dos_return_error_already_set

	jsr dos_opendir
	bcc dos_return_error_already_set

	; Directory is now open, and we can now iterate through directory entries
	jmp dos_findnext


dos_findnext:
	; Keep searching in directory for another match

dff_try_next_entry:

	; Get next directory entry
	jsr dos_readdir
	bcs dff_have_next_entry

	jsr dos_closefile

	lda #dos_errorcode_file_not_found
	jmp dos_return_error
dff_have_next_entry:

	; Compare dos_dirent_longfilename with dos_requested_filename
	jsr dos_dirent_compare_name_to_requested
	; no match? try next entry
	bcc dff_try_next_entry
	
	; we have a match, so return success
	; (we don't close the file handle for the directory search, because the
	; caller may want to find multiple matches)
	sec
	rts

dos_opendir:

	; Open the current directory as a file
	jsr dos_get_free_descriptor
	bcc dos_return_error_already_set

	; get offset in file descriptor table
	txa
	asl
	asl
	asl
	asl
	tay

	; set disk id
	lda dos_disk_current_disk
	sta dos_file_descriptors+dos_filedescriptor_offset_diskid,y

	; load cluster of dir into file descriptor
	ldx #$00
dff1:	lda dos_disk_cwd_cluster,x
	sta [dos_file_descriptors+dos_filedescriptor_offset_startcluster],y
	sta [dos_file_descriptors+dos_filedescriptor_offset_currentcluster],y
	iny
	inx
	cpx #$04
	bne dff1

	; Mark file descriptor as being a directory
	ldx dos_current_file_descriptor_offset
	lda #dos_filemode_directoryaccess
	sta [dos_file_descriptors+dos_filedescriptor_offset_mode],x

	jsr dos_open_current_file
	bcc dos_return_error_already_set
	rts

dos_readdir:
	; Get the current file entry, and advance pointer
	; This requires parsing the current directory entry onwards, accumulating
	; long filename parts as required.  We only support filenames to 64 chars,
	; so long names longer than that will get ignored.
	; LFN entries have an attribute byte of $0F (normally indicates volume label)
	; LFN entries use 16-bit unicode values. For now we will just keep the lower
	; byte of these

	jsr checkpoint
	.byte 0,"dos_readdir <entry>",0

	; clear long file name data from last call
	lda #0
	sta dos_dirent_longfilename_length

	jsr dos_file_read_current_sector

	ldx dos_current_file_descriptor_offset
	lda [dos_file_descriptors+dos_filedescriptor_offset_mode],x
	cmp #dos_filemode_directoryaccess
	beq drd_isdir
	cmp #dos_filemode_end_of_directory
	bne drd_notadir

	lda #dos_errorcode_eof
	jmp dos_return_error

drd_notadir:
	; refuse to read files as directories
	lda #dos_errorcode_not_a_directory
	jmp dos_return_error

drd_isdir:

	; Clear dirent structure
	; WARNING - Uses carnal knowledge to know that dirent structure is
	; 64+1+11+4+4+1 = 85 contiguous bytes
	ldx #[dos_dirent_structure_length-1]
	lda #$00
drce1:	sta dos_dirent_longfilename,x
	dex
	bpl drce1
	
	; Read current sector
	jsr dos_file_read_current_sector
	bcc dos_return_error_already_set

	jsr sd_map_sectorbuffer
	
drce_next_piece:

	jsr checkpoint
	.byte 0,"drce_next_piece",0

	; Offset in sector correctly indicates where we need to read.
	; Sectors are 512 bytes, so we can't just do a register index.
	; Instead we will setup a 16-bit pointer.
	lda dos_current_file_descriptor_offset
	ora #dos_filedescriptor_offset_offsetinsector
	tax
	lda dos_file_descriptors,x
	sta dos_scratch_vector
	lda dos_file_descriptors+1,x
	clc
	adc #$DE   ; high byte of SD card sector buffer
	sta dos_scratch_vector+1

	; (dos_scratch_vector) now has the address of the directory entry
	ldy #fs_fat32_dirent_offset_attributes
	lda (<dos_scratch_vector),y
	cmp #$0f              ; LFN entry special attribute value
	bne drce_shortname
	; make sure long entry type is "filename" (=$00)
	ldy #fs_fat32_dirent_offset_lfn_type
	lda (<dos_scratch_vector),y
	bne drce_shortname
	
	; verify checksum of long name
	; XXX - Actually, we need to keep the checksum, and then compare it with the
	; checksum we compute on the short name to check if this is the right long
	; name.  We are just going to ignore this for now, and assume (and hope) that
	; the LFN structure is always healthy.  I am sure this will come back to bite
	; us at some point, and it can be fixed at that point in time.

	; It's a long filename piece
	; byte 0 gives the position in the LFN of this piece.
	; Each piece has 13 16-bit unicode values.
	; For now, we will only use the lower byte.  later we should gather the
	; long filenames as UTF-16, and then convert them to UTF-8.
	
	ldy #fs_fat32_dirent_offset_lfn_part_number
	lda (<dos_scratch_vector),y
	and #$3f ; mask out end of LFN indicator
	dec ; subtract one, since pieces are numbered from 1 upwards
	; each piece has 13 chars, and we only allow 64 characters total, so any
	; piece number >4 can be ignored
	cmp #5
	bcs drce_ignore_lfn_piece
	tax
	lda lfn_piece_offsets,x
	tax

	jsr checkpoint
	.byte 0,"drce_next_piece: found LFN piece",0
	
	; Copy first part of LFN
	ldy #fs_fat32_dirent_offset_lfn_part1_start
	ldz #fs_fat32_dirent_offset_lfn_part1_chars
drce2:	lda (<dos_scratch_vector),y
	beq drce_eot_in_filename
	sta dos_dirent_longfilename,x
	stx dos_dirent_longfilename_length
	inx
	; protect against over-long LFNs
	cpx #$40
	beq drce_eot_in_filename
	iny
	iny
	dez
	bne drce2

	lda #1
	jsr lfndebug

	; Copy second part of LFN
	ldy #fs_fat32_dirent_offset_lfn_part2_start
	ldz #fs_fat32_dirent_offset_lfn_part2_chars
drce3:	lda (<dos_scratch_vector),y
	beq drce_eot_in_filename
	sta dos_dirent_longfilename,x
	stx dos_dirent_longfilename_length
	inx
	; protect against over-long LFNs
	cpx #$40
	beq drce_eot_in_filename
	iny
	iny
	dez
	bne drce3

	lda #2
	jsr lfndebug

	; Copy first part of LFN
	ldy #fs_fat32_dirent_offset_lfn_part3_start
	ldz #fs_fat32_dirent_offset_lfn_part3_chars
drce4:	lda (<dos_scratch_vector),y
	beq drce_eot_in_filename
	sta dos_dirent_longfilename,x
	stx dos_dirent_longfilename_length
	inx
	; protect against over-long LFNs
	cpx #$40
	beq drce_eot_in_filename
	iny
	iny
	dez
	bne drce4

	lda #3
	jsr lfndebug
	
drce_eot_in_filename:

	jsr checkpoint
	.byte 0,"drce_eot_in_filename",0
	
	lda #4
	jsr lfndebug

	; got all characters from this LFN piece
	cpx dos_dirent_longfilename_length
	bcc drce_piece_didnt_grow_name_length
	stx dos_dirent_longfilename_length
	cpx #$3f
	bcs drce_eot_in_filename2
	; null terminate if there is space, for convenience
	lda #$00
	sta dos_dirent_longfilename,x
	stx dos_dirent_longfilename_length
drce_eot_in_filename2:

drce_piece_didnt_grow_name_length:

drce_ignore_lfn_piece:

	jsr checkpoint
	.byte 0,"drce_ignore_lfn_piece",0
    
	; We have finished processing this piece of long name.
	; bump directory entry, read next sector if required, and re-enter loop
	; above to keep accumulating

	jsr dos_readdir_advance_to_next_entry
	bcc drce_no_more_pieces

	jsr checkpoint
	.byte 0,"drce_ignore_lfn_piece <2>",0
	    
	jmp drce_next_piece
drce_no_more_pieces:
	jsr checkpoint
	.byte 0,"drce_no_more_pieces",0

	lda #dos_errorcode_eof
	jmp dos_return_error

drce_shortname:
	; We have found a short name.

	jsr checkpoint
	.byte 0,"drce_shortname",0
	
	; store short name
	ldy #fs_fat32_dirent_offset_shortname

	; Ignore empty and deleted entries (first byte $00 or $E5 respectively)
	lda (<dos_scratch_vector),y
	beq drd_deleted_or_invalid_entry
	cmp #$e5
	beq drd_deleted_or_invalid_entry

	jsr checkpoint
	.byte 0,"drce_shortname <2>",0

	ldx #$00
drce5:	lda (<dos_scratch_vector),y
	sta dos_dirent_shortfilename,x
	inx
	iny
	cpx #11
	bne drce5

	jsr checkpoint
	.byte 0,"drce5",0

	; If we have no long name, copy it also to long name, inserting "." between
	; name and extension as required.
	lda dos_dirent_longfilename_length
	bne drce_already_have_long_name

	; copy name part
	ldy #fs_fat32_dirent_offset_shortname
	ldx #$00
drce7:	lda (<dos_scratch_vector),y
	sta dos_dirent_longfilename,x
	stx dos_dirent_longfilename_length
	inx
	iny
	cmp #$20            ; space indicates end of short name before extension
	beq drce_insert_dot
	cpx #8
	bne drce7
	inx
drce_insert_dot:
	dex
	lda #'.
	sta dos_dirent_longfilename,x
	stx dos_dirent_longfilename_length
	inx
	; copy extension part
	ldy #fs_fat32_dirent_offset_shortname+8
	ldz #0
drce6:	lda (<dos_scratch_vector),y
	sta dos_dirent_longfilename,x
	stx dos_dirent_longfilename_length
	inx
	iny
	inz
	cpz #3  ; short name extensions are <=3 chars
	beq drce_copied_extension
	; also terminate extensions early if they are <3 chars
	cmp #$20
	beq drce_copied_extension
	cpx #[8+1+3]
	bne drce6
    drce_copied_extension:
	jsr checkpoint
	.byte 0,"drce_copied_extension",0

	; null terminate short name for convenience in our debugging
	lda #$00
	sta dos_dirent_longfilename,x	
	; record length of short name
	stx dos_dirent_longfilename_length

drce_already_have_long_name:

	jsr checkpoint
	.byte 0,"drce_already_have_long_name",0

	; now copy attribute field and other useful data

	; starting cluster
	ldy #fs_fat32_dirent_offset_clusters_low
	lda (<dos_scratch_vector),y
	sta dos_dirent_cluster
	iny
	lda (<dos_scratch_vector),y
	sta dos_dirent_cluster+1
	ldy #fs_fat32_dirent_offset_clusters_high
	lda (<dos_scratch_vector),y
	sta dos_dirent_cluster+2
	iny
	lda (<dos_scratch_vector),y
	sta dos_dirent_cluster+3

	; file length in bytes
	ldy #fs_fat32_dirent_offset_file_length
	ldx #0
drce_fl:
	lda (<dos_scratch_vector),y
	sta dos_dirent_length,x
	iny
	inx
	cpx #4
	bne drce_fl

	; attributes
	ldy #fs_fat32_dirent_offset_attributes
	lda (<dos_scratch_vector),y
	sta dos_dirent_type_and_attribs

	jsr checkpoint
	.byte 0,"drce_fl <1>",0

	jsr dos_readdir_advance_to_next_entry
	bcs drce_noteof

	jsr checkpoint
	.byte 0,"drce_fl <2>",0

	; We need to pass the error through here to indicate EOF in directory,
	; but in a way that can be defered to the next call to dos_readdir, because
	; we have a valid entry right now.  We do this with a special file mode which
	; is EOF of directory (dos_filemode_end_of_directory)
	ldx dos_current_file_descriptor_offset
	lda #dos_filemode_end_of_directory
	sta dos_file_descriptors+dos_filedescriptor_offset_mode,x

	ldx dos_current_file_descriptor_offset
	lda [dos_file_descriptors+dos_filedescriptor_offset_mode],x


drce_noteof:

	jsr checkpoint
	.byte 0,"drce_noteof",0

	; Ignore zero-length filenames (corresponding to empty directory entries)
	lda dos_dirent_longfilename_length
	cmp #0
	beq dos_readdir
	lda dos_dirent_shortfilename
	cmp #$20
	beq dos_readdir
	cmp #$00
	beq dos_readdir

	sec
	rts

lfndebug:
	ora #$30
	sta fnmsg1-4
	
	; Show what we have in the filename so far
	phx
	ldx #29
drce23:	lda dos_dirent_longfilename,x
	bne drce22
	lda #$3f
drce22:	sta fnmsg1,x
	dex
	bpl drce23
	plx


	jsr checkpoint
	.byte 0,"LFN(1): "
fnmsg1:
	.byte "..............................",0

	rts

drd_deleted_or_invalid_entry:
	jsr checkpoint
	.byte 0,"drd_deleted_or_invalid_entry",0

	jsr dos_readdir_advance_to_next_entry
	bcs dos_readdir
	jmp dos_return_error_already_set


lfn_piece_offsets:
	.byte 0,13,13*2,13*3,13*4

dos_dirent_compare_name_to_requested:

	; print debug message showing what we are comparing

	; print filename for debug

	; Do the cheap check of comparing the lengths first
	lda dos_dirent_longfilename_length
	cmp dos_requested_filename_len
	bne dff3

	; lengths match, so compare bytes
	; XXX - Needs to support * and ?
	; see http://6502.org/source/strings/patmatch.htm for a routine to take
	; inspiration from.
	ldx dos_dirent_longfilename_length
	dex
dff4:	lda dos_dirent_longfilename,x
	cmp dos_requested_filename,x
	bne dff3
	dex
	bne dff4

	; File names match, so return success
	sec
	rts

dff3:
	; file names don't match, so return failure
	clc
	rts

dos_readdir_advance_to_next_entry:
	ldy dos_current_file_descriptor_offset
	
	clc
	lda dos_file_descriptors+dos_filedescriptor_offset_offsetinsector+0,y
	adc #$20 ; length of FAT32/VFAT directory entry
	sta dos_file_descriptors+dos_filedescriptor_offset_offsetinsector+0,y
	bne dratne_done

	; Increment upper byte
	lda dos_file_descriptors+dos_filedescriptor_offset_offsetinsector+1,y
	inc
	cmp #$01
	bne drce_end_of_sector
	sta dos_file_descriptors+dos_filedescriptor_offset_offsetinsector+1,y
dratne_done:
	sec
	rts

drce_end_of_sector:
	; Reset pointer back to start of sector
	lda #$00
	sta dos_file_descriptors+dos_filedescriptor_offset_offsetinsector+1,y

	jsr dos_file_advance_to_next_sector
	rts

dos_set_current_file_from_dirent:
	; copy start cluster from dirent to start and current cluster
	jsr dos_get_free_descriptor
	jsr dos_get_file_descriptor_offset
	bcc dos_return_error_already_set

	; set disk id
	lda dos_disk_current_disk
	sta dos_file_descriptors+dos_filedescriptor_offset_diskid,x

	; set current cluster to start cluster
	ldy #0
dscffd1:
	lda dos_dirent_cluster,y
	sta dos_file_descriptors+dos_filedescriptor_offset_startcluster,x
	sta dos_file_descriptors+dos_filedescriptor_offset_currentcluster,x
	inx
	iny
	cpy #4
	bne dscffd1

	jsr dos_get_file_descriptor_offset
	bcc dos_return_error_already_set

	; set disk id
	lda dos_disk_current_disk
	sta dos_file_descriptors+dos_filedescriptor_offset_diskid,x

	; set mode
	lda #dos_filemode_readonly
	sta dos_file_descriptors+dos_filedescriptor_offset_mode,x

	; set sector in cluster (set to 0)
	lda #$00
	sta dos_file_descriptors+dos_filedescriptor_offset_sectorincluster,x
	; set offset in sector (set to 0)
	sta dos_file_descriptors+dos_filedescriptor_offset_offsetinsector+0,x
	sta dos_file_descriptors+dos_filedescriptor_offset_offsetinsector+1,x

	sec
	rts

dos_open_current_file:
	; copy start cluster to current cluster, and zero position in file
	jsr dos_get_file_descriptor_offset
	bcc dos_return_error_already_set

	; Copy start cluster to current cluster
	ldy #3
docf1:	lda dos_file_descriptors+dos_filedescriptor_offset_startcluster,x
	sta dos_file_descriptors+dos_filedescriptor_offset_currentcluster,x
	inx
	dey
	bpl docf1
	jsr dos_get_file_descriptor_offset
	lda #$00

	; sectorincluster, offsetinsector, fileoffset are contiguous, which allows
	; us to clear these more efficiently.
	ldy #6
docf2:	sta dos_file_descriptors+dos_filedescriptor_offset_sectorincluster,x
	inx
	dey
	bne docf2

	jsr dos_get_file_descriptor_offset

	sec
	rts


dos_get_file_descriptor_offset:
	lda dos_current_file_descriptor
	cmp #4
	bcs dos_bad_file_descriptor
	asl
	asl
	asl
	asl
	tax
	sec
	rts

dos_bad_file_descriptor:
	lda #dos_errorcode_invalid_file_descriptor
	jmp dos_return_error

dos_set_current_cluster_from_file:
	; copy cluster number in file to current cluster
	jsr dos_get_file_descriptor_offset
	bcc dos_return_error_already_set
	ldy #$00
dfrcs1:	lda dos_file_descriptors+dos_filedescriptor_offset_currentcluster,x
	sta dos_current_cluster,y
	inx
	iny
	cpy #$04
	bne dfrcs1
	rts

dos_file_read_current_sector:
	jsr dos_set_current_cluster_from_file
	jsr dos_cluster_to_sector

	; Add sector within cluster
	jsr dos_get_file_descriptor_offset
	bcc dos_return_error_already_set
	ora #dos_filedescriptor_offset_sectorincluster
	tay
	ldx #$00
	clc
	lda dos_file_descriptors,y
	bne dfrcs4
dfrcs2: lda #$00
dfrcs4:
	adc $d681,x
	sta $d681,x
	bcc dfrcs_inced
	inx
	cpx #$04
	bne dfrcs2
dfrcs_inced:

	jsr sd_fix_sectornumber
	jmp sd_readsector

dos_file_advance_to_next_sector:

	; Increment file position offset by 2 pages
	ldx dos_current_file_descriptor_offset

	lda dos_file_descriptors+dos_filedescriptor_offset_fileoffset+0,x
	clc
	adc #$02
	sta dos_file_descriptors+dos_filedescriptor_offset_fileoffset+0,x
	bcc dfatns1
	inc dos_file_descriptors+dos_filedescriptor_offset_fileoffset+1,x
	bne dfatns1
	inc dos_file_descriptors+dos_filedescriptor_offset_fileoffset+2,x
dfatns1:
	
	; increase sector
	inc dos_file_descriptors+dos_filedescriptor_offset_sectorincluster,x
	lda dos_file_descriptors+dos_filedescriptor_offset_sectorincluster,x
	ldy dos_disk_table_offset

	cmp dos_disk_table+fs_fat32_sectors_per_cluster,y
	; and if necessary, advance to next cluster
	beq dos_file_advance_to_next_cluster
	sec
	rts

dos_file_advance_to_next_cluster:

	; set to sector 0 in cluster
	ldy dos_current_file_descriptor_offset
	lda #$00
	sta dos_file_descriptors+dos_filedescriptor_offset_sectorincluster,y

	; read chained cluster number for fs_clusternumber

	; FAT32 uses 32-bit cluster numbers.
	; 512 / 4 = 128 cluster numbers per sector.
	; To get the sector of the FAT containin a particular
	; cluster entry, we thus need to shift the cluster number
	; right 7 bits.  Then we add the start sector number of the FAT.

	jsr dos_set_current_cluster_from_file	

	; copy cluster to sector number
	ldx #$03
dfanc1:
	lda dos_current_cluster,x
	sta dos_current_sector,x
	dex
	bpl dfanc1

	; Remember low byte of cluster number so that we can pull the
	; cluster number for the next cluster out of the FAT sector
	lda dos_current_cluster
	sta dos_scratch_byte_1

	; shift right 7 times = divide by 128
	ldy #$07
dfanc2:	clc		
	ror dos_current_cluster+3
	ror dos_current_cluster+2
	ror dos_current_cluster+1
	ror dos_current_cluster+0
	dey
	bne dfanc2

	; add start of partition offset
	ldy dos_disk_table_offset
	ldx #$00
	clc
	php
dfanc3:	plp
	lda dos_current_cluster,x
	adc dos_disk_table+fs_start_sector,y
	sta dos_current_cluster,x
	php
	iny
	inx
	cpx #$04
	bne dfanc3
	plp

	; add start of fat offset
	ldy dos_disk_table_offset
	ldx #$00
	clc
	php
dfanc4:	plp
	lda dos_current_cluster,x
	adc dos_disk_table+fs_fat32_system_sectors,y
	sta dos_current_cluster,x
	php
	iny
	inx
	cpx #$02
	bne dfanc4

	; copy from current cluster to SD sector address register
	ldx #$03
dfanc41:
	lda dos_current_cluster,x
	sta $d681,x
	dex
	bpl dfanc41

dfanc44:
	plp
	lda dos_current_cluster,x
	adc #$00
	sta dos_current_cluster,x
	php
	inx
	cpx #$04
	bne dfanc44

	plp

	; turn sector number into byte address for non-SDHC cards
	jsr sd_fix_sectornumber

	; read FAT sector
	jsr sd_readsector
	bcc dos_return_error_already_set

	jsr sd_map_sectorbuffer

	; now read the right four bytes out.
	; cluster number needs to be shifted left 2 bits.
	; we only need the lowest order byte.
	; Get low byte of old cluster number from dos_scratch_byte_1
	; where we put it.
	lda dos_scratch_byte_1
	asl
	asl
	tax

	; get offset to current cluster field in current file descriptor ...
	lda dos_current_file_descriptor_offset
	ora #dos_filedescriptor_offset_currentcluster
	tay
	; ... and keep it handy, because we will need it a few times
	sty dos_scratch_byte_2

	; get offset of current cluster number field in file descriptor
	; so that we can write the new cluster number in there.
	ldy dos_scratch_byte_2
	
	ldz #$00
	lda dos_scratch_byte_1
	and #$40
	bne dfanc_high
dfanc6:	lda $de00,x
	sta dos_file_descriptors,y
	inx
	iny
	inz
	cpz #$04
	bne dfanc6
	bra dfanc_check
dfanc_high:
	lda $df00,x
	sta dos_file_descriptors,y
	inx
	iny
	inz
	cpz #$04
	bne dfanc_high
dfanc_check:
	; check that resulting cluster number is valid.

	ldy #$00
	; get current cluster field address again
	lda dos_file_descriptors+3,y
	taz
	phy
	jsr printhex
	ply
	lda dos_file_descriptors+2,y
	taz
	phy
	jsr printhex
	ply
	lda dos_file_descriptors+1,y
	taz
	phy
	jsr printhex
	ply
	lda dos_file_descriptors+0,y
	taz
	jsr printhex


	; get current cluster field address again
	ldy dos_scratch_byte_2

	; First, only the lower 28-bits are valid
	lda dos_file_descriptors+3,y
	and #$0f
	sta dos_file_descriptors+3,y

	; Now check for special values:
	; cluster 0 is invalid
	lda dos_file_descriptors+3,y
	ora dos_file_descriptors+2,y
	ora dos_file_descriptors+1,y
	ora dos_file_descriptors,y
	cmp #$00
	beq dfanc_fail
	; $FFFFFF7 = bad cluster
	; $FFFFFFF = end of file
	lda dos_file_descriptors+3,y
	cmp #$0f
	bne dfanc_ok
	lda dos_file_descriptors+2,y
	cmp #$ff
	bne dfanc_ok
	lda dos_file_descriptors+1,y
	cmp #$ff
	bne dfanc_ok
	lda dos_file_descriptors,y
	cmp #$ff
	beq dfanc_fail
	cmp #$f7
	beq dfanc_fail

dfanc_ok:
	; cluster number is okay
	sec
	rts

dfanc_fail:
	lda #dos_errorcode_invalid_cluster
	jmp dos_return_error

dos_print_current_cluster:
	ldx #<msg_clusternumber
	ldy #>msg_clusternumber
	jsr printmessage
	ldy #$00
	ldz dos_current_cluster+3
	jsr printhex
	ldz dos_current_cluster+2
	jsr printhex
	ldz dos_current_cluster+1
	jsr printhex
	ldz dos_current_cluster+0
	jmp printhex

	
dos_readfileintomemory:
	; file name must be already loaded into dos_requested_filename,
	; with length in dos_requreste_filename_length

	; Clear number of sectors read
	ldx #$00
	stx dos_sectorsread
	stx dos_sectorsread+1

	jsr dos_findfirst
	php
	; close directory now that we have what we were looking for ...
	jsr dos_closefile
	plp
	; ... but report if we hit an error
	bcc dos_return_error_already_set

	jsr dos_openfile
	bcc dos_return_error_already_set

	jsr sd_map_sectorbuffer

drfim_sector_loop:
	jsr dos_file_read_current_sector
	bcc drfim_eof

	; copy sector to memory
	ldx #$00
	ldz #$00
drfim_rr1:
	lda $de00,x
	nop ; 32-bit pointer access follows
	sta (<dos_file_loadaddress),z
	inz
	inx
	bne drfim_rr1
	inw <dos_file_loadaddress+1
drfim_rr1b:
	lda $df00,x
	nop ; 32-bit pointer access follows
	sta (<dos_file_loadaddress),z
	inz
	inx
	bne drfim_rr1b

	jsr dos_file_advance_to_next_sector
	bcc drfim_eof

	; We only allow loading into a 16MB space
	; Provided that we check the load address before starting,
	; this ensures that a user-land request cannot load a huge file
	; that eventually overwrites the hypervisor and results in privilege
	; escalation.
	inw <dos_file_loadaddress+1

	; Increment number of sectors read (16 bit valie)
	inc dos_sectorsread
	bne drfim_sector_loop
	inc dos_sectorsread+1
	; see if there is another sector
	bne drfim_sector_loop

	jsr dos_closefile

	; File is >65535 sectors (32MB), report error
	lda #dos_errorcode_file_too_long
	jmp dos_return_error
drfim_eof:
	jsr dos_closefile
	jmp dos_return_success

dos_setname:
	stx dos_scratch_vector
	sty dos_scratch_vector+1
	ldy #$00
lr11:	lda (<dos_scratch_vector),y
	sta dos_requested_filename,y
	beq dsn_eon
	iny
	cpy #$40
	bne lr11
	lda #0
	sta dos_requested_filename_len
	lda #dos_errorcode_name_too_long
	clc
	rts
dsn_eon:
	sty dos_requested_filename_len

	sec
	rts

dos_d81attach:
	jsr checkpoint
	.byte 0,"dos_d81attach",0

	; Assumes only that D81 file name has been set with dos_setname.
		jsr dos_findfile
		bcs d81a1
		lda #dos_errorcode_file_not_found
		clc
		rts
		
d81a1:		; XXX - Why do we call closefile here?
		jsr dos_closefile

		; now we need to check that the file is long enough,
		; and also that the clusters are contiguous.

		; Start by opening the file
		jsr dos_set_current_file_from_dirent
		bcc nod81
		jsr dos_openfile
		bcc nod81
		
		; work out how many clusters we need
		; We need 1600 sectors, so halve for every zero tail
		; bit in sectors per cluster.  we can do this because
		; clusters in FAT must be 2^n sectors.
		lda #$00
		sta d81_clustercount 
		sta d81_clustercount+1
		lda #<1600
		sta d81_clustersneeded
		lda #>1600
		sta d81_clustersneeded+1

		; get sectors per cluster of disk
		ldx dos_disk_table_offset
		lda dos_disk_table+fs_fat32_sectors_per_cluster,x
		taz

l94:		tza
		and #$01
		bne d81firstcluster
		tza
		lsr
		taz
		lsr d81_clustersneeded+1
		ror d81_clustersneeded
		jmp l94				

d81firstcluster:
		; Get current cluster of D81 file, so that
		; we can check that clusters in file are contiguous
		ldx dos_current_file_descriptor_offset
		ldy #0
l94b:		lda dos_file_descriptors+dos_filedescriptor_offset_currentcluster,x
		sta d81_clusternumber,y
		inx
		iny
		cpy #4
		bne l94b

d81nextcluster:
		; Now read through clusters and make sure that all is
		; well.

		; check that it matches expected cluster number
		ldx dos_current_file_descriptor_offset
		ldy #0
l94a:		lda dos_file_descriptors+dos_filedescriptor_offset_currentcluster,x
		cmp d81_clusternumber,y
		bne d81isfragged
		inx
		iny
		cpy #4
		bne l94a

		; increment number of clusters found so far
		inc d81_clustercount
		bne l96
		inc d81_clustercount+1
l96:

		; increment expected cluster number
		clc
		lda d81_clusternumber
		adc #$01
		sta d81_clusternumber
		lda d81_clusternumber+1
		adc #$00
		sta d81_clusternumber+1
		lda d81_clusternumber+2
		adc #$00
		sta d81_clusternumber+2
		lda d81_clusternumber+3
		adc #$00
		sta d81_clusternumber+3

		jsr dos_file_advance_to_next_cluster
		bcs d81nextcluster

		; The above continues until EOF is reached, so clear DOS
		; error after.
		lda #$00
		sta dos_error_code

		jsr checkpoint
		.byte 0,"dos_d81attach <measured end of image>",0

		jsr dos_closefile

		; read to end of D81 file, and it is contiguous
		; now check that it is the right length

		lda d81_clustersneeded
		cmp d81_clustercount
		bne d81wronglength
		
		lda d81_clustersneeded+1
		cmp d81_clustercount+1
		bne d81wronglength

		; D81 is good, so set flags to indicate it is mounted
		; (but read-only)
		lda #$03
		sta $d68b

		jsr checkpoint
		.byte 0,"dos_d81attach <success>",0

		sec
		rts
		
d81wronglength:
		jsr checkpoint
		.byte 0,"dos_d81attach <wrong length>",0

		lda #dos_errorcode_image_wrong_length
		sta dos_error_code
		clc
		rts		

d81isfragged:
		jsr checkpoint
		.byte 0,"dos_d81attach <fragmented>",0

		lda #dos_errorcode_image_fragmented
		sta dos_error_code
		clc
		rts
nod81:
		jsr checkpoint
		.byte 0,"dos_d81attach <file not found>",0

		clc
		rts
