C64 $0000000 6510/45GS10 CPU port DDR
C64 $0000000 CPU:PORTDDR 6510/45GS10 CPU port DDR
C64 $0000001 6510/45GS10 CPU port data
C64 $0000001 CPU:PORT 6510/45GS10 CPU port data
C64 $0000002-$000FFFF - 64KB RAM
C65 $0010000-$001FFFF - 64KB RAM
C65 $0020000-$003FFFF - 128KB ROM (can be used as RAM in M65 mode)
C65 $002A000-$002BFFF - 8KB C64 BASIC ROM
C65 $002D000-$002DFFF - 4KB C64 CHARACTER ROM
C65 $002E000-$002FFFF - 8KB C64 KERNAL ROM
C65 $0030000-$0031FFF - 16KB C65 DOS ROM
C65 $0032000-$0035FFF - 8KB C65 BASIC ROM
C65 $0038000-$003BFFF - 8KB C65 BASIC GRAPHICS ROM
C65 $003C000-$003CFFF - 4KB C65 KERNAL/INTERFACE ROM
C65 $003E000-$003FFFF - 8KB C65 KERNAL ROM
GS $4000000 - $7FFFFFF Slow Device memory (64MB)
GS $4000000 - $7FFFFFF SUMMARY:SLOWDEV Slow Device memory (64MB)
GS $7010000.4-0 - Read /EXROM & /GAME signal probe count (MEGA65 R1 PCB only)
GS $7010000.5 - Force assertion of /RESET on cartridge port
GS $7010000.5 - Read cartridge force reset (1=reset)
GS $7010000.6 - Read cartridge /EXROM flag
GS $7010000.7 - Read cartridge /EXROM flag
GS $7010001.0-4 - Directly read lower 5 bits of cartridge port data lines.
GS $7010001.5 - Joystick read toggle flag DEBUG
GS $7010001.6 - 1=force joystick expansion mode.
GS $7010001.6 - Force enabling of joystick expander cartridge
GS $7010001.7 - Expansion port mode: 1=normal mode, 0=joystick expansion mode
GS $7010002 - Counter of /IRQ triggers from cartridge
GS $7010003 - Counter of /NMI triggers from cartridge
GS $7010004 - Counter of /DMA triggers from cartridge
GS $7010005 - Counter of /GAME triggers from cartridge
GS $7010006 - Counter of /EXROM triggers from cartridge
GS $8000000 - $FEFFFFF Slow Device memory (127MB)
GS $8000000 - $FEFFFFF SUMMARY:SLOWDEV Slow Device memory (127MB)
C64 $D000 VIC-II:S0X sprite 0 horizontal position
C64 $D001 VIC-II:S0Y sprite 0 vertical position
C64 $D002 VIC-II:S1X sprite 1 horizontal position
C64 $D003 VIC-II:S1Y sprite 1 vertical position
C64 $D004 VIC-II:S2X sprite 2 horizontal position
C64 $D005 VIC-II:S2Y sprite 2 vertical position
C64 $D006 VIC-II:S3X sprite 3 horizontal position
C64 $D007 VIC-II:S3Y sprite 3 vertical position
C64 $D008 VIC-II:S4X sprite 4 horizontal position
C64 $D009 VIC-II:S4Y sprite 4 vertical position
C64 $D00A VIC-II:S5X sprite 5 horizontal position
C64 $D00B VIC-II:S5Y sprite 5 vertical position
C64 $D00C VIC-II:S6X sprite 6 horizontal position
C64 $D00D VIC-II:S6Y sprite 6 vertical position
C64 $D00E VIC-II:S7X sprite 7 horizontal position
C64 $D00F VIC-II:S7Y sprite 7 vertical position
C64 $D010 VIC-II:SXMSB sprite horizontal position MSBs
C64 $D011.2-0 VIC-II:YSCL 24/25 vertical smooth scroll
C64 $D011.3 VIC-II:RSEL 24/25 row select
C64 $D011.4 VIC-II:BLNK disable display
C64 $D011.5 VIC-II:BMM bitmap mode
C64 $D011.6 VIC-II:ECM extended background mode
C64 $D011.7 VIC-II:RC raster compare bit 8
C64 $D011 VIC-II control register
C64 $D012 VIC-II:RC raster compare bits 0 to 7
C64 $D013 VIC-II:LPX Coarse horizontal beam position (was lightpen X)
C64 $D014 VIC-II:LPY Coarse vertical beam position (was lightpen Y)
C64 $D015 VIC-II:SE sprite enable bits
C64 $D016.2-0 VIC-II:XSCL horizontal smooth scroll
C64 $D016.3 VIC-II:CSEL 38/40 column select
C64 $D016.4 VIC-II:MCM Multi-colour mode
C64 $D016.5 VIC-II:RST Disables video output on MAX Machine(tm) VIC-II 6566.  Ignored on normal C64s and the MEGA65
C64 $D016 VIC-II control register
C64 $D017 VIC-II:SEXY sprite vertical expansion enable bits
C64 $D018.3-1 VIC-II:CB character set address location ($\times$ 1KiB)
C64 $D018.7-4 VIC-II:VS screen address ($\times$ 1KiB)
C64 $D018 VIC-II RAM addresses
C64 $D019.0 VIC-II:RIRQ raster compare indicate or acknowledge
C64 $D019.1 VIC-II:ISBC sprite:bitmap collision indicate or acknowledge
C64 $D019.2 VIC-II:ISSC sprite:sprite collision indicate or acknowledge
C64 $D019.3 VIC-II:ILP light pen indicate or acknowledge
C64 $D019 VIC-II IRQ control
C64 $D01A.0 VIC-II:MRIRQ mask raster IRQ
C64 $D01A.1 VIC-II:MISBC mask sprite:bitmap collision IRQ
C64 $D01A.2 VIC-II:MISSC mask sprite:sprite collision IRQ
C64 $D01A compatibility IRQ mask bits
C64 $D01B VIC-II:BSP sprite background priority bits
C64 $D01C VIC-II:SCM sprite multicolour enable bits
C64 $D01D VIC-II:SEXX sprite horizontal expansion enable bits
C64 $D01E sprite/sprite collissions
C64 $D01E VIC-II:SSC sprite/sprite collision indicate bits
C64 $D01F sprite/foreground collissions
C64 $D01F VIC-II:SBC sprite/foreground collision indicate bits
C64 $D020.3-0 VIC-II:BORDERCOL display border colour (16 colour)
C65 $D020.7-0 VIC-III:BORDERCOL display border colour (256 colour)
GS $D020.7-0 VIC-IV:BORDERCOL display border colour (256 colour)
C64 $D020 Border colour
C64 $D021.3-0 VIC-II:SCREENCOL screen colour (16 colour)
C65 $D021.7-0 VIC-III:SCREENCOL screen colour (256 colour)
GS $D021.7-0 VIC-IV:SCREENCOL screen colour (256 colour)
C64 $D021 Screen colour
C64 $D022.3-0 VIC-II:MC1 multi-colour 1 (16 colour)
C65 $D022.7-0 VIC-III:MC1 multi-colour 1 (256 colour)
GS $D022.7-0 VIC-IV:MC1 multi-colour 1 (256 colour)
C64 $D022 VIC-II multi-colour 1
C64 $D023.3-0 VIC-II:MC2 multi-colour 2 (16 colour)
C65 $D023.7-0 VIC-III:MC2 multi-colour 2 (256 colour)
GS $D023.7-0 VIC-IV:MC2 multi-colour 2 (256 colour)
C64 $D023 VIC-II multi-colour 2
C64 $D024.3-0 VIC-II:MC3 multi-colour 3 (16 colour)
C65 $D024.7-0 VIC-III:MC3 multi-colour 3 (256 colour)
GS $D024.7-0 VIC-IV:MC3 multi-colour 3 (256 colour)
C64 $D024 VIC-II multi-colour 3
C65 $D025 VIC-III:SPRMC0 Sprite multi-colour 0 (8-bit for selection of any palette colour)
C64 $D025 VIC-II:SPRMC0 Sprite multi-colour 0
GS $D025 VIC-IV:SPRMC0 Sprite multi-colour 0 (8-bit for selection of any palette colour)
C65 $D026 VIC-III:SPRMC1 Sprite multi-colour 1 (8-bit for selection of any palette colour)
C64 $D026 VIC-II:SPRMC1 Sprite multi-colour 1
GS $D026 VIC-IV:SPRMC1 Sprite multi-colour 1 (8-bit for selection of any palette colour)
C64 $D027 VIC-II:SPR0COL sprite 0 colour / 16-colour sprite transparency colour (lower nybl)
C64 $D028 VIC-II:SPR1COL sprite 1 colour / 16-colour sprite transparency colour (lower nybl)
C64 $D029 VIC-II:SPR2COL sprite 2 colour / 16-colour sprite transparency colour (lower nybl)
C64 $D02A VIC-II:SPR3COL sprite 3 colour / 16-colour sprite transparency colour (lower nybl)
C64 $D02B VIC-II:SPR4COL sprite 4 colour / 16-colour sprite transparency colour (lower nybl)
C64 $D02C VIC-II:SPR5COL sprite 5 colour / 16-colour sprite transparency colour (lower nybl)
C64 $D02D VIC-II:SPR6COL sprite 6 colour / 16-colour sprite transparency colour (lower nybl)
C64 $D02E VIC-II:SPR7COL sprite 7 colour / 16-colour sprite transparency colour (lower nybl)
C65 $D02F VIC-III KEY register for unlocking extended registers.
C65 $D02F VIC-III:KEY Write $A5 then $96 to enable C65/VIC-III IO registers
GS $D02F VIC-IV:KEY Write $47 then $53 to enable C65GS/VIC-IV IO registers
C65 $D02F Write anything else to return to C64/VIC-II IO map
C64 $D030.0 VIC-II:C128FAST 2MHz select (for C128 2MHz emulation)
C65 $D030.0 VIC-III:CRAM2K Map 2nd KB of colour RAM \@ \$DC00-\$DFFF
C65 $D030.1 VIC-III:EXTSYNC Enable external video sync (genlock input)
C65 $D030.2 VIC-III:PAL Use PALETTE ROM or RAM entries for colours 0 - 15
C65 $D030.3 VIC-III:ROM8 Map C65 ROM \@ \$8000
C65 $D030.4 VIC-III:ROMA Map C65 ROM \@ \$A000
C65 $D030.5 VIC-III:ROMC Map C65 ROM \@ \$C000
C65 $D030.6 VIC-III:CROM9 Select between C64 and C65 charset.
C65 $D030.7 VIC-III:ROME Map C65 ROM \@ \$E000
C64 $D030 SUMMARY: C128 2MHz emulation
C65 $D030 SUMMARY:VIC-III Control Register A
C65 $D031.0 VIC-III:INT Enable VIC-III interlaced mode
C65 $D031.1 VIC-III:MONO Enable VIC-III MONO video output (not implemented)
C65 $D031.2 VIC-III:H1280 Enable 1280 horizontal pixels (not implemented)
C65 $D031.3 VIC-III:V400 Enable 400 vertical pixels
C65 $D031.4 VIC-III:BPM Bit-Plane Mode
C65 $D031.5 VIC-III:ADDR Enable extended attributes and 8 bit colour entries
C65 $D031.6 VIC-III:FAST Enable C65 FAST mode (\~3.5MHz)
C65 $D031.7 VIC-III:H640 Enable C64 640 horizontal pixels / 80 column mode
C65 $D031 SUMMARY:VIC-III Control Register B
C65 $D032 - Bitplane enable bits
C65 $D033.1-3 VIC-III:B0ADEVN - Bitplane 0 address, even lines
C65 $D033.5-7 VIC-III:B0ADODD - Bitplane 0 address, odd lines
C65 $D033 - Bitplane 0 address
C65 $D033-$D03A - VIC-III Bitplane addresses
C65 $D034.1-3 VIC-III:B1ADEVN - Bitplane 1 address, even lines
C65 $D034.5-7 VIC-III:B1ADODD - Bitplane 1 address, odd lines
C65 $D034 - Bitplane 1 address
C65 $D035.1-3 VIC-III:B2ADEVN - Bitplane 2 address, even lines
C65 $D035.5-7 VIC-III:B2ADODD - Bitplane 2 address, odd lines
C65 $D035 - Bitplane 2 address
C65 $D036.1-3 VIC-III:B3ADEVN - Bitplane 3 address, even lines
C65 $D036.5-7 VIC-III:B3ADODD - Bitplane 3 address, odd lines
C65 $D036 - Bitplane 3 address
C65 $D037.1-3 VIC-III:B4ADEVN - Bitplane 4 address, even lines
C65 $D037.5-7 VIC-III:B4ADODD - Bitplane 4 address, odd lines
C65 $D037 - Bitplane 4 address
C65 $D038.1-3 VIC-III:B5ADEVN - Bitplane 5 address, even lines
C65 $D038.5-7 VIC-III:B5ADODD - Bitplane 5 address, odd lines
C65 $D038 - Bitplane 5 address
C65 $D039.1-3 VIC-III:B6ADEVN - Bitplane 6 address, even lines
C65 $D039.5-7 VIC-III:B6ADODD - Bitplane 6 address, odd lines
C65 $D039 - Bitplane 6 address
C65 $D03A.1-3 VIC-III:B7ADEVN - Bitplane 7 address, even lines
C65 $D03A.5-7 VIC-III:B7ADODD - Bitplane 7 address, odd lines
C65 $D03A - Bitplane 7 address
C65 $D03B - Set bits to NOT bitplane contents
C65 $D03B VIC-III:BPCOMP Complement bitplane flags
C65 $D03C - Bitplane X
C65 $D03C VIC-III:BPX Bitplane X
C65 $D03D - Bitplane Y
C65 $D03D VIC-III:BPY Bitplane Y
C65 $D03E - Horizontal position (screen verniers?)
C65 $D03E VIC-III:HPOS Bitplane X Offset
C65 $D03F - Vertical position (screen verniers?)
C65 $D03F VIC-III:VPOS Bitplane Y Offset
C65 $D040 VIC-III:B0PIX Display Address Translater (DAT) Bitplane 0 port
C65 $D041 VIC-III:B1PIX Display Address Translater (DAT) Bitplane 1 port
C65 $D042 VIC-III:B2PIX Display Address Translater (DAT) Bitplane 2 port
C65 $D043 VIC-III:B3PIX Display Address Translater (DAT) Bitplane 3 port
C65 $D044 VIC-III:B4PIX Display Address Translater (DAT) Bitplane 4 port
C65 $D045 VIC-III:B5PIX Display Address Translater (DAT) Bitplane 5 port
C65 $D046 VIC-III:B6PIX Display Address Translater (DAT) Bitplane 6 port
C65 $D047 VIC-III:B7PIX Display Address Translater (DAT) Bitplane 7 port
GS $D048 VIC-IV:TBDRPOS top border position
GS $D049.3-0 VIC-IV:TBDRPOS top border position MSB
GS $D049.7-4 VIC-IV:SPRBPMEN Sprite bitplane-modify-mode enables
GS $D04A VIC-IV:BBDRPOS bottom border position
GS $D04B.3-0 VIC-IV:BBDRPOS bottom border position
GS $D04B.7-4 VIC-IV:SPRBPMEN Sprite bitplane-modify-mode enables
GS $D04C VIC-IV:TEXTXPOS character generator horizontal position
GS $D04D.3-0 VIC-IV:TEXTXPOS character generator horizontal position
GS $D04D.7-4 VIC-IV:SPRTILEN Sprite horizontal tile enables.
GS $D04E VIC-IV:TEXTYPOS Character generator vertical position
GS $D04F.3-0 VIC-IV:TEXTYPOS Character generator vertical position
GS $D04F.7-4 VIC-IV:SPRTILEN Sprite 7-4 horizontal tile enables
GS $D050.0-5 VIC-IV:XPOS Read horizontal raster scan position
GS $D051 VIC-IV:XPOS Read horizontal raster scan position
GS $D052 VIC-IV:FNRASTER Read physical raster position
GS $D053.0-2 VIC-IV:FNRASTER Read physical raster position
GS $D053.7 VIC-IV:FNRST Raster compare source (1=VIC-IV fine raster, 0=VIC-II raster)
GS $D054.0 VIC-IV:CHR16 enable 16-bit character numbers (two screen bytes per character)
GS $D054.1 VIC-IV:FCLRLO enable full-colour mode for character numbers <=\$FF
GS $D054.2 VIC-IV:FCLRHI enable full-colour mode for character numbers >\$FF
GS $D054.3 VIC-IV:SMTH video output horizontal smoothing enable
GS $D054.4 VIC-IV:SPR640 Sprite H640 enable;
GS $D054.5 VIC-IV:PALEMU video output pal simulation
GS $D054.6 VIC-IV:VFAST C65GS FAST mode (48MHz)
GS $D054.7 VIC-IV:ALPHEN Alpha compositor enable
GS $D054 SUMMARY:VIC-IV Control register C
GS $D055 VIC-IV:SPRHGTEN sprite extended height enable (one bit per sprite)
GS $D056 VIC-IV:SPRHGHT Sprite extended height size (sprite pixels high)
GS $D057 VIC-IV:SPRX64EN Sprite extended width enables (8 bytes per sprite row = 64 pixels wide for normal sprites or 16 pixels wide for 16-colour sprite mode)
GS $D058 VIC-IV:CHARSTEP characters per logical text row (LSB)
GS $D059 VIC-IV:CHARSTEP characters per logical text row (MSB)
GS $D05A VIC-IV:CHRXSCL Horizontal hardware scale of text mode (pixel 120ths per pixel)
GS $D05B VIC-IV:CHRYSCL Vertical scaling of text mode (number of physical rasters per char text row)
GS $D05C VIC-IV:SIDBDRWD Width of single side border
GS $D05D.0-5 VIC-IV:SIDBDRWD side border width (MSB)
GS $D05D.6 VIC-IV:RSTDELEN Enable raster delay (delays raster counter and interrupts by one line to match output pipeline latency)
GS $D05D.7 VIC-IV:HOTREG Enable VIC-II hot registers. When enabled, touching many VIC-II registers causes the VIC-IV to recalculate display parameters, such as border positions and sizes
GS $D05E VIC-IV:CHRCOUNT Number of characters to display per row
GS $D05F VIC-IV:SPRXSMSBS Sprite H640 X Super-MSBs
GS $D060 VIC-IV:SCRNPTR screen RAM precise base address (bits 0 - 7)
GS $D061 VIC-IV:SCRNPTR screen RAM precise base address (bits 15 - 8)
GS $D062 VIC-IV:SCRNPTR screen RAM precise base address (bits 23 - 16)
GS $D063 VIC-IV:SCRNPTR screen RAM precise base address (bits 31 - 24)
GS $D064 VIC-IV:COLPTR colour RAM base address (bits 0 - 7)
GS $D065 VIC-IV:COLPTR colour RAM base address (bits 15 - 8)
GS $D066.0-4 VIC-IV xcounter pipeline delay DEBUG WILL BE REMOVED
GS $D066.6 VIC-IV render activity display enable DEBUG WILL BE REMOVED
GS $D066.7 VIC-IV test pattern display enable DEBUG WILL BE REMOVED
GS $D067 DEBUG:SBPDEBUG Sprite/bitplane first X DEBUG WILL BE REMOVED
GS $D068 VIC-IV:CHARPTR Character set precise base address (bits 0 - 7)
GS $D069 VIC-IV:CHRPTR Character set precise base address (bits 15 - 8)
GS $D06A VIC-IV:CHRPTR Character set precise base address (bits 23 - 16)
GS $D06B VIC-IV:SPR16EN sprite 16-colour mode enables
GS $D06C VIC-IV:SPRPTRADR sprite pointer address (bits 7 - 0)
GS $D06D VIC-IV:SPRPTRADR sprite pointer address (bits 15 - 8)
GS $D06E.0-6 VIC-IV:SPRPTRBNK sprite pointer address (bits 22 - 16)
GS $D06E.7 VIC-IV:SPRPTR16 16-bit sprite pointer mode (allows sprites to be located on any 64 byte boundary in chip RAM)
GS $D06F.5-0 VIC-IV:RASLINE0 first VIC-II raster line
GS $D06F.7 VIC-IV:PALNTSC NTSC emulation mode (max raster = 262)
GS $D070.1-0 VIC-IV:ABTPALSEL VIC-IV bitmap/text palette bank (alternate palette)
GS $D070.3-2 VIC-IV:SPRPALSEL sprite palette bank
GS $D070.5-4 VIC-IV:BTPALSEL bitmap/text palette bank
GS $D070.7-6 VIC-IV:MAPEDPAL palette bank mapped at \$D100-\$D3FF
GS $D070 NONE:VIC-IV palette bank selection
GS $D071 VIC-IV:BP16ENS VIC-IV 16-colour bitplane enable flags
GS $D072 VIC-IV:VSYNDEL VIC-IV VSYNC delay
GS $D073.0-3 VIC-IV:ALPHADELAY Alpha delay for compositor
GS $D073.4-7 VIC-IV:RASTERHEIGHT physical rasters per VIC-II raster (1 to 16)
GS $D074 VIC-IV:SPRENALPHA Sprite alpha-blend enable
GS $D075 VIC-IV:SPRALPHAVAL Sprite alpha-blend value
GS $D076 VIC-IV:SPRENV400 Sprite V400 enables
GS $D077 VIC-IV:SRPYMSBS Sprite V400 Y position MSBs
GS $D078 VIC-IV:SPRYSMSBS Sprite V400 Y position super MSBs
GS $D079 VIC-IV:RSTCOMP Raster compare value
GS $D07A.0-2 VIC-IV:RSTCMP Raster compare value MSB
GS $D07A.3-6 VIC-IV:RESERVED 
GS $D07A.7 VIC-IV:FNRSTCMP Raster compare is in physical rasters if set, or VIC-II raster if clear
GS $D07B VIC-IV:Number of text rows to display
GS $D07C.0-3 VIC-IV:RESERVED UNUSED BITS
GS $D07C.4 VIC-IV:HSYNCP hsync polarity
GS $D07C.5 VIC-IV:VSYNCP vsync polarity
GS $D07C.6-7 VIC-IV:RESERVED UNUSED BITS
GS $D07D DEBUG:DEBUGX VIC-IV debug X position (LSB)
GS $D07E DEBUG:DEBUGY VIC-IV debug Y position (LSB)
GS $D07F.0-5 DEBUG:DEBUGX VIC-IV debug X position (MSB)
GS $D07F.4-7 DEBUG:DEBUGY VIC-IV debug Y position (MSB)
GS $D07F.7 DEBUG:DEBUGOOF VIC-IV debug out-of-frame signal enable
C65 $D080 - F011 FDC control
C65 $D081 - F011 FDC command
C65 $D082 - F011 FDC Status A port (read only)
C65 $D083 - F011 FDC Status B port (read only)
C65 $D084 - F011 FDC track
C65 $D085 - F011 FDC sector
C65 $D086 - F011 FDC side
C65 $D087 - F011 FDC data register (read/write)
GS $D09B - FSM state of low-level SD controller (DEBUG)
GS $D09C - Last byte low-level SD controller read from card (DEBUG)
GS $D09D - FDC-side buffer pointer high bit (DEBUG)
GS $D09E - CPU-side buffer pointer low bits (DEBUG)
GS $D09F.0 - CPU-side buffer pointer high bit (DEBUG)
GS $D09F.1 - EQ flag (DEBUG)
GS $D09F.2 - EQ flag inhibit state (DEBUG)
C65 $D0A0 - C65 RAM Expansion controller
C65 $D0A0-$D0FF - Reserved for C65 RAM Expansion Controller.
C65 $D0A0-$D0FF SUMMARY:REC Reserved for C65 RAM Expansion Controller.
GS $D0E0 Buffered UART1 Data register (read to accept a byte, write to transmit a byte)
GS $D0E1.0 Buffered UART1 enable interrupt on TX buffer low-water mark
GS $D0E1.1 Buffered UART1 enable interrupt on RX high-water mark
GS $D0E1.2 Buffered UART1 enable interrupt on RX byte
GS $D0E1.3 Buffered UART1 TX buffer full
GS $D0E1.4 Buffered UART1 RX buffer full
GS $D0E1.5 Buffered UART1 TX buffer empty
GS $D0E1.6 Buffered UART1 RX buffer empty
GS $D0E1.7 Buffered UART1 interrupt status
GS $D0E1 Buffered UART1 Status register
GS $D0E6 Buffered UART2 frequency divisor (LSB)
GS $D0E7 Buffered UART2 frequency divisor (MSB)
GS $D0E8 Buffered UART2 Data register (read to accept a byte, write to transmit a byte)
GS $D0E9.0 Buffered UART2 enable interrupt on TX buffer low-water mark
GS $D0E9.1 Buffered UART2 enable interrupt on RX high-water mark
GS $D0E9.2 Buffered UART2 enable interrupt on RX byte
GS $D0E9.3 Buffered UART2 TX buffer full
GS $D0E9.4 Buffered UART2 RX buffer full
GS $D0E9.5 Buffered UART2 TX buffer empty
GS $D0E9.6 Buffered UART2 RX buffer empty
GS $D0E9.7 Buffered UART2 interrupt status
GS $D0E9 Buffered UART2 Status register
GS $D0EE Buffered UART2 frequency divisor (LSB)
GS $D0EF Buffered UART2 frequency divisor (MSB)
C65 $D100-$D1FF VIC-III:PALRED red palette values (reversed nybl order)
C65 $D200-$D2FF VIC-III:PALGREEN green palette values (reversed nybl order)
C65 $D300-$D3FF VIC-III:PALBLUE blue palette values (reversed nybl order)
C64 $D400-$D43F = right SID
C64 $D440-$D47F = left SID
C64 $D480-$D4FF = repeated images of SIDs
C65 $D600 UART:DATA UART data register (read or write)
C65 $D601.0 UART:RXRDY UART RX byte ready flag (clear by reading \$D600)
C65 $D601.1 UART:RXOVRRUN UART RX overrun flag (clear by reading \$D600)
C65 $D601.2 UART:PTYERR UART RX parity error flag (clear by reading \$D600)
C65 $D601.3 UART:FRMERR UART RX framing error flag (clear by reading \$D600)
C65 $D601 C65 UART status register
C65 $D602.0 UART:PTYEVEN UART Parity: 1=even, 0=odd
C65 $D602.1 UART:PTYEN UART Parity enable: 1=enabled
C65 $D602.2-3 UART:CHARSZ UART character size: 00=8, 01=7, 10=6, 11=5 bits per byte
C65 $D602.4-5 UART:SYNCMOD UART synchronisation mode flags (00=RX \& TX both async, 01=RX sync, TX async, 1x=TX sync, RX async (unused on the MEGA65)
C65 $D602.6 UART:RXEN UART enable receive
C65 $D602.7 UART:TXEN UART enable transmit
C65 $D602 C65 UART control register
C65 $D603 UART:DIVISOR UART baud rate divisor (16 bit). Baud rate = 7.09375MHz / DIVISOR, unless MEGA65 fast UART mode is enabled, in which case baud rate = 80MHz / DIVISOR
C65 $D604 UART:DIVISOR UART baud rate divisor (16 bit). Baud rate = 7.09375MHz / DIVISOR, unless MEGA65 fast UART mode is enabled, in which case baud rate = 80MHz / DIVISOR
C65 $D605.4 UART:IMRXNMI UART interrupt mask: NMI on RX (not yet implemented on the MEGA65)
C65 $D605.5 UART:IMTXNMI UART interrupt mask: NMI on TX (not yet implemented on the MEGA65)
C65 $D605.6 UART:IMRXIRQ UART interrupt mask: IRQ on RX (not yet implemented on the MEGA65)
C65 $D605.7 UART:IMTXIRQ UART interrupt mask: IRQ on TX (not yet implemented on the MEGA65)
C65 $D606.4 UART:IFRXNMI UART interrupt flag: NMI on RX (not yet implemented on the MEGA65)
C65 $D606.5 UART:IFTXNMI UART interrupt flag: NMI on TX (not yet implemented on the MEGA65)
C65 $D606.6 UART:IFRXIRQ UART interrupt flag: IRQ on RX (not yet implemented on the MEGA65)
C65 $D606.7 UART:IFTXIRQ UART interrupt flag: IRQ on TX (not yet implemented on the MEGA65)
C65 $D606 C65 UART interrupt flag register              
GS $D607.0 UART:CAPLOCK C65 capslock key sense
GS $D607.1 UART:KEYCOL8 C65 keyboard column 8 select
C65 $D607 C65 UART 2-bit port data register (used for C65 keyboard)
GS $D608.0-1 UART:PORTEDDR C65 keyboard extra lines Data Direction Register (DDR)
C65 $D608 C65 UART data direction register (used for C65 keyboard)
GS $D609.0 UARTMISC:UFAST C65 UART BAUD clock source: 1 = 7.09375MHz, 0 = 80MHz (VIC-IV pixel clock)
GS $D609 MEGA65 extended UART control register
GS $D60B.5-0 UARTMISC:PORTF PMOD port A on FPGA board (data) (Nexys4 boards only)
GS $D60B.6 UARTMISC:OSKZON Display hardware zoom of region under first touch point always
GS $D60B.7 UARTMISC:OSKZEN Display hardware zoom of region under first touch point for on-screen keyboard
GS $D60C.0-5 UARTMISC:PORTFDDR PMOD port A on FPGA board (DDR)
GS $D60C.6-7 UARTMISC:PORTFDDR On Screen Keyboard (OSK) Zoom Control Data Direction Register (DDR). Must be set to output to control these features.
GS $D60D.0 - Internal 1541 drive connect (1= use internal 1541 instead of IEC drive connector)                        
GS $D60D.0 UARTMISC:CONN41 Internal 1541 drive connect (1=connect internal 1541 drive to IEC bus)                        
GS $D60D.1 - Internal 1541 drive reset
GS $D60D.1 UARTMISC:RST41 Internal 1541 drive reset (1=reset, 0=operate)
GS $D60D.2 UARTMISC:SDDATA SD card MOSI/MISO
GS $D60D.3 UARTMISC:SDCLK SD card SCLK
GS $D60D.4 UARTMISC:SDCS SD card CS_BO
GS $D60D.5 UARTMISC:SDBSH Enable SD card bitbash mode
GS $D60D.6 UARTMISC:HDSPI HDMI SPI control interface SDA data line 
GS $D60D.7 UARTMISC:HDSCL HDMI SPI control interface SCL clock 
GS $D60D Bit bashing port
GS $D60E UARTMISC:BASHDDR Data Direction Register (DDR) for \$D60D bit bashing port.
GS $D60F.0 UARTMISC:KEYLEFT Directly read C65 Cursor left key
GS $D60F.1 UARTMISC:KEYUP Directly read C65 Cursor up key
GS $D610 UARTMISC:ASCIIKEY Last key press as ASCII (hardware accelerated keyboard scanner). Write to clear event ready for next.
GS $D611.0 UARTMISC:MRSHFT Right shift key state (hardware accelerated keyboard scanner).
GS $D611.0 WRITE ONLY Connect POT lines to IEC port (for r1 PCB only)
GS $D611.1 UARTMISC:MLSHFT Left shift key state (hardware accelerated keyboard scanner).
GS $D611.1 WRITE ONLY enable real joystick ports (for r2 PCB only)
GS $D611.2 UARTMISC:MCTRL CTRL key state (hardware accelerated keyboard scanner).
GS $D611.3 UARTMISC:MMEGA MEGA/C= key state (hardware accelerated keyboard scanner).
GS $D611.4 UARTMISC:MALT ALT key state (hardware accelerated keyboard scanner).
GS $D611.5 UARTMISC:MSCRL NOSCRL key state (hardware accelerated keyboard scanner).
GS $D611 Modifier key state (hardware accelerated keyboard scanner).
GS $D612.0 UARTMISC:WGTKEY Enable widget board keyboard/joystick input
GS $D612.1 UARTMISC:PS2KEY Enable ps2 keyboard/joystick input
GS $D612.2 UARTMISC:PHYKEY Enable physical keyboard input
GS $D612.3 UARTMISC:VRTKEY Enable virtual/snythetic keyboard input
GS $D612.4 UARTMISC:OSKDEBUG Debug OSK overlay (WRITE ONLY)
GS $D612.4 UARTMISC:PS2JOY Enable PS/2 / USB keyboard simulated joystick input
GS $D612.5 UARTMISC:JOYSWAP Exchange joystick ports 1 & 2
GS $D612.6 UARTMISC:LJOYA Rotate inputs of joystick A by 180 degrees (for left handed use)
GS $D612.7 UARTMISC:LJOYB Rotate inputs of joystick B by 180 degrees (for left handed use)
GS $D613 DEBUG:CRTACSCNT Count of cartridge port memory accesses (read only)
GS $D614 DEBUG:KEYMATRIXPEEK 8-bit segment of combined keyboard matrix (READ)
GS $D615.0-6 UARTMISC:VIRTKEY1 Set to \$7F for no key down, else specify virtual key press.
GS $D615.7 UARTMISC:OSKEN Enable display of on-screen keyboard composited overlay
GS $D616.0-6 UARTMISC:VIRTKEY2 Set to \$7F for no key down, else specify 2nd virtual key press.
GS $D616.7 UARTMISC:OSKALT Display alternate on-screen keyboard layout (typically dial pad for MEGA65 telephone)
GS $D617.0-6 UARTMISC:VIRTKEY3 Set to \$7F for no key down, else specify 3nd virtual key press.
GS $D617.7 UARTMISC:OSKTOP 1=Display on-screen keyboard at top, 0=Disply on-screen keyboard at bottom of screen.
GS $D618 UARTMISC:KSCNRATE Physical keyboard scan rate (\$00=50MHz, \$FF=~200KHz)
GS $D619 UARTMISC:UNUSED port o output value
GS $D61A UARTMISC:UNUSED port p output value
GS $D61B.0 WRITEONLY enable/disable Amiga mouse support (1351 emulation) on jostick 1
GS $D61B.1 WRITEONLY enable/disable Amiga mouse support (1351 emulation) on jostick 2
GS $D61B.2 WRITEONLY assume amiga mouse on jostick 1 if enabled
GS $D61B.3 WRITEONLY assume amiga mouse on jostick 2 if enabled
GS $D61B.6 WRITEONLY DEBUG disable ASCII key retrigger suppression
GS $D61B.7 WRITEONLY DEBUG disable ASCII key glitch suppression
GS $D61B DEBUG:AMIMOUSDETECT READ 1351/amiga mouse auto detection DEBUG
GS $D61C DEBUG:1541PCLSB internal 1541 PC LSB
GS $D61D DEBUG:ASCKEYCNT ASCII key event counter LSB
GS $D61E DEBUG:ASCKEYCNT ASCII key event counter MSB
GS $D61F DEBUG:BUCKYCOPY DUPLICATE Modifier key state (hardware accelerated keyboard scanner).
GS $D620 UARTMISC:POTAX Read Port A paddle X, without having to fiddle with SID/CIA settings.
GS $D621 UARTMISC:POTAY Read Port A paddle Y, without having to fiddle with SID/CIA settings.
GS $D622 UARTMISC:POTBX Read Port B paddle X, without having to fiddle with SID/CIA settings.
GS $D623 UARTMISC:POTBY Read Port B paddle Y, without having to fiddle with SID/CIA settings.
GS $D624.0 Paddles connected via IEC port (rev1 PCB debug)
GS $D624.1 pot_drain signal
GS $D624.3-2 CIA porta bits 7-6 for POT multiplexor
GS $D624.4 fa_potx line
GS $D624.5 fa_poty line
GS $D624.6 fb_potx line
GS $D624.7 fb_poty line          
GS $D624 DEBUG:POTDEBUG READ ONLY flags for paddles. See c65uart.vhdl for more information.
GS $D640.6 - Thumbnail drawing was in progress.
GS $D640.7 - Thumbnail is valid if 1.  Else there has not been a complete frame since elapsed without a trap to hypervisor mode, in which case the thumbnail may not reflect the current process.
GS $D640 CPU:HTRAP00 Writing triggers hypervisor trap \$00
GS $D640-$D641 - Read-only hardware-generated thumbnail of display (accessible only in hypervisor mode)
GS $D640 HCPU:REGA Hypervisor A register storage
GS $D640 - Read to obtain status of thumbnail generator.
GS $D640 - Read to reset port address for thumbnail generator
GS $D641 CPU:HTRAP01 Writing triggers hypervisor trap \$01
GS $D641 HCPU:REGX Hypervisor X register storage
GS $D641 - Read port for thumbnail generator
GS $D642 CPU:HTRAP02 Writing triggers hypervisor trap \$02
GS $D642 HCPU_REGY Hypervisor Y register storage
GS $D642 - Lower 8 bits of thumbnail buffer read address (TEMPORARY DEBUG REGISTER)
GS $D643 CPU:HTRAP03 Writing triggers hypervisor trap \$03
GS $D643 HCPU:REGZ Hypervisor Z register storage
GS $D644 CPU:HTRAP04 Writing triggers hypervisor trap \$04
GS $D644 HCPU:REGB Hypervisor B register storage
GS $D645 CPU:HTRAP05 Writing triggers hypervisor trap \$05
GS $D645 HCPU:SPL Hypervisor SPL register storage
GS $D646 CPU:HTRAP06 Writing triggers hypervisor trap \$06
GS $D646 HCPU:SPH Hypervisor SPH register storage
GS $D647 CPU:HTRAP07 Writing triggers hypervisor trap \$07
GS $D647 HCPU:PFLAGS Hypervisor P register storage
GS $D648 CPU:HTRAP08 Writing triggers hypervisor trap \$08
GS $D648 HCPU:PCL Hypervisor PC-low register storage
GS $D649 CPU:HTRAP09 Writing triggers hypervisor trap \$09
GS $D649 HCPU:PCH Hypervisor PC-high register storage
GS $D64A CPU:HTRAP0A Writing triggers hypervisor trap \$0A
GS $D64A HCPU:MAPLO Hypervisor MAPLO register storage (high bits)
GS $D64B CPU:HTRAP0B Writing triggers hypervisor trap \$0B
GS $D64B HCPU:MAPLO Hypervisor MAPLO register storage (low bits)
GS $D64C CPU:HTRAP0C Writing triggers hypervisor trap \$0C
GS $D64C HCPU:MAPHI Hypervisor MAPHI register storage (high bits)
GS $D64D CPU:HTRAP0D Writing triggers hypervisor trap \$0D
GS $D64D HCPU:MAPHI Hypervisor MAPHI register storage (low bits)
GS $D64E CPU:HTRAP0E Writing triggers hypervisor trap \$0E
GS $D64E HCPU:MAPLOMB Hypervisor MAPLO mega-byte number register storage
GS $D64F CPU:HTRAP0F Writing triggers hypervisor trap \$0F
GS $D64F HCPU:MAPHIMB Hypervisor MAPHI mega-byte number register storage
GS $D650 CPU:HTRAP10 Writing triggers hypervisor trap \$10
GS $D650 HCPU:PORT00 Hypervisor CPU port \$00 value
GS $D651 CPU:HTRAP11 Writing triggers hypervisor trap \$11
GS $D651 HCPU:PORT01 Hypervisor CPU port \$01 value
GS $D652.0-1 HCPU:VICMODE VIC-II/VIC-III/VIC-IV mode select
GS $D652.2 HCPU:EXSID 0=Use internal SIDs, 1=Use external(1) SIDs
GS $D652 CPU:HTRAP12 Writing triggers hypervisor trap \$12
GS $D652 - Hypervisor VIC-IV IO mode
GS $D653 CPU:HTRAP13 Writing triggers hypervisor trap \$13
GS $D653 HCPU:DMASRCMB Hypervisor DMAgic source MB
GS $D654 CPU:HTRAP14 Writing triggers hypervisor trap \$14
GS $D654 HCPU:DMADSTMB Hypervisor DMAgic destination MB
GS $D655 CPU:HTRAP15 Writing triggers hypervisor trap \$15
GS $D655 HCPU:DMALADDR Hypervisor DMAGic list address bits 0-7
GS $D656 CPU:HTRAP16 Writing triggers hypervisor trap \$16
GS $D656 HCPU:DMALADDR Hypervisor DMAGic list address bits 15-8
GS $D657 CPU:HTRAP17 Writing triggers hypervisor trap \$17
GS $D657 HCPU:DMALADDR Hypervisor DMAGic list address bits 23-16
GS $D658 CPU:HTRAP18 Writing triggers hypervisor trap \$18
GS $D658 HCPU:DMALADDR Hypervisor DMAGic list address bits 27-24
GS $D659.0 HCPU:VFLOP 1=Virtualise SD/Floppy access (usually for access via serial debugger interface)
GS $D659 CPU:HTRAP19 Writing triggers hypervisor trap \$19
GS $D659 - Hypervisor virtualise hardware flags
GS $D65A CPU:HTRAP1A Writing triggers hypervisor trap \$1A
GS $D65B CPU:HTRAP1B Writing triggers hypervisor trap \$1B
GS $D65C CPU:HTRAP1C Writing triggers hypervisor trap \$1C
GS $D65D CPU:HTRAP1D Writing triggers hypervisor trap \$1D
GS $D65D - Hypervisor current virtual page number (low byte)
GS $D65E CPU:HTRAP1E Writing triggers hypervisor trap \$1E
GS $D65E - Hypervisor current virtual page number (mid byte)
GS $D65F CPU:HTRAP1F Writing triggers hypervisor trap \$1F
GS $D65F - Hypervisor current virtual page number (high byte)
GS $D660 CPU:HTRAP20 Writing triggers hypervisor trap \$20
GS $D660 - Hypervisor virtual memory page 0 logical page low byte
GS $D661 CPU:HTRAP21 Writing triggers hypervisor trap \$21
GS $D661 - Hypervisor virtual memory page 0 logical page high byte
GS $D662 CPU:HTRAP22 Writing triggers hypervisor trap \$22
GS $D662 - Hypervisor virtual memory page 0 physical page low byte
GS $D663 CPU:HTRAP23 Writing triggers hypervisor trap \$23
GS $D663 - Hypervisor virtual memory page 0 physical page high byte
GS $D664 CPU:HTRAP24 Writing triggers hypervisor trap \$24
GS $D664 - Hypervisor virtual memory page 1 logical page low byte
GS $D665 CPU:HTRAP25 Writing triggers hypervisor trap \$25
GS $D665 - Hypervisor virtual memory page 1 logical page high byte
GS $D666 CPU:HTRAP26 Writing triggers hypervisor trap \$26
GS $D666 - Hypervisor virtual memory page 1 physical page low byte
GS $D667 CPU:HTRAP27 Writing triggers hypervisor trap \$27
GS $D667 - Hypervisor virtual memory page 1 physical page high byte
GS $D668 CPU:HTRAP28 Writing triggers hypervisor trap \$28
GS $D668 - Hypervisor virtual memory page 2 logical page low byte
GS $D669 CPU:HTRAP29 Writing triggers hypervisor trap \$29
GS $D669 - Hypervisor virtual memory page 2 logical page high byte
GS $D66A CPU:HTRAP2A Writing triggers hypervisor trap \$2A
GS $D66A - Hypervisor virtual memory page 2 physical page low byte
GS $D66B CPU:HTRAP2B Writing triggers hypervisor trap \$2B
GS $D66B - Hypervisor virtual memory page 2 physical page high byte
GS $D66C CPU:HTRAP2C Writing triggers hypervisor trap \$2C
GS $D66C - Hypervisor virtual memory page 3 logical page low byte
GS $D66D CPU:HTRAP2D Writing triggers hypervisor trap \$2D
GS $D66D - Hypervisor virtual memory page 3 logical page high byte
GS $D66E CPU:HTRAP2E Writing triggers hypervisor trap \$2E
GS $D66E - Hypervisor virtual memory page 3 physical page low byte
GS $D66F CPU:HTRAP2F Writing triggers hypervisor trap \$2F
GS $D66F - Hypervisor virtual memory page 3 physical page high byte
GS $D670 CPU:HTRAP30 Writing triggers hypervisor trap \$30
GS $D670 HCPU:GEORAMBASE Hypervisor GeoRAM base address (x MB)
GS $D671 CPU:HTRAP31 Writing triggers hypervisor trap \$31
GS $D671 HCPU:GEORAMMASK Hypervisor GeoRAM address mask (applied to GeoRAM block register)
GS $D672.6 HCPU:MATRIXEN Enable composited Matrix Mode, and disable UART access to serial monitor.
GS $D672 CPU:HTRAP32 Writing triggers hypervisor trap \$32
GS $D672 - Protected Hardware configuration
GS $D673 CPU:HTRAP33 Writing triggers hypervisor trap \$33
GS $D674 CPU:HTRAP34 Writing triggers hypervisor trap \$34
GS $D675 CPU:HTRAP35 Writing triggers hypervisor trap \$35
GS $D676 CPU:HTRAP36 Writing triggers hypervisor trap \$36
GS $D677 CPU:HTRAP37 Writing triggers hypervisor trap \$37
GS $D678 CPU:HTRAP38 Writing triggers hypervisor trap \$38
GS $D679 CPU:HTRAP39 Writing triggers hypervisor trap \$39
GS $D67A CPU:HTRAP3A Writing triggers hypervisor trap \$3A
GS $D67B CPU:HTRAP3B Writing triggers hypervisor trap \$3B
GS $D67C.0-7 HCPU:UARTDATA (write) Hypervisor write serial output to UART monitor
GS $D67C.6 - (read) Hypervisor internal immediate UART monitor busy flag (can write when 0)
GS $D67C.7 - (read) Hypervisor serial output from UART monitor busy flag (can write when 0)
GS $D67C CPU:HTRAP3C Writing triggers hypervisor trap \$3C
GS $D67D.0 HCPU:CARTEN Hypervisor enable /EXROM and /GAME from cartridge
GS $D67D.1 HCPU:JMP32EN Hypervisor enable 32-bit JMP/JSR etc
GS $D67D.2 HCPU:ROMPROT Hypervisor write protect C65 ROM \$20000-\$3FFFF
GS $D67D.3 HCPU:ASCFAST Hypervisor enable ASC/DIN CAPS LOCK key to enable/disable CPU slow-down in C64/C128/C65 modes
GS $D67D.4 HCPU:CPUFAST Hypervisor force CPU to 48MHz for userland (userland can override via POKE0)
GS $D67D.5 HCPU:F4502 Hypervisor force CPU to 4502 personality, even in C64 IO mode.
GS $D67D.6 HCPU:PIRQ Hypervisor flag to indicate if an IRQ is pending on exit from the hypervisor / set 1 to force IRQ/NMI deferal for 1,024 cycles on exit from hypervisor.
GS $D67D.7 HCPU:PNMI Hypervisor flag to indicate if an NMI is pending on exit from the hypervisor.
GS $D67D CPU:HTRAP3D Writing triggers hypervisor trap \$3D
GS $D67D HCPU:WATCHDOG Hypervisor watchdog register: writing any value clears the watch dog
GS $D67E.5 (read) Hypervisor read /GAME signal from cartridge.
GS $D67E.6 (read) Hypervisor read /EXROM signal from cartridge.
GS $D67E.7 (read) Hypervisor upgraded flag. Writing any value here sets this bit until next power on (i.e., it surives reset).
GS $D67E CPU:HTRAP3E Writing triggers hypervisor trap \$3E
GS $D67E HCPU:HICKED Hypervisor already-upgraded bit (writing sets permanently)
GS $D67F CPU:HTRAP3F Writing triggers hypervisor trap \$3F
GS $D67F HCPU:ENTEREXIT Writing trigger return from hypervisor
GS $D680.0 - SD controller BUSY flag
GS $D680.1 - SD controller BUSY flag
GS $D680.2 - SD controller RESET flag
GS $D680.3 - SD controller sector buffer mapped flag
GS $D680.4 - SD controller SDHC mode flag
GS $D680.5 - SD controller SDIO FSM ERROR flag
GS $D680.6 - SD controller SDIO error flag
GS $D680.7 - SD controller primary / secondary SD card 
GS $D680 - SD controller status/command
GS $D681-$D684 - SD controller SD sector address
GS $D685 - DEBUG Show current state ID of SD card interface
GS $D686 - DEBUG SD card data token
GS $D686 WRITE ONLY set fill byte for use in fill mode, instead of SD buffer data
GS $D687 - DEBUG SD card most recent byte read
GS $D688 - Low-byte of F011 buffer pointer (disk side) (read only)
GS $D689.0 - High bit of F011 buffer pointer (disk side) (read only)
GS $D689.1 - Sector read from SD/F011/FDC, but not yet read by CPU (i.e., EQ and DRQ)
GS $D689.2 Set/read SD card sd_handshake signal
GS $D689.3 - (read only) sd_data_ready signal.
GS $D689.7 - Memory mapped sector buffer select: 1=SD-Card, 0=F011/FDC
GS $D68A - DEBUG check signals that can inhibit sector buffer mapping
GS $D68B.0 - F011 disk 1 disk image enable
GS $D68B.1 - F011 disk 1 present
GS $D68B.2 - F011 disk 1 write protect
GS $D68B.3 - F011 disk 2 disk image enable
GS $D68B.4 - F011 disk 2 present
GS $D68B.5 - F011 disk 2 write protect
GS $D68B.6 F011:MDISK0 Enable 16MiB ``MEGA Disk'' for F011 emulated drive 0
GS $D68B.7 F011:MDISK0 Enable 16MiB ``MEGA Disk'' for F011 emulated drive 1
GS $D68B - Diskimage control flags
GS $D68B - F011 emulation control register
GS $D68C-$D68F - F011 disk 1 disk image address on SD card
GS $D68C F011:DISK2ADDR0 Diskimage 2 sector number (bits 0-7)
GS $D68C F011:DISKADDR0 Diskimage sector number (bits 0-7)
GS $D68D F011:DISK2ADDR1 Diskimage 2 sector number (bits 8-15)
GS $D68D F011:DISKADDR1 Diskimage sector number (bits 8-15)
GS $D68E F011:DISK2ADDR2 Diskimage 2 sector number (bits 16-23)
GS $D68E F011:DISKADDR2 Diskimage sector number (bits 16-23)
GS $D68F F011:DISK2ADDR3 Diskimage 2 sector number (bits 24-31)
GS $D68F F011:DISKADDR3 Diskimage sector number (bits 24-31)
GS $D690-$D693 - F011 disk 2 disk image address on SD card
GS $D6A0 - 3.5" FDC control line debug access
GS $D6A0 - DEBUG FDC read status lines
GS $D6A1.0 - Use real floppy drive instead of SD card
GS $D6A1.1 - Match any sector on a real floppy read/write
GS $D6A1.2-6 - FDC debug status flags
GS $D6A2 - FDC clock cycles per MFM data bit
GS $D6A3 - FDC track number of last matching sector header
GS $D6A4 - FDC sector number of last matching sector header
GS $D6A5 - FDC side number of last matching sector header
GS $D6A6 - DEBUG FDC decoded MFM byte
GS $D6A7 - DEBUG FDC decoded MFM state
GS $D6A8 - DEBUG FDC last decoded MFM byte
GS $D6A9 - DEBUG FDC last gap interval (LSB)
GS $D6AA - DEBUG FDC last gap interval (MSB)
GS $D6AB - DEBUG FDC last 7 rdata bits (packed by mfm_gaps)
GS $D6AC - DEBUG FDC last quantised gap
GS $D6AD.0-3 - PHONE:Volume knob 1 audio target
GS $D6AD.4-7 - PHONE:Volume knob 2 audio target
GS $D6AE.0-3 - PHONE:Volume knob 3 audio target
GS $D6AE.7 - PHONE:Volume knob 3 controls LCD panel brightness
GS $D6AF.0 - f011_rsector_found
GS $D6AF.1 - f011_wsector_found
GS $D6AF.2 - f011_eq_inhibit
GS $D6AF.3 - f011_rnf
GS $D6AF.4 - f011_drq
GS $D6AF.5 - f011_lost
GS $D6AF - Directly set F011 flags (intended for virtual F011 mode) WRITE ONLY
GS $D6B0.0 - Touch event 1 is valid
GS $D6B0.1 - Touch event 2 is valid
GS $D6B0.2-3 - Touch event 1 up/down state
GS $D6B0.5-4 - Touch event 2 up/down state
GS $D6B0.6 - Invert horizontal axis
GS $D6B0.7 - Invert vertical axis
GS $D6B0 - Touch pad control / status
GS $D6B1 - Touch pad X scaling LSB
GS $D6B2 - Touch pad X scaling MSB
GS $D6B3 - Touch pad Y scaling LSB
GS $D6B4 - Touch pad Y scaling MSB
GS $D6B5 - Touch pad X delta LSB
GS $D6B6 - Touch pad X delta MSB
GS $D6B7 - Touch pad Y delta LSB
GS $D6B8 - Touch pad Y delta MSB
GS $D6B9 - Touch pad touch #1 X LSB
GS $D6BA - Touch pad touch #1 Y LSB
GS $D6BB.0-1 - Touch pad touch #1 X MSBs
GS $D6BB.5-4 - Touch pad touch #1 Y MSBs
GS $D6BC - Touch pad touch #2 X LSB
GS $D6BD - Touch pad touch #2 Y LSB
GS $D6BE.0-1 - Touch pad touch #2 X MSBs
GS $D6BE.5-4 - Touch pad touch #2 Y MSBs
GS $D6BF.7 - Enable/disable touch panel I2C communications
GS $D6C0.0-3 - Touch pad gesture directions (left,right,up,down)
GS $D6C0.7-4 - Touch pad gesture ID
GS $D6D0 - I2C bus select (bus 0 = temp sensor on Nexys4 boardS)
GS $D6D1.0 - I2C reset
GS $D6D1.1 - I2C command latch write strobe (write 1 to trigger command)
GS $D6D1.2 - I2C Select read (1) or write (0)
GS $D6D1.5 - I2C bus 1 swap SDA/SCL pins
GS $D6D1.6 - I2C busy flag
GS $D6D1.7 - I2C ack error
GS $D6D1 - I2C control/status
GS $D6D2.7-1 - I2C address
GS $D6D3 - I2C data write register
GS $D6D4 - I2C data read register
GS $D6DA - DEBUG SD card last error code LSB
GS $D6DB - DEBUG SD card last error code MSB
GS $D6DE - FPGA die temperature sensor (lower nybl)
GS $D6DF - FPGA die temperature sensor (upper byte)
GS $D6E0.0 Clear to reset ethernet PHY
GS $D6E0.0 ETH:RST Write 0 to hold ethernet controller under reset
GS $D6E0.1-2 ETH:DRXD Read ethernet RX bits currently on the wire
GS $D6E0.3 ETH:DRXDV Read ethernet RX data valid (debug)
GS $D6E0.4 Allow remote keyboard input via magic ethernet frames
GS $D6E0.4 ETH:KEYEN Allow remote keyboard input via magic ethernet frames
GS $D6E0.6 ETH:RXBLKD Indicate if ethernet RX is blocked until RX buffers rotated
GS $D6E1.0 reset ethernet PHY
GS $D6E1.1 ETH:RXBM Set which RX buffer is memory mapped
GS $D6E1.1 - Set which RX buffer is memory mapped
GS $D6E1.2 ETH:RXBU Indicate which RX buffer was most recently used
GS $D6E1.2 WRITE ONLY Enable real-time CPU/BUS monitoring via ethernet
GS $D6E1.3 Enable real-time video streaming via ethernet (or fast IO bus if CPU/bus monitoring enabled)
GS $D6E1.3 ETH:STRM Enable streaming of CPU instruction stream or VIC-IV display on ethernet
GS $D6E1.4 ETH:TXQ Ethernet TX IRQ status
GS $D6E1.5 ETH:RXQ Ethernet RX IRQ status
GS $D6E1.6 ETH:TXQEN Enable ethernet TX IRQ
GS $D6E1.7 ETH:RXQEN Enable ethernet RX IRQ
GS $D6E1 - Ethernet interrupt and control register
GS $D6E2 ETH:TXSZLSB TX Packet size (low byte)
GS $D6E2 Set low-order size of frame to TX
GS $D6E3 ETH:TXSZMSB TX Packet size (high byte)
GS $D6E3 Set high-order size of frame to TX
GS $D6E4 = $00 = Clear ethernet TX trigger (debug)
GS $D6E4 = $01 = Transmit packet
GS $D6E4 ETH:COMMAND Ethernet command register
GS $D6E5.0 ETH:NOPROM Ethernet disable promiscuous mode
GS $D6E5.1 Disable CRC check for received packets
GS $D6E5.1 ETH:NOCRC Disable CRC check for received packets
GS $D6E5.2-3 Ethernet TX clock phase adjust
GS $D6E5.2-3 ETH:TXPH Ethernet TX clock phase adjust
GS $D6E5.4 ETH:BCST Accept broadcast frames
GS $D6E5.5 ETH:MCST Accept multicast frames
GS $D6E6.0-4 ETH:MIIMREG Ethernet MIIM register number
GS $D6E6.7-5 ETH:MIIMPHY Ethernet MIIM PHY number (use 0 for Nexys4, 1 for MEGA65 r1 PCBs)
GS $D6E7 ETH:MIIMVLSB Ethernet MIIM register value (LSB)
GS $D6E8 ETH:MIIMVMSB Ethernet MIIM register value (MSB)
GS $D6E9 ETH:MACADDR1 Ethernet MAC address
GS $D6EA ETH:MACADDR2 Ethernet MAC address
GS $D6EB ETH:MACADDR3 Ethernet MAC address
GS $D6EC ETH:MACADDR4 Ethernet MAC address
GS $D6ED ETH:MACADDR5 Ethernet MAC address
GS $D6EE ETH:MACADDR6 Ethernet MAC address
GS $D6EF ETH:DBGRXSTAT DEBUG show current ethernet RX state
GS $D6F0 - LCD panel brightness control
GS $D6F2 - Read FPGA five-way buttons
GS $D6F3 - Accelerometer bit-bashing port
GS $D6F3 Accelerometer inputs
GS $D6F4 - Audio Mixer register select
GS $D6F5 - Audio Mixer register read port
GS $D6F5 - Audio Mixer register write port
GS $D6F6 - Keyboard scan code reader (lower byte)
GS $D6F7 - Keyboard scan code reader (upper nybl)
GS $D6F8 - 8-bit digital audio out (left)
GS $D6F8 - Digital audio, left channel, LSB
GS $D6F9 - Digital audio, left channel, MSB
GS $D6FA - Digital audio, left channel, LSB
GS $D6FB - Digital audio, left channel, MSB
GS $D6FC - audio LSB (source selected by $D6F4)
GS $D6FD - audio MSB (source selected by $D6F4)
GS $D6FF - Flash bit-bashing port
C65 $D700 DMA:ADDRLSBTRIG DMAgic DMA list address LSB, and trigger DMA (when written)
C65 $D701 DMA:ADDRMSB DMA list address high byte (address bits 8 -- 15).
C65 $D702 DMA:ADDRBANK DMA list address bank (address bits 16 -- 22). Writing clears \$D704.
GS $D703.0 DMA:EN018B DMA enable F018B mode (adds sub-command byte)
GS $D704 DMA:ADDRMB DMA list address mega-byte
GS $D705 DMA:ETRIG Set low-order byte of DMA list address, and trigger Enhanced DMA job (uses DMA option list)
GS $D705 - Enhanced DMAgic job option $00 = End of options
GS $D705 - Enhanced DMAgic job option $06 = Use $86 $xx transparency value (don't write source bytes to destination, if byte value matches $xx)
GS $D705 - Enhanced DMAgic job option $07 = Disable $86 $xx transparency value.
GS $D705 - Enhanced DMAgic job option $0A = Use F018A list format
GS $D705 - Enhanced DMAgic job option $0B = Use F018B list format
GS $D705 - Enhanced DMAgic job option $80 $xx = Set MB of source address
GS $D705 - Enhanced DMAgic job option $81 $xx = Set MB of destination address
GS $D705 - Enhanced DMAgic job option $82 $xx = Set source skip rate (/256ths of bytes)
GS $D705 - Enhanced DMAgic job option $83 $xx = Set source skip rate (whole bytes)
GS $D705 - Enhanced DMAgic job option $84 $xx = Set destination skip rate (/256ths of bytes)
GS $D705 - Enhanced DMAgic job option $85 $xx = Set destination skip rate (whole bytes)
GS $D705 - Enhanced DMAgic job option $86 $xx = Don't write to destination if byte value = $xx, and option $06 enabled
GS $D70E DMA:ADDRLSB DMA list address low byte (address bits 0 -- 7) WITHOUT STARTING A DMA JOB (used by Hypervisor for unfreezing DMA-using tasks)
GS $D710.0 - MISC:BADLEN Enable badline emulation
GS $D710.1 - MISC:SLIEN Enable 6502-style slow (7 cycle) interrupts
GS $D770-3 25-bit multiplier input A
GS $D770 MATH:MULTINA Multiplier input A (25 bit)
GS $D771 MATH:MULTINA Multiplier input A (25 bit)
GS $D772 MATH:MULTINA Multiplier input A (25 bit)
GS $D773.0 MATH:MULTINA Multiplier input A (25 bit)
GS $D774-7 18-bit multiplier input B
GS $D774 MATH:MULTINB Multiplier input A (18 bit)
GS $D775 MATH:MULTINB Multiplier input A (18 bit)
GS $D776.0-1 MATH:MULTINB Multiplier input A (18 bit)
GS $D778 MATH:MULTOUT 48-bit output of MULTINA $\times$ MULTINB
GS $D779 MATH:MULTOUT 48-bit output of MULTINA $\times$ MULTINB
GS $D77A MATH:MULTOUT 48-bit output of MULTINA $\times$ MULTINB
GS $D77B MATH:MULTOUT 48-bit output of MULTINA $\times$ MULTINB
GS $D77C MATH:MULTOUT 48-bit output of MULTINA $\times$ MULTINB
GS $D77D MATH:MULTOUT 48-bit output of MULTINA $\times$ MULTINB
GS $D77E MATH:MULTOUT 48-bit output of MULTINA $\times$ MULTINB
GS $D780-$D7BF - 16 x 32 bit Math Unit values
GS $D780 MATH:MATHIN0 Math unit 32-bit input 0
GS $D781 MATH:MATHIN0 Math unit 32-bit input 0
GS $D782 MATH:MATHIN0 Math unit 32-bit input 0
GS $D783 MATH:MATHIN0 Math unit 32-bit input 0
GS $D784 MATH:MATHIN1 Math unit 32-bit input 1
GS $D785 MATH:MATHIN1 Math unit 32-bit input 1
GS $D786 MATH:MATHIN1 Math unit 32-bit input 1
GS $D787 MATH:MATHIN1 Math unit 32-bit input 1
GS $D788 MATH:MATHIN2 Math unit 32-bit input 2
GS $D789 MATH:MATHIN2 Math unit 32-bit input 2
GS $D78A MATH:MATHIN2 Math unit 32-bit input 2
GS $D78B MATH:MATHIN2 Math unit 32-bit input 2
GS $D78C MATH:MATHIN3 Math unit 32-bit input 3
GS $D78D MATH:MATHIN3 Math unit 32-bit input 3
GS $D78E MATH:MATHIN3 Math unit 32-bit input 3
GS $D78F MATH:MATHIN3 Math unit 32-bit input 3
GS $D790 MATH:MATHIN4 Math unit 32-bit input 4
GS $D791 MATH:MATHIN4 Math unit 32-bit input 4
GS $D792 MATH:MATHIN4 Math unit 32-bit input 4
GS $D793 MATH:MATHIN4 Math unit 32-bit input 4
GS $D794 MATH:MATHIN5 Math unit 32-bit input 5
GS $D795 MATH:MATHIN5 Math unit 32-bit input 5
GS $D796 MATH:MATHIN5 Math unit 32-bit input 5
GS $D797 MATH:MATHIN5 Math unit 32-bit input 5
GS $D798 MATH:MATHIN6 Math unit 32-bit input 6
GS $D799 MATH:MATHIN6 Math unit 32-bit input 6
GS $D79A MATH:MATHIN6 Math unit 32-bit input 6
GS $D79B MATH:MATHIN6 Math unit 32-bit input 6
GS $D79C MATH:MATHIN7 Math unit 32-bit input 7
GS $D79D MATH:MATHIN7 Math unit 32-bit input 7
GS $D79E MATH:MATHIN7 Math unit 32-bit input 7
GS $D79F MATH:MATHIN7 Math unit 32-bit input 7
GS $D7A0 MATH:MATHIN8 Math unit 32-bit input 8
GS $D7A1 MATH:MATHIN8 Math unit 32-bit input 8
GS $D7A2 MATH:MATHIN8 Math unit 32-bit input 8
GS $D7A3 MATH:MATHIN8 Math unit 32-bit input 8
GS $D7A4 MATH:MATHIN9 Math unit 32-bit input 9
GS $D7A5 MATH:MATHIN9 Math unit 32-bit input 9
GS $D7A6 MATH:MATHIN9 Math unit 32-bit input 9
GS $D7A7 MATH:MATHIN9 Math unit 32-bit input 9
GS $D7A8 MATH:MATHIN10 Math unit 32-bit input 10
GS $D7A9 MATH:MATHIN10 Math unit 32-bit input 10
GS $D7AA MATH:MATHIN10 Math unit 32-bit input 10
GS $D7AB MATH:MATHIN10 Math unit 32-bit input 10
GS $D7AC MATH:MATHIN11 Math unit 32-bit input 11
GS $D7AD MATH:MATHIN11 Math unit 32-bit input 11
GS $D7AE MATH:MATHIN11 Math unit 32-bit input 11
GS $D7AF MATH:MATHIN11 Math unit 32-bit input 11
GS $D7B0 MATH:MATHIN12 Math unit 32-bit input 12
GS $D7B1 MATH:MATHIN12 Math unit 32-bit input 12
GS $D7B2 MATH:MATHIN12 Math unit 32-bit input 12
GS $D7B3 MATH:MATHIN12 Math unit 32-bit input 12
GS $D7B4 MATH:MATHIN13 Math unit 32-bit input 13
GS $D7B5 MATH:MATHIN13 Math unit 32-bit input 13
GS $D7B6 MATH:MATHIN13 Math unit 32-bit input 13
GS $D7B7 MATH:MATHIN13 Math unit 32-bit input 13
GS $D7B8 MATH:MATHIN14 Math unit 32-bit input 14
GS $D7B9 MATH:MATHIN14 Math unit 32-bit input 14
GS $D7BA MATH:MATHIN14 Math unit 32-bit input 14
GS $D7BB MATH:MATHIN14 Math unit 32-bit input 14
GS $D7BC MATH:MATHIN15 Math unit 32-bit input 15
GS $D7BD MATH:MATHIN15 Math unit 32-bit input 15
GS $D7BE MATH:MATHIN15 Math unit 32-bit input 15
GS $D7BF MATH:MATHIN15 Math unit 32-bit input 15
GS $D7C0.0-3 MATH:UNIT0INA Select which of the 16 32-bit math registers is input A for Math Function Unit 0.
GS $D7C0.4-7 MATH:UNIT0INB Select which of the 16 32-bit math registers is input B for Math Function Unit 0.
GS $D7C0-$D7CF - 16 Math function unit input A (3-0) and input B (7-4) selects
GS $D7C1.0-3 MATH:UNIT1INA Select which of the 16 32-bit math registers is input A for Math Function Unit 1.
GS $D7C1.4-7 MATH:UNIT1INB Select which of the 16 32-bit math registers is input B for Math Function Unit 1.
GS $D7C2.0-3 MATH:UNIT2INA Select which of the 16 32-bit math registers is input A for Math Function Unit 2.
GS $D7C2.4-7 MATH:UNIT2INB Select which of the 16 32-bit math registers is input B for Math Function Unit 2.
GS $D7C3.0-3 MATH:UNIT3INA Select which of the 16 32-bit math registers is input A for Math Function Unit 3.
GS $D7C3.4-7 MATH:UNIT3INB Select which of the 16 32-bit math registers is input B for Math Function Unit 3.
GS $D7C4.0-3 MATH:UNIT4INA Select which of the 16 32-bit math registers is input A for Math Function Unit 4.
GS $D7C4.4-7 MATH:UNIT4INB Select which of the 16 32-bit math registers is input B for Math Function Unit 4.
GS $D7C5.0-3 MATH:UNIT5INA Select which of the 16 32-bit math registers is input A for Math Function Unit 5.
GS $D7C5.4-7 MATH:UNIT5INB Select which of the 16 32-bit math registers is input B for Math Function Unit 5.
GS $D7C6.0-3 MATH:UNIT6INA Select which of the 16 32-bit math registers is input A for Math Function Unit 6.
GS $D7C6.4-7 MATH:UNIT6INB Select which of the 16 32-bit math registers is input B for Math Function Unit 6.
GS $D7C7.0-3 MATH:UNIT7INA Select which of the 16 32-bit math registers is input A for Math Function Unit 7.
GS $D7C7.4-7 MATH:UNIT7INB Select which of the 16 32-bit math registers is input B for Math Function Unit 7.
GS $D7C8.0-3 MATH:UNIT8INA Select which of the 16 32-bit math registers is input A for Math Function Unit 8.
GS $D7C8.4-7 MATH:UNIT8INB Select which of the 16 32-bit math registers is input B for Math Function Unit 8.
GS $D7C9.0-3 MATH:UNIT9INA Select which of the 16 32-bit math registers is input A for Math Function Unit 9.
GS $D7C9.4-7 MATH:UNIT9INB Select which of the 16 32-bit math registers is input B for Math Function Unit 9.
GS $D7CA.0-3 MATH:UNIT10INA Select which of the 16 32-bit math registers is input A for Math Function Unit 10.
GS $D7CA.4-7 MATH:UNIT10INB Select which of the 16 32-bit math registers is input B for Math Function Unit 10.
GS $D7CB.0-3 MATH:UNIT11INA Select which of the 16 32-bit math registers is input A for Math Function Unit 11.
GS $D7CB.4-7 MATH:UNIT11INB Select which of the 16 32-bit math registers is input B for Math Function Unit 11.
GS $D7CC.0-3 MATH:UNIT12INA Select which of the 16 32-bit math registers is input A for Math Function Unit 12.
GS $D7CC.4-7 MATH:UNIT12INB Select which of the 16 32-bit math registers is input B for Math Function Unit 12.
GS $D7CD.0-3 MATH:UNIT13INA Select which of the 16 32-bit math registers is input A for Math Function Unit 13.
GS $D7CD.4-7 MATH:UNIT13INB Select which of the 16 32-bit math registers is input B for Math Function Unit 13.
GS $D7CE.0-3 MATH:UNIT14INA Select which of the 16 32-bit math registers is input A for Math Function Unit 14.
GS $D7CE.4-7 MATH:UNIT14INB Select which of the 16 32-bit math registers is input B for Math Function Unit 14.
GS $D7CF.0-3 MATH:UNIT15INA Select which of the 16 32-bit math registers is input A for Math Function Unit 15.
GS $D7CF.4-7 MATH:UNIT15INB Select which of the 16 32-bit math registers is input B for Math Function Unit 15.
GS $D7D0.0-3 MATH:UNIT0OUT Select which of the 16 32-bit math registers receives the output of Math Function Unit 0
GS $D7D0.4 - MATH:U0LOWOUT If set, the low-half of the output of Math Function Unit 0 is written to math register UNIT0OUT.
GS $D7D0.5 - MATH:U0HIOUT If set, the high-half of the output of Math Function Unit 0 is written to math register UNIT0OUT.
GS $D7D0.6 - MATH:U0ADD If set, Math Function Unit 0 acts as a 32-bit adder instead of 32-bit multiplier.
GS $D7D0.7 - MATH:U0LATCH If set, Math Function Unit 0's output is latched.
GS $D7D1.0-3 MATH:UNIT1OUT Select which of the 16 32-bit math registers receives the output of Math Function Unit 1
GS $D7D1.4 - MATH:U1LOWOUT If set, the low-half of the output of Math Function Unit 1 is written to math register UNIT1OUT.
GS $D7D1.5 - MATH:U1HIOUT If set, the high-half of the output of Math Function Unit 1 is written to math register UNIT1OUT.
GS $D7D1.6 - MATH:U1ADD If set, Math Function Unit 1 acts as a 32-bit adder instead of 32-bit multiplier.
GS $D7D1.7 - MATH:U1LATCH If set, Math Function Unit 1's output is latched.
GS $D7D2.0-3 MATH:UNIT2OUT Select which of the 16 32-bit math registers receives the output of Math Function Unit 2
GS $D7D2.4 - MATH:U2LOWOUT If set, the low-half of the output of Math Function Unit 2 is written to math register UNIT2OUT.
GS $D7D2.5 - MATH:U2HIOUT If set, the high-half of the output of Math Function Unit 2 is written to math register UNIT2OUT.
GS $D7D2.6 - MATH:U2ADD If set, Math Function Unit 2 acts as a 32-bit adder instead of 32-bit multiplier.
GS $D7D2.7 - MATH:U2LATCH If set, Math Function Unit 2's output is latched.
GS $D7D3.0-3 MATH:UNIT3OUT Select which of the 16 32-bit math registers receives the output of Math Function Unit 3
GS $D7D3.4 - MATH:U3LOWOUT If set, the low-half of the output of Math Function Unit 3 is written to math register UNIT3OUT.
GS $D7D3.5 - MATH:U3HIOUT If set, the high-half of the output of Math Function Unit 3 is written to math register UNIT3OUT.
GS $D7D3.6 - MATH:U3ADD If set, Math Function Unit 3 acts as a 32-bit adder instead of 32-bit multiplier.
GS $D7D3.7 - MATH:U3LATCH If set, Math Function Unit 3's output is latched.
GS $D7D4.0-3 MATH:UNIT4OUT Select which of the 16 32-bit math registers receives the output of Math Function Unit 4
GS $D7D4.4 - MATH:U4LOWOUT If set, the low-half of the output of Math Function Unit 4 is written to math register UNIT4OUT.
GS $D7D4.5 - MATH:U4HIOUT If set, the high-half of the output of Math Function Unit 4 is written to math register UNIT4OUT.
GS $D7D4.6 - MATH:U4ADD If set, Math Function Unit 4 acts as a 32-bit adder instead of 32-bit multiplier.
GS $D7D4.7 - MATH:U4LATCH If set, Math Function Unit 4's output is latched.
GS $D7D5.0-3 MATH:UNIT5OUT Select which of the 16 32-bit math registers receives the output of Math Function Unit 5
GS $D7D5.4 - MATH:U5LOWOUT If set, the low-half of the output of Math Function Unit 5 is written to math register UNIT5OUT.
GS $D7D5.5 - MATH:U5HIOUT If set, the high-half of the output of Math Function Unit 5 is written to math register UNIT5OUT.
GS $D7D5.6 - MATH:U5ADD If set, Math Function Unit 5 acts as a 32-bit adder instead of 32-bit multiplier.
GS $D7D5.7 - MATH:U5LATCH If set, Math Function Unit 5's output is latched.
GS $D7D6.0-3 MATH:UNIT6OUT Select which of the 16 32-bit math registers receives the output of Math Function Unit 6
GS $D7D6.4 - MATH:U6LOWOUT If set, the low-half of the output of Math Function Unit 6 is written to math register UNIT6OUT.
GS $D7D6.5 - MATH:U6HIOUT If set, the high-half of the output of Math Function Unit 6 is written to math register UNIT6OUT.
GS $D7D6.6 - MATH:U6ADD If set, Math Function Unit 6 acts as a 32-bit adder instead of 32-bit multiplier.
GS $D7D6.7 - MATH:U6LATCH If set, Math Function Unit 6's output is latched.
GS $D7D7.0-3 MATH:UNIT7OUT Select which of the 16 32-bit math registers receives the output of Math Function Unit 7
GS $D7D7.4 - MATH:U7LOWOUT If set, the low-half of the output of Math Function Unit 7 is written to math register UNIT7OUT.
GS $D7D7.5 - MATH:U7HIOUT If set, the high-half of the output of Math Function Unit 7 is written to math register UNIT7OUT.
GS $D7D7.6 - MATH:U7ADD If set, Math Function Unit 7 acts as a 32-bit adder instead of 32-bit multiplier.
GS $D7D7.7 - MATH:U7LATCH If set, Math Function Unit 7's output is latched.
GS $D7D8.0-3 MATH:UNIT8OUT Select which of the 16 32-bit math registers receives the output of Math Function Unit 8
GS $D7D8.4 - MATH:U8LOWOUT If set, the low-half of the output of Math Function Unit 8 is written to math register UNIT8OUT.
GS $D7D8.5 - MATH:U8HIOUT If set, the high-half of the output of Math Function Unit 8 is written to math register UNIT8OUT.
GS $D7D8.6 - MATH:U8ADD If set, Math Function Unit 8 acts as a 32-bit adder instead of 32-bit barrel-shifter.
GS $D7D8.7 - MATH:U8LATCH If set, Math Function Unit 8's output is latched.
GS $D7D9.0-3 MATH:UNIT9OUT Select which of the 16 32-bit math registers receives the output of Math Function Unit 9
GS $D7D9.4 - MATH:U9LOWOUT If set, the low-half of the output of Math Function Unit 9 is written to math register UNIT9OUT.
GS $D7D9.5 - MATH:U9HIOUT If set, the high-half of the output of Math Function Unit 9 is written to math register UNIT9OUT.
GS $D7D9.6 - MATH:U9ADD If set, Math Function Unit 9 acts as a 32-bit adder instead of 32-bit barrel-shifter.
GS $D7D9.7 - MATH:U9LATCH If set, Math Function Unit 9's output is latched.
GS $D7DA.0-3 MATH:UNIT10OUT Select which of the 16 32-bit math registers receives the output of Math Function Unit A
GS $D7DA.4 - MATH:UALOWOUT If set, the low-half of the output of Math Function Unit A is written to math register UNIT10OUT.
GS $D7DA.5 - MATH:UAHIOUT If set, the high-half of the output of Math Function Unit A is written to math register UNIT10OUT.
GS $D7DA.6 - MATH:UAADD If set, Math Function Unit A acts as a 32-bit adder instead of 32-bit barrel-shifter.
GS $D7DA.7 - MATH:UALATCH If set, Math Function Unit A's output is latched.
GS $D7DB.0-3 MATH:UNIT11OUT Select which of the 16 32-bit math registers receives the output of Math Function Unit B
GS $D7DB.4 - MATH:UBLOWOUT If set, the low-half of the output of Math Function Unit B is written to math register UNIT11OUT.
GS $D7DB.5 - MATH:UBHIOUT If set, the high-half of the output of Math Function Unit B is written to math register UNIT11OUT.
GS $D7DB.6 - MATH:UBADD If set, Math Function Unit B acts as a 32-bit adder instead of 32-bit barrel-shifter.
GS $D7DB.7 - MATH:UBLATCH If set, Math Function Unit B's output is latched.
GS $D7DC.0-3 MATH:UNIT12OUT Select which of the 16 32-bit math registers receives the output of Math Function Unit C
GS $D7DC.4 - MATH:UCLOWOUT If set, the low-half of the output of Math Function Unit C is written to math register UNIT12OUT.
GS $D7DC.5 - MATH:UCHIOUT If set, the high-half of the output of Math Function Unit C is written to math register UNIT12OUT.
GS $D7DC.6 - MATH:UCADD If set, Math Function Unit C acts as a 32-bit adder instead of 32-bit divider.
GS $D7DC.7 - MATH:UCLATCH If set, Math Function Unit C's output is latched.
GS $D7DD.0-3 MATH:UNIT13OUT Select which of the 16 32-bit math registers receives the output of Math Function Unit D
GS $D7DD.4 - MATH:UDLOWOUT If set, the low-half of the output of Math Function Unit D is written to math register UNIT13OUT.
GS $D7DD.5 - MATH:UDHIOUT If set, the high-half of the output of Math Function Unit D is written to math register UNIT13OUT.
GS $D7DD.6 - MATH:UDADD If set, Math Function Unit D acts as a 32-bit adder instead of 32-bit divider.
GS $D7DD.7 - MATH:UDLATCH If set, Math Function Unit D's output is latched.
GS $D7DE.0-3 MATH:UNIT14OUT Select which of the 16 32-bit math registers receives the output of Math Function Unit E
GS $D7DE.4 - MATH:UELOWOUT If set, the low-half of the output of Math Function Unit E is written to math register UNIT14OUT.
GS $D7DE.5 - MATH:UEHIOUT If set, the high-half of the output of Math Function Unit E is written to math register UNIT14OUT.
GS $D7DE.6 - MATH:UEADD If set, Math Function Unit E acts as a 32-bit adder instead of 32-bit divider.
GS $D7DE.7 - MATH:UELATCH If set, Math Function Unit E's output is latched.
GS $D7DF.0-3 MATH:UNIT15OUT Select which of the 16 32-bit math registers receives the output of Math Function Unit F
GS $D7DF.4 - MATH:UFLOWOUT If set, the low-half of the output of Math Function Unit F is written to math register UNIT15OUT.
GS $D7DF.5 - MATH:UFHIOUT If set, the high-half of the output of Math Function Unit F is written to math register UNIT15OUT.
GS $D7DF.6 - MATH:UFADD If set, Math Function Unit F acts as a 32-bit adder instead of 32-bit divider.
GS $D7DF.7 - MATH:UFLATCH If set, Math Function Unit F's output is latched.
GS $D7E0 MATH:LATCHINT Latch interval for latched outputs (in CPU cycles)
GS $D7E0 - Math unit latch interval (only update output of math function units every this many cycles, if they have the latch output flag set)
GS $D7E1.0 MATH:WREN Enable setting of math registers (must normally be set)
GS $D7E1.1 MATH:CALCEN Enable committing of output values from math units back to math registers (clearing effectively pauses iterative formulae)
GS $D7E1 - Math unit general settings (writing also clears math cycle counter)
GS $D7E2 MATH:RESERVED Reserved
GS $D7E3 MATH:RESERVED Reserved
GS $D7E4 MATH:ITERCNT Iteration Counter (32 bit)
GS $D7E5 MATH:ITERCNT Iteration Counter (32 bit)
GS $D7E6 MATH:ITERCNT Iteration Counter (32 bit)
GS $D7E7 MATH:ITERCNT Iteration Counter (32 bit)
GS $D7E8 MATH:ITERCMP Math iteration counter comparator (32 bit)
GS $D7E9 MATH:ITERCMP Math iteration counter comparator (32 bit)
GS $D7EA MATH:ITERCMP Math iteration counter comparator (32 bit)
GS $D7EB MATH:ITERCMP Math iteration counter comparator (32 bit)
GS $D7FA CPU:SPEEDBIAS 1/2/3.5MHz CPU speed fine adjustment
GS $D7FB.0 CPU:BRCOST 1=charge extra cycle(s) for branches taken
GS $D7FB.1 CPU:CARTEN 1= enable cartridges
GS $D7FC DEBUG chip-select enables for various devices
GS $D7FD.6 CPU:NOGAME Override for /GAME : Must be 0 to enable /GAME signal
GS $D7FD.6 CPU:POWEREN Set to zero to power off computer on supported systems. WRITE ONLY.
GS $D7FD.7 CPU:NOEXROM Override for /EXROM : Must be 0 to enable /EXROM signal
C64 $DC00 CIA1:PORTA Port A 
C64 $DC01 CIA1:PORTB Port B
C64 $DC02 CIA1:DDRA Port A DDR
C64 $DC03 CIA1:DDRB Port B DDR
C64 $DC04 CIA1:TIMERA Timer A counter (16 bit)
C64 $DC05 CIA1:TIMERA Timer A counter (16 bit)
C64 $DC06 CIA1:TIMERB Timer B counter (16 bit)
C64 $DC07 CIA1:TIMERB Timer B counter (16 bit)
C64 $DC08.0-3 CIA1:TODJIF TOD tenths of seconds
C64 $DC09.0-5 CIA1:TODSEC TOD seconds
C64 $DC0A.0-5 CIA1:TODSEC TOD minutes
C64 $DC0B.0-4 CIA1:TODHOUR TOD hours
C64 $DC0B.7 CIA1:TODAMPM TOD PM flag
C64 $DC0C CIA1:SDR shift register data register(writing starts sending)
C64 $DC0D.0 CIA1:TA Timer A underflow
C64 $DC0D.1 CIA1:TB Timer B underflow
C64 $DC0D.2 CIA1:ALRM TOD alarm
C64 $DC0D.3 CIA1:SP shift register full/empty
C64 $DC0D.4 CIA1:FLG FLAG edge detected
C64 $DC0D.7 CIA1:IR Interrupt flag
C64 $DC0D CIA1 ISR : Reading clears events
C64 $DC0E.0 CIA1:STRTA Timer A start
C64 $DC0E.1 CIA1:PBONA Timer A PB6 out
C64 $DC0E.2 CIA1:OMODA Timer A toggle or pulse
C64 $DC0E.3 CIA1:RMODA Timer A one-shot mode
C64 $DC0E.5 CIA1:IMODA Timer A Timer A tick source
C64 $DC0E.6 CIA1:SPMOD Serial port direction
C64 $DC0E.7 CIA1:TOD50 50/60Hz select for TOD clock
C64 $DC0F.0 CIA1:STRTB Timer B start
C64 $DC0F.1 CIA1:PBONB Timer B PB7 out
C64 $DC0F.2 CIA1:OMODB Timer B toggle or pulse
C64 $DC0F.3 CIA1:RMODB Timer B one-shot mode
C64 $DC0F.4 CIA1:LOAD Strobe input to force-load timers
C64 $DC0F.5-6 CIA1:IMODB Timer B Timer A tick source
C64 $DC0F.7 CIA2:TODEDIT TOD alarm edit
GS $DC10 CIA1:TALATCH Timer A latch value (16 bit)
GS $DC11 CIA1:TALATCH Timer A latch value (16 bit)
GS $DC12 CIA1:TALATCH Timer B latch value (16 bit)
GS $DC13 CIA1:TALATCH Timer B latch value (16 bit)
GS $DC14 CIA1:TALATCH Timer A current value (16 bit)
GS $DC15 CIA1:TALATCH Timer A current value (16 bit)
GS $DC16 CIA1:TALATCH Timer B current value (16 bit)
GS $DC17 CIA1:TALATCH Timer B current value (16 bit)
GS $DC18.0-3 CIA1:TODJIF TOD 10ths of seconds value
GS $DC18.4 CIA1:IMTB Interrupt mask for Timer B
GS $DC18.5 CIA1:IMALRM Interrupt mask for TOD alarm
GS $DC18.6 CIA1:IMSP Interrupt mask for shift register (serial port)
GS $DC18.7 CIA1:IMFLG Interrupt mask for FLAG line
GS $DC19 CIA1:TODSEC TOD Alarm seconds value
GS $DC1A CIA1:TODMIN TOD Alarm minutes value
GS $DC1B.0-6 CIA1:TODHOUR TOD hours value
GS $DC1B.7 CIA1:TODAMPM TOD AM/PM flag
GS $DC1C CIA1:ALRMJIF TOD Alarm 10ths of seconds value
GS $DC1D CIA1:ALRMSEC TOD Alarm seconds value
GS $DC1E CIA1:ALRMMIN TOD Alarm minutes value
GS $DC1F.0-6 CIA1:ALRMHOUR TOD Alarm hours value
GS $DC1F.7 CIA1:ALRMAMPM TOD Alarm AM/PM flag
C64 $DD00 CIA2:PORTA Port A 
C64 $DD01 CIA2:PORTB Port B
C64 $DD02 CIA2:DDRA Port A DDR
C64 $DD03 CIA2:DDRB Port B DDR
C64 $DD04 CIA2:TIMERA Timer A counter (16 bit)
C64 $DD05 CIA2:TIMERA Timer A counter (16 bit)
C64 $DD06 CIA2:TIMERB Timer B counter (16 bit)
C64 $DD07 CIA2:TIMERB Timer B counter (16 bit)
C64 $DD08.0-3 CIA2:TODJIF TOD tenths of seconds
C64 $DD09.0-5 CIA2:TODSEC TOD seconds
C64 $DD0A.0-5 CIA2:TODSEC TOD minutes
C64 $DD0B.0-4 CIA2:TODHOUR TOD hours
C64 $DD0B.7 CIA2:TODAMPM TOD PM flag
C64 $DD0C CIA2:SDR shift register data register(writing starts sending)
C64 $DD0D.0 CIA2:TA Timer A underflow
C64 $DD0D.1 CIA2:TB Timer B underflow
C64 $DD0D.2 CIA2:ALRM TOD alarm
C64 $DD0D.3 CIA2:SP shift register full/empty
C64 $DD0D.4 CIA2:FLG FLAG edge detected
C64 $DD0D CIA2 ISR : Reading clears events
C64 $DD0E.0 CIA2:STRTA Timer A start
C64 $DD0E.1 CIA2:PBONA Timer A PB6 out
C64 $DD0E.2 CIA2:OMODA Timer A toggle or pulse
C64 $DD0E.3 CIA2:RMODA Timer A one-shot mode
C64 $DD0E.5 CIA2:IMODA Timer A Timer A tick source
C64 $DD0E.6 CIA2:SPMOD Serial port direction
C64 $DD0E.7 CIA2:TOD50 50/60Hz select for TOD clock
C64 $DD0F.0 CIA2:STRTB Timer B start
C64 $DD0F.1 CIA2:PBONB Timer B PB7 out
C64 $DD0F.2 CIA2:OMODB Timer B toggle or pulse
C64 $DD0F.3 CIA2:RMODB Timer B one-shot mode
C64 $DD0F.4 CIA2:LOAD Strobe input to force-load timers
C64 $DD0F.5-6 CIA2:IMODB Timer B Timer A tick source
C64 $DD0F.7 CIA2:TODEDIT TOD alarm edit
GS $DD10 CIA2:TALATCH Timer A latch value (16 bit)
GS $DD11 CIA2:TALATCH Timer A latch value (16 bit)
GS $DD12 CIA2:TALATCH Timer B latch value (16 bit)
GS $DD13 CIA2:TALATCH Timer B latch value (16 bit)
GS $DD14 CIA2:TALATCH Timer A current value (16 bit)
GS $DD15 CIA2:TALATCH Timer A current value (16 bit)
GS $DD16 CIA2:TALATCH Timer B current value (16 bit)
GS $DD17 CIA2:TALATCH Timer B current value (16 bit)
GS $DD18.0-3 CIA2:TODJIF TOD 10ths of seconds value
GS $DD18.4 CIA2:IMTB Interrupt mask for Timer B
GS $DD18.5 CIA2:IMALRM Interrupt mask for TOD alarm
GS $DD18.6 CIA2:IMSP Interrupt mask for shift register (serial port)
GS $DD18.7 CIA2:IMFLG Interrupt mask for FLAG line
GS $DD19 CIA2:TODSEC TOD Alarm seconds value
GS $DD1A CIA2:TODMIN TOD Alarm minutes value
GS $DD1B.0-6 CIA2:TODHOUR TOD hours value
GS $DD1B.7 CIA2:TODAMPM TOD AM/PM flag
GS $DD1C CIA2:ALRMJIF TOD Alarm 10ths of seconds value
GS $DD1D CIA2:ALRMSEC TOD Alarm seconds value
GS $DD1E CIA2:ALRMMIN TOD Alarm minutes value
GS $DD1F.0-6 CIA2:ALRMHOUR TOD Alarm hours value
GS $DD1F.7 CIA2:ALRMAMPM TOD Alarm AM/PM flag
GS ETH:$D6E0 Ethernet control
GS $FF7E000-$FF7EFFF SUMMARY:CHARWRITE VIC-IV CHARROM write area
GS $FF7Exxx VIC-IV CHARROM write area
GS $FF80000-$FF87FFF SUMMARY:COLOURRAM Colour RAM (32KB or 64KB)
GS $FF8xxxx - Colour RAM (32KB or 64KB)
GS $FFcB000-$FFcBFFF - Internal 1541 ROM access
GS $FFCC000-$FFCFFFF - Internal 1541 ROM access
GS $FFD6C00-DFF - F011 floppy controller sector buffer
GS $FFD6E00-FFF - SD card direct access sector buffer
GS $FFD7000-FF - I2C Peripherals     
GS $FFD70F0 - ADC1 smoothed value (LSB)
GS $FFD70F1 - ADC1 smoothed value (MSB)
GS $FFD70F2 - ADC2 smoothed value (LSB)
GS $FFD70F3 - ADC2 smoothed value (MSB)
GS $FFD70F4 - ADC3 smoothed value (LSB)
GS $FFD70F5 - ADC3 smoothed value (MSB)
GS $FFD7100-07 UUID:UUID64 64-bit UUID. Can be used to seed ethernet MAC address
GS $FFD7110-3F RTC:RTC Real-time Clock
GS $FFD7110 RTC:RTCSEC Real-time Clock seconds value (binary coded decimal)
GS $FFD7111 RTC:RTCMIN Real-time Clock minutes value (binary coded decimal)
GS $FFD7112 RTC:RTCHOUR Real-time Clock hours value (binary coded decimal)
GS $FFD7113 RTC:RTCDAY Real-time Clock day of month value (binary coded decimal)
GS $FFD7114 RTC:RTCMONTH Real-time Clock month value (binary coded decimal)
GS $FFD7115 RTC:RTCYEAR Real-time Clock year value (binary coded decimal)
GS $FFD7140-7F RTC:NVRAM 64-bytes of non-volatile RAM. Can be used for storing machine configuration.
GS $FFDE800 - $FFDEFFF Ethernet RX buffer (read only)
GS $FFDE800 - $FFDEFFF Ethernet TX buffer (write only)
GS $FFDF000 - VFPGA width of CLB array (READ ONLY)
GS $FFDF001 - VFPGA height of CLB array (READ ONLY)
GS $FFDF002 - VFPGA Logical wire cardinality (READ ONLY)
GS $FFDF003 - VFPGA number of LUTs per CLB (READ ONLY)
GS $FFDF004 - VFPGA number of inputs per CLB (READ ONLY)
GS $FFDF005 - VFPGA number of inputs per LUT (READ ONLY)
GS $FFDF006 - VFPGA number of IO pins (READ ONLY)
GS $FFDF007 - VFPGA number of bytes in bitstream (LSB) (READ ONLY)
GS $FFDF008 - VFPGA number of bytes in bitstream (MSB) (READ ONLY)
GS $FFDF009 - VFPGA number of bytes in snapshot (LSB) (READ ONLY)
GS $FFDF00A - VFPGA number of bytes in snapshot (MSB) (READ ONLY)
GS $FFDF00B.0 - VFPGA DMA engine present flag (READ ONLY)
GS $FFDF00B.1 - VFPGA memory access engine present flag (READ ONLY)
GS $FFDF00B.2 - VFPGA interrupt pin present flag (READ ONLY)
GS $FFDF00B.3 - VFPGA cycle count done flag (READ ONLY)
GS $FFDF00B.4 - VFPGA reset (1= VFPGA is held under reset)
GS $FFDF00B.5 - VFPGA clk_done_IE flag
GS $FFDF00B.6 - VFPGA global_interrupt_IE flag 
GS $FFDF00B.7 - VFPGA global_interrupt flag (READ ONLY)
GS $FFDF00C - VFPGA SHA1 hash of architecture LSBs
GS $FFDF00D - VFPGA SHA1 hash of architecture LSBs
GS $FFDF00E - VFPGA SHA1 hash of architecture LSBs
GS $FFDF00F - VFPGA SHA1 hash of architecture LSBs
GS $FFDF010 - VFPGA logical clock divisor (LSB)
GS $FFDF011 - VFPGA logical clock divisor (MSB)
GS $FFDF012 - VFPGA cycle clock counter (LSB)
GS $FFDF013 - VFPGA cycle clock counter (SSB)
GS $FFDF014 - VFPGA cycle clock counter (MSB)
GS $FFDF015 - VFPGA config access register: Reads or writes single byte of bitstream
GS $FFDF015 - VFPGA config access register: Reads or writes single byte of state snapshot vector
GS $FFDF02x - VFPGA read output pins, with automatic ACK to FPGA on input bits 8-14 for $FFDF020-$FFDF026
GS $FFDF03x - vFPGA input registers, with auto acknowledgement of reads by toggling input bits 0-6 when $FFDF030-$FFD036 are read
GS $FFF8000-$FFF80FC Hypervisor entry point when $D640-$D67F is written
GS $FFF8000-$FFFBFFF 16KB Hyppo/hypervisor ROM
GS $FFF8000-$FFFBFFF 16KB Hyppo/Hypervisor ROM
GS $FFF8000-$FFFBFFF SUMMARY:HYPERVISOR 16KB Hyppo/Hypervisor ROM
GS $FFF8100 Hypervisor entry point on reset (trap $40)
GS $FFF8104 Hypervisor entry point on page fault (trap $41)
GS $FFF8108 Hypervisor entry point on RESTORE long-press (trap $42)
GS $FFF810C Hypervisor entry point on C=-TAB / ALT-TAB (trap $43)
GS $FFF8110 Hypervisor entry point on FDC read (when virtualised) (trap $44)
GS $FFF8114 Hypervisor entry point on FDC write (when virtualised) (trap $45)
