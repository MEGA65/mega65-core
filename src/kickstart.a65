; MEGA65 Kick Start ROM.
; Paul Gardner-Stephen, 2014-2016.
;
; Purpose: 
; 1. Verify checksum of ROM area of slow RAM.
; 1. If checksum fails, load complete ROM from SD card.
; 2. Select default disk image for F011 emulation.
;
; The kickstart ROM is 16KB in length, and maps at $8000-$BFFF
; in hypervisor mode.
;
; Kickstart modifies RAM from $0000-$07FFF (ZP, stack, 40-column
; screen, 16-bit text mode) during normal boot.
;
;
; BG: is the below true still, I dont think so.
; If Kickstart needs to load the ROM from SD card, then it may
; modify the first 64KB of fast ram.
;
;
; We will use the convention of C=0 means failure, ie CLC/RTS,
;                           and C=1 means success, ie SEC/RTS.
;
;
;	; this included file defines many of the alias used throughout
;	; it also suggests some memory-map definitions
;	;

	.include "kickstart_machine.a65"

;
; scratch space in ZP space usually used by kernel
; we try to use address space not normally used by C64 kernel, so that
; it is possible to make calls to kickstart after boot.  Eventually
; the desire is to have an SYS call that brings up a menu that lets
; you choose a disk image from a list.
;
	.data 

;	========================
	.org $ce00
;	========================

	.space romslab 1
	.space screenrow 1 

	.space checksum 4
	.space file_pagesread 2

	; variables for testing of D81 boot image
	;
	.space d81_clusternumber 4
	.space d81_clustersneeded 2
	.space d81_clustercount 2

	; make sure that we don't go past the 256 byte page reserved for hypervisor scratch space
	;
	.checkpc $CEFF

	.text

;	========================
	.org $8000
;	========================

;;; ----------------------------------------------------------------------------
;;; CPU Hypervisor Trap entry points.
;;; 64 x 4 byte entries for user-land traps.
;;; some more x 4 byte entries for system traps (reset, page fault etc)
;;; ----------------------------------------------------------------------------

trap_entry_points:

	; Traps $00-$07 (user callable)
	;
	jmp dos_and_process_trap	; Trap #$00 (unsure what to call it)
	nop				; refer: kickstart_dos.a65
	jmp memory_trap                 ; Trap #$01
	nop                             ; refer: kickstart_mem.a65
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop

	; Traps $08-$0F (user callable)
	;
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop

	; Traps $10-$17 (user callable)
	;
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop

	; Traps $18-$1F (user callable)
	;
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop

	; Traps $20-$27 (user callable)
	;
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop

	; Traps $28-$2F (user callable)
	;
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop

	; Traps $30-$37
	;
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop

	jmp protected_hardware_config	; Trap #$32 (Protected Hardware Configuration) 
	nop			  	; refer: kickstart_task


	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop

	; Traps $38-$3F (user callable)
	;
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop

;	========================

	; Traps $40-$4F (reset, page fault and other system-generated traps)
	jmp reset_entry			; Trap #$40 (power on / reset)
	nop				; refer: below in this file

	jmp page_fault			; Trap #$41 (page fault)
	nop				; refer: kickstart_mem

	jmp double_restore_trap		; Trap #$42 (double-tap RESTORE key)
	nop				; refer: kickstart_task "1000010" x"42"

	jmp matrix_mode_toggle          ; Trap #$43 (C= + TAB combination)
	nop				; refer: kickstart_task

	jmp f011_virtual_read           ; Trap #$44 (virtualised F011 sector read)
	nop

	jmp f011_virtual_write	        ; Trap #$44 (virtualised F011 sector write)
	nop

	jmp nosuchtrap			; common-trap (catch all)
	nop				; refer: below in this file
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop


	; Leave room for relocated cpu vectors below
	;
	.checkpc $81F8
	.advance $81F8

	; Then we have relocated CPU vectors at $81F8-$81FF
	; (which are 2-byte vectors for interrupts, not 4-byte
	; trap addresses).
	; These are used to catch interrupts in hypervisor mode
	; (although the need for them may have since been removed)
	.word reset_entry    ; unused vector
	.word hypervisor_nmi ; NMI
	.word reset_entry    ; RESET
	.word hypervisor_irq ; IRQ

	.checkpc $8200
	.advance $8200

;;; ----------------------------------------------------------------------------
;;; Hypervisor traps
;;; ----------------------------------------------------------------------------
	

;;; ----------------------------------------------------------------------------
;;; Illegal trap / trap sub-function handlers
;;; ----------------------------------------------------------------------------
;
; Traps are triggered by writing to $D640-$D67F
; and trap to $8000+((address & $3F)*4) in the hypervisor

; Routine for unimplemented/reserved traps
; (Consider replacing with trap to hypervisor error screen with option
;  to return?)
;
nosuchtrap:

	; Clear C flag for caller to indicate failure
	;
	lda hypervisor_flags
	and #$FE   ; C flag is bit 0
	sta hypervisor_flags

	; set A to $FF
	;
	lda #$ff
	sta hypervisor_a

	; return from hypervisor
	;
	sta hypervisor_enterexit_trigger

;	========================

return_from_trap_with_success:

	; Return from trap with C flag clear to indicate success

	jsr sd_unmap_sectorbuffer	

	; set C flag for caller to indicate success
	;
	lda hypervisor_flags
	ora #$01   ; C flag is bit 0
	sta hypervisor_flags

	jsr checkpoint
	.byte 0,"return_from_trap_with_success",0

	; return from hypervisor
	sta hypervisor_enterexit_trigger

;	========================

return_from_trap_with_failure:

	jsr sd_unmap_sectorbuffer	

	; report error in A
	;
	sta hypervisor_a
	lda hypervisor_flags
	and #$fe   ; C flag is bit 0 (ie clear bit-0)
	sta hypervisor_flags

	jsr checkpoint
	.byte 0,"return_from_trap_with_failure",0

	; return from hypervisor
	sta hypervisor_enterexit_trigger	

;	========================

invalid_subfunction:

	jmp nosuchtrap

;	========================

;;; ----------------------------------------------------------------------------
;;; DOS, process control and related functions trap
;;; ----------------------------------------------------------------------------
		.include "kickstart_dos.a65"

;;; ----------------------------------------------------------------------------
;;; Virtual memory and memory management
;;; ----------------------------------------------------------------------------
		.include "kickstart_mem.a65"

;;; ----------------------------------------------------------------------------
;;; Task (process) management
;;; ----------------------------------------------------------------------------
		.include "kickstart_task.a65"

;;; ----------------------------------------------------------------------------
;;; sdcard and fat32 related functions
;;; ----------------------------------------------------------------------------
		.include "kickstart_sdfat.a65"

;;; ----------------------------------------------------------------------------
;;; Virtualised F011 access (used for disk over serial monitor)
;;; ----------------------------------------------------------------------------
		.include "kickstart_virtual_f011.a65"

;;; ----------------------------------------------------------------------------
;;; CPU Hypervisor Entry Point on reset
;;; ----------------------------------------------------------------------------

reset_machine_state:
		; get CPU state sensible
		sei
		cld
		see

		; disable IRQ/NMI sources
		lda #$7f
		sta $DC0D
		sta $DD0D
		LDA #$00
		STA $D019

		sec
		; determine VIC mode and set it accordingly in VICIV_MAGIC
		jsr enhanced_io

		; clear UART interrupt status
		lda $d60d

		; switch to fast mode
		; 1. C65 fast-mode enable
		lda $d031
		ora #$40
		sta $d031
		; 2. MEGA65 48MHz enable (requires C65 or C128 fast mode to truly enable, hence the above)
		lda #$40
		tsb $d054

		; sprites off
		lda #$00
		sta $d015

		; disable CIA interrupts		
		lda #$7f
		sta $DC0D
		sta $DD0D

		; disable video interrupts
		lda #$00
		sta $D01A

		; enable audio amplifier
		lda #$01
		sta $d6f9

		; We DO NOT need to mess with $01, because
		; the 4510 starts up with kickstart mapped at $8000-$BFFF 
		; enhanced ($FFD3xxx) IO page mapped at $D000,
		; and fast RAM elsewhere.

		; Disable reset watchdog (this happens simply by writing anything to
		; this register)
		; Enable /EXROM and /GAME from cartridge port (bit 0)
		; enable flat 32-bit addressing (bit 1)
		; do not engage ROM write protect (yet) (bit 2)
		; do make ASC/DIN / CAPS LOCK control CPU speed (bit 3)
		; do not force CPU to full speed (bit 4)
		; also force 4502 CPU personality (6502 personality is still incomplete) (bit 5)
		; and clear any pending IRQ or NMI event (bit 6)
		;
		; (The watchdog was added to catch reset problems where the machine
		; would run off somewhere odd instead of resetting properly. Now it
		; will auto-reset after 65535 cycles if the watchdog is not cleared).
		;
		
		lda #$6b    ; 01101011
		sta hypervisor_feature_enables

		; Map SD card sector buffer
		lda #$80
		sta $d689

		; Access cartridge IO area to force EXROM probe on R1 PCBs
		lda $de00

		jsr resetdisplay
		jsr erasescreen
		jsr resetpalette

;note that this first message does not get displayed correctly
		jsr checkpoint
		.byte 0,"reset_machine_state",0
;but this second message does
		jsr checkpoint
		.byte 0,"reset_machine_state",0

		rts

;;; ----------------------------------------------------------------------------
;;; CPU Hypervisor reset/trap routines
;;; ----------------------------------------------------------------------------
;
reset_entry:
		sei

.macro f011test
		; use real floppy drive
		lda #$01
		sta $d6a1

		; 10x MFM speed for simulation data
		lda #$0a
		sta $d6a2

		lda #$68 ; floppy motor + LED on, head side 1
		sta $d080

		; Request sector T39,S1,H1
		lda #0
		sta $d084
		lda #1
		sta $d085
		sta $d086

		lda $d087 ; clear DRQ flag
		; reset buffer pointers
		lda #$01
		sta $d081

		; Test sector buffer access
		lda #$11
		sta $d087
		lda #$22
		sta $d087
		lda #$01
		sta $d081
		lda $d087
		lda $d087

		; Issue read request
		lda #$40
		sta $d081

bytewait:
		lda $d082
		and #$20
		bne bytewait

		; read next byte
		lda $d087

		; get next byte
		jmp bytewait
.macend
;		.invoke f011test

		jsr reset_machine_state

		; display welcome screen
		;
		ldx #<msg_kickstart
		ldy #>msg_kickstart
		jsr printmessage

		; leave a blank line below kickstart banner
		;
		ldx #<msg_blankline
		ldy #>msg_blankline
		jsr printmessage

		; Display GIT commit
		;
		ldx #<msg_gitcommit
		ldy #>msg_gitcommit
		jsr printmessage

		; Display help text
		;
		ldx #<msg_kickstarthelp
		ldy #>msg_kickstarthelp
		jsr printmessage

		; check keyboard for 0-9 down to select alternate rom
		;
		jsr keyboardread

		; Magic instruction used by monitor_load to work out where
		; to patch. Monitor_load changes bit to JMP when patching for
		; SD-cardless operation
		bit go64
		bit $1234

;	========================

normalboot:

	; check for keyboard input to jump to utility menu
	jsr scankeyboard
	bcs nokey1
	cmp #$20
	beq utility_menu

nokey1:

	jsr dump_disk_count	; debugging to Checkpoint
	jsr dumpcurrentfd	; debugging to Checkpoint

		; Try to read the MBR from the SD card to ensure SD card is happy
		;
		ldx #<msg_tryingsdcard
		ldy #>msg_tryingsdcard
		jsr printmessage

tryreadmbr:
		jsr readmbr
		bcs gotmbr

	; check for keyboard input to jump to utility menu
	jsr scankeyboard
	bcs nokey2
	cmp #$20
	beq utility_menu
nokey2:

		; Oops, cant read MBR
		; display debug message to screen
		;
		ldx #<msg_retryreadmbr
		ldy #>msg_retryreadmbr
		jsr printmessage

		; put sd card sector buffer back after scanning
		; keyboard
		lda #$81
		tsb $d680

		; display debug message to uart
		;
		jsr checkpoint
		.byte 0,"re-try reading MBR of sdcard",0

		jmp tryreadmbr

;	========================
		
gotmbr:
		; good, was able to read the MBR

		; Scan SD card for partitions and mount them.
		;
		jsr dos_clearall
		jsr dos_read_partitiontable

		; then print out some useful information
		;
		ldx #<msg_diskcount
		ldy #>msg_diskcount
		jsr printmessage
		;
		ldy #$00
		ldz dos_disk_count
		jsr printhex
		;
		ldy #$00
		ldz dos_default_disk
		jsr printhex

	jsr dump_disk_count	; debugging to Checkpoint
	jsr dumpcurrentfd	; debugging to Checkpoint
;	jsr print_disk_table	; debugging to Screen

;	========================

		; If we have no disks, offer the utility menu
		lda dos_disk_count
		beq utility_menu


		; Go to root directory on default disk
		;
		ldx dos_default_disk
		jsr dos_cdroot
		bcs mountsystemdiskok

		; failed
		;
		ldx #<msg_cdrootfailed
		ldy #>msg_cdrootfailed
		jsr printmessage
		ldy #$00
		ldz dos_error_code
		jsr printhex

		jsr checkpoint
		.byte 0,"FAILED CDROOT",0
		;
		; BG: should probably JMP to reset or something, and not fall through

		
mountsystemdiskok:

		; Load and display boot logo
		; Prepare 32-bit pointer for loading boot logo @ $0003D00
		; (palette is $3D00-$3FFF, logo $4000-$8FFF)
		lda #$3d
		sta <dos_file_loadaddress+1
		lda #$00
		sta <dos_file_loadaddress+0
		; lda #$00
		sta <dos_file_loadaddress+2
		; lda #$00
		sta <dos_file_loadaddress+3

		ldx #<txt_BOOTLOGOM65
		ldy #>txt_BOOTLOGOM65
		jsr dos_setname

		; print debug message
		;
		jsr checkpoint
		.byte 0,"  try-loading BOOTLOGO",0
	
		jsr dos_readfileintomemory
		bcs logook
		
;	========================

		; FAILED: print debug message
		;
		jsr checkpoint
		.byte 0,"  FAILED-loading BOOTLOGO",0

		; print debug message
		;
		ldx #<msg_nologo
		ldy #>msg_nologo
		jsr printmessage
		ldy #$00
		ldz dos_error_code
		jsr printhex

		jsr checkpoint
		.byte 0,"FAILED loading BOOTLOGO",0

;	========================

logook:
		; Loaded banner, so copy palette into place
		jsr setbannerpalette

		; iterate through directory entries looking for ordinary file 
		; KICKUP.M65 to load into hypervisor memory ...
		; ... but only if we are not running a kick-up'd kickstart now.
		;
		lda hypervisor_kickedup_flag	;$d67e = register for kickup-state (00=virgin, else already-kicked)
		bpl allowkickup

		; already kicked
		;
		ldx #<msg_alreadykicked
		ldy #>msg_alreadykicked
		jsr printmessage

		jmp postkickup

;	========================

allowkickup:	; BG was label nextdirectoryentry3:

		; Prepare 32-bit pointer for loading kickup @ $0004000
		;
		; BG: and why load at $4000 again?
		;
		lda #$00
		sta <dos_file_loadaddress+0
		lda #$40
		sta <dos_file_loadaddress+1
		lda #$00
		sta <dos_file_loadaddress+2
		lda #$00
		sta <dos_file_loadaddress+3

		ldx #<txt_KICKUPM65
		ldy #>txt_KICKUPM65
		jsr dos_setname

		; print debug message
		;
		jsr checkpoint
		.byte 0,"  try-loading KICKUP",0

		jsr dos_readfileintomemory
		bcc nokickup

;	========================

		; We have loaded a kickup file, so jump into it.


		; print debug message
		;
		jsr checkpoint
		.byte 0,"  loaded OK KICKUP",0


		ldx #<msg_kickuploaded
		ldy #>msg_kickuploaded
		jsr printmessage

		ldy #$00
		ldz <zptempv32+3	; BG what is in this register? Where is the data set?
		jsr printhex
		ldz <zptempv32+2
		jsr printhex
		ldz <zptempv32+1
		jsr printhex
		ldz <zptempv32+0
		jsr printhex

dokickup:
		; Use DMAgic to copy $0004000-$0007FFF to $FFF8000-$FFFBFFF
		; (We have to copy the routine to do this to RAM, since we will
		; be replacing ourselves)
		ldx #$00
krc:		lda kickuproutine,x
		sta $3000,x
		inx
		bne krc
		jmp $3000

;	========================

kickuproutine:
		; The following routine gets copied as-is to $3000 and run from there.
		; The DMA list is still available in the kickstart ROM when it gets
		; called, so we can just use it there, instead of working out where
		; it gets copied to

		; NOTE that only 256-bytes are copied, so the kickuproutine and kickupdmalist
		;      cannot exceed this limit, else revise the krc routine.

		; Set bottom 22 bits of DMA list address as for C65
		; (8MB address range).  Kickstart ROM is at $FFF8000, so $FF goes
		; in high-byte area
		;
		lda #$ff
		sta $d702
		lda #$ff   
		sta $d704  ; dma list is in top MB of address space
		sta $d706  ; similarly destination of copy is top MB of address space
		lda #$00
		sta $d705  ; source of copy is bottom MB of address space
		lda #>kickupdmalist
		sta $d701
		lda #<kickupdmalist
		sta $d700
		; clear source/destination MB so that C65 ROM doesn't go bananas
		lda #$00
		sta $d706

		; copy complete, so mark ourselves upgraded, and jump into hypervisor
		; as though we were just reset.

		; BG: here we should store non-zero, not ZERO ?
		;
		sta hypervisor_kickedup_flag	; mark ourselves as having kicked up, (00=virgin, else already-kicked)
		jmp $8100

;	========================

kickupdmalist:
		; copy $0004000-$0007FFF to $FFF8000-$FFFBFFF
		; (MB offsets get set in routine)
		.byte $00 ; copy + last request in chain
		.word $4000 ; size of copy is 16KB
		.word $4000 ; starting at $4000
		.byte $00   ; of bank $0
		.word $8000 ; destination address is $8000
		.byte $0F   ; of bank $F
		.word $0000 ; modulo (unused)

;	========================

couldntopenkickup:

nokickup:
		ldx #<msg_nokickup
		ldy #>msg_nokickup
		jsr printmessage

postkickup:

		; MILESTONE: Have file system properties.

		; Look for MEGA65.D81 to mount for F011 emulation

		; print debug message
		;
		jsr checkpoint
		.byte 0,"  Here we are POST-KICKUP",0

	jsr dumpcurrentfd	; debugging to Checkpoint
		
		; for now indicate that there is no disk in drive
		;
		lda #$00
		sta $d68b	; f011 emulation, BG: should have an alias

		; Go to root directory on default disk
		;
		ldx dos_default_disk
		jsr dos_cdroot
		bcc sdcarderror

		; Select PAL/NTSC mode based on presence of file called NTSC
		ldx #<txt_NTSC
		ldy #>txt_NTSC
		jsr dos_setname
		jsr dos_findfile
		bcc setpal
setntsc:
		lda #$80
		tsb $d06f
		jmp setpalntsc
setpal:
		lda #$80
		trb $d06f		

setpalntsc:
		; Re-set virtual screen row length after touching $D06F
		lda #80
		sta $d058

		; set name of file we are looking for
		;
		ldx #<txt_MEGA65D81
		ldy #>txt_MEGA65D81
		jsr dos_setname

		; print debug message
		;
		jsr checkpoint
		.byte 0,"  try-mounting MEGA65.D81",0

		jsr dos_findfile
		bcc d81attachfail
		jsr dos_closefile

		jsr dos_d81attach
		bcc d81attachfail
		
		ldx #<msg_d81mounted
		ldy #>msg_d81mounted
		jsr printmessage

		; print debug message
		;
		jsr checkpoint
		.byte 0,"  mounted MEGA65.D81",0

		; all done, move on to loading the ROM
		;

		jmp findrom

;	========================

d81attachfail:
		; we couldn't find the D81 file, so tell the user
		;
		ldx #<msg_nod81
		ldy #>msg_nod81
		jsr printmessage
		ldy #$00
		ldz dos_error_code
		jsr printhex

	; debug
	jsr checkpoint
	.byte 0," couldnt mount/attach MEGA65.D81",0

findrom:
		; Check state of current ROM
		;
		jsr checkromok
		bcc loadrom

		; ROM is loaded and ready, so transfer control to it.
		;
		ldx #<msg_romok
		ldy #>msg_romok
		jsr printmessage

		jsr checkpoint
		.byte 0,"JUMPing into ROM-code",0

	; check for keyboard input to jump to utility menu
	jsr scankeyboard
	bcs nokey3
	cmp #$20
	beq utility_menu
nokey3:


		jmp go64

;	========================

loadrom:

	jsr dumpcurrentfd	; debugging to Checkpoint

		; ROMs are not loaded, so try to load them, or prompt
		; for user to insert SD card
		;
		ldx #<msg_rombad
		ldy #>msg_rombad
		jsr printmessage

		; print debug message
		;
		jsr checkpoint
		.byte 0,"  try-loading CHAR-ROM",0

		; Load CHARROM.M65 into character ROM
		;
		ldx #<txt_CHARROMM65
		ldy #>txt_CHARROMM65
		jsr dos_setname
		
		; Prepare 32-bit pointer for loading whole ROM ($FF7E000)
		;
		lda #$00
		sta <dos_file_loadaddress+0
		lda #$E0
		sta <dos_file_loadaddress+1
		lda #$F7
		sta <dos_file_loadaddress+2
		lda #$0F
		sta <dos_file_loadaddress+3

		jsr dos_readfileintomemory
		bcs loadedcharromok

;	========================

		; FAILED
		ldx #<msg_charrombad
		ldy #>msg_charrombad
		jsr printmessage

		; print debug message
		;
		jsr checkpoint
		.byte 0," couldnt load CHARROM.M65",0

		jmp loadc65rom

;	========================

loadedcharromok:
		; print debug message
		;
		jsr checkpoint
		.byte 0,"  OK-loading CHARROM",0

		; prepare debug message
		;
		ldx dos_current_file_descriptor_offset
		lda dos_file_descriptors + dos_filedescriptor_offset_fileoffset+0,x
		sta file_pagesread
		lda dos_file_descriptors + dos_filedescriptor_offset_fileoffset+1,x
		sta file_pagesread+1

		ldx #<msg_charromloaded
		ldy #>msg_charromloaded
		jsr printmessage
		ldy #$00
		ldz file_pagesread+1
		jsr printhex
		ldz file_pagesread
		jsr printhex

loadc65rom:

	jsr dumpcurrentfd	; debugging to Checkpoint

		; print debug message
		;
		jsr checkpoint
		.byte 0,"  try-loading MEGA65-ROM",0

		ldx #<txt_MEGA65ROM
		ldy #>txt_MEGA65ROM
		jsr dos_setname

		; Prepare 32-bit pointer for loading whole ROM ($0020000)
		;
		lda #$00
		sta <dos_file_loadaddress+0
		sta <dos_file_loadaddress+1
		sta <dos_file_loadaddress+3
		lda #$02
		sta <dos_file_loadaddress+2

		jsr dos_readfileintomemory
		bcs loadedok

;	========================

		; ROM not found: indicate which ROM we were looking for
		;
		ldx #$0b
l17d:		lda txt_MEGA65ROM,x
		sta msg_romnotfound+19,x
		dex
		bne l17d
		ldx #<msg_romnotfound
		ldy #>msg_romnotfound
		jsr printmessage

		jsr sdwaitawhile
		jsr sdwaitawhile
		jsr sdwaitawhile
		jsr sdwaitawhile

		jmp sdcarderror

;	========================

		; ROM was found and loaded
loadedok:
		ldx dos_current_file_descriptor_offset
		lda dos_file_descriptors + dos_filedescriptor_offset_fileoffset +0,x
		sta file_pagesread
		lda dos_file_descriptors + dos_filedescriptor_offset_fileoffset +1,x
		sta file_pagesread+1

		; check the size of the loaded file
		; i.e., that we have loaded $0200 x $100 = $20000 = 128KiB
		lda file_pagesread
		bne romfiletooshort
		lda file_pagesread+1
		cmp #$00
		beq romfiletooshort
		cmp #$02
		bne romfiletoolong

		; the loaded ROM was OK in size

		; Store checksum of ROM
		;
		jsr storeromsum

		; copy character ROM portion into place
		; i.e., copy $2Dxxx to $FF7Exxx

		lda #$ff
		sta $d702
		sta $d704
		sta $d706
		lda #$00
		sta $d705
		lda #>charromdmalist
		sta $d701
		lda #<charromdmalist
		sta $d700

		jmp loadedmegaromok

charromdmalist:
		.byte $00
		.word $1000
		.word $D000
		.byte $02
		.word $E000
		.byte $07
		.word $0000
		

loadedmegaromok:
		; print debug message
		;
		jsr checkpoint
		.byte 0,"  OK-loading CHARROM",0

		; prepare debug message
		;
		ldx dos_current_file_descriptor_offset
		lda dos_file_descriptors + dos_filedescriptor_offset_fileoffset+0,x
		sta file_pagesread
		lda dos_file_descriptors + dos_filedescriptor_offset_fileoffset+1,x
		sta file_pagesread+1

		ldx #<msg_megaromloaded
		ldy #>msg_megaromloaded
		jsr printmessage
		ldy #$00
		ldz file_pagesread+1
		jsr printhex
		ldz file_pagesread
		jsr printhex
		
		; ROM file loaded, transfer control
		;
		ldx #<msg_romok
		ldy #>msg_romok
		jsr printmessage

		; print debug message
		;
		jsr checkpoint
		.byte 0,"  OK-loading MEGA65-ROM",0

		; print debug message
		;
		jsr checkpoint
		.byte 0,"JUMPing into ROM-code",0

	jsr dumpcurrentfd	; debugging to Checkpoint

loaddiskmenu:

                ; print debug message
                ;
                jsr checkpoint
                .byte 0,"  try-loading $C000 Utility",0

                ldx #<txt_C000UTIL
                ldy #>txt_C000UTIL
                jsr dos_setname

                ; Prepare 32-bit pointer for loading whole ROM ($0020000)
                ;
                lda #$00
                sta <dos_file_loadaddress+0
                sta <dos_file_loadaddress+2
                sta <dos_file_loadaddress+3
                lda #$c0
                sta <dos_file_loadaddress+1

                jsr dos_readfileintomemory
;                bcs loadedok

	jsr dumpcurrentfd	; debugging to Checkpoint

	; check for keyboard input to jump to utility menu
	jsr scankeyboard
	bcs nokey4
	cmp #$20
	beq utility_menu
nokey4:

		jmp go64		

;	========================

romfiletoolong:
		ldx #<msg_romfilelongerror
		ldy #>msg_romfilelongerror
		jsr printmessage
		ldz file_pagesread+1
		jsr printhex
		ldz file_pagesread
		jsr printhex
		jsr sdwaitawhile
		jmp reset_entry

romfiletooshort:
		ldx #<msg_romfileshorterror
		ldy #>msg_romfileshorterror
		jsr printmessage
		ldz file_pagesread+1
		jsr printhex
		ldz file_pagesread
		jsr printhex
		jsr sdwaitawhile
		jmp reset_entry

;	========================

fileopenerror:
		ldx #<msg_fileopenerror
		ldy #>msg_fileopenerror
		jsr printmessage

sdcarderror:	ldx #<msg_sdcarderror
		ldy #>msg_sdcarderror
		jsr printmessage

		jsr sdwaitawhile
		jmp reset_entry

;	========================

badfs:		ldx #<msg_badformat
		ldy #>msg_badformat
		jsr printmessage

		jsr sdwaitawhile
		jmp reset_entry

;;; ----------------------------------------------------------------------------
;;; ROM loading and manipulation routines
;;; ----------------------------------------------------------------------------

checkromok:
		; read switch 13.  If set, assume ROM is invalid
		;
		lda fpga_switches_high
		and #$20
		bne checksumfails

		; or if loading a ROM other than MEGA65.ROM, then assume ROM
		; is invalid
		;
		lda txt_MEGA65ROM+6
		cmp #'.
		bne checksumfails
	
		; calculate checksum of loaded ROM ...
		;
		jsr calcromsum
		; ... then fall through to testing it
testromsum:
		; have checksum for all slabs.

		jsr mapromchecksumrecord

		lda $4000
		cmp checksum
		bne checksumfails
		lda $4001
		cmp checksum+1
		bne checksumfails
		lda $4002
		cmp checksum+2
		bne checksumfails

		jsr resetmemmap

		sec
		rts

;	========================

		; check failed
checksumfails:	clc
		rts

;	========================

storeromsum:
		jsr mapromchecksumrecord

		lda checksum
		sta $4000
		lda checksum+1
		sta $4001
		lda checksum+2
		sta $4002
		rts

;	========================

mapromchecksumrecord:

		; Map in ROM load record, and compare checksum
		; Here we have to use our extension to MAP to access >1MB
		; as only 128KB of slow ram is shadowed to $20000.
		;
		; Again, we have to take the relative nature of MAP, so
		; we ask for $FC000 to be mapped at $0000, which means that
		; $4000 will correspond to $0000 (MAP instruction address
		; space wraps around at the 1MB mark)
		
		; select 128MB mark for mapping lower 32KB of address space
		;
		lda #$80
		ldx #$0f
		ldy #$00   ; keep kickstart mapped at $8000-$BFFF
		ldz #$3f

		map

		; then map $FC000 + $4000 = $00000 at $4000-$7FFF
		;
		lda #$c0
		ldx #$cf
		ldy #$00   ; keep kickstart mapped at $8000-$BFFF
		ldz #$3f
		map
		eom
		
		rts

;	========================

calcromsum:	; calculate checksum of 128KB ROM
		
		; use MAP to map C65 ROM address space in 16KB
		; slabs at $4000-$7FFF.  Check sum each, and
		; then compare checksum to ROM load record.
		;
		; ROMs get loaded into slow RAM at $8020000-$803FFFF,
		; which is shadowed for reading using C65 MAP instruction to
		; C65 address space $20000-$3FFFF.
		;
		; Checksum and ROM load record are stored in
		; $8000000 - $800FFFF, i.e., the first 64KB of
		; slow RAM.
		;
		; The 4510 MAP instruction does not normally provide access to the
		; full 28-bit address space, so we need to use a trick.
		;
		; We do this by interpretting a MAP instruction that says to
		; map none of the 8KB pages, but provides an offset in the range
		; $F0000 - $FFF00 to set the "super page" register for that 32KB
		; moby to bits 8 to 15 of the offset.  In practice, this means
		; to allow mapping of memory above 1MB, the MB of memory being
		; selected is chosen by the contents of A and Y registers when 
		; X and Z = $0F.
		; 
				
		; reset checksum
		; checksum is not all zeroes, so that if RAM initialises with
		; all zeroes, including in the checksum field, the checksum will
		; not pass.
		;
		lda #$03
		sta checksum
		sta checksum+1
		sta checksum+2
		sta checksum+3

		; start with bottom 16KB of ROM
		; we count in 16KB slabs, and ROM starts at 128KB mark,
		; so we want to check from the 8th to 15th slabs inclusive.
		;
		lda #$08
		sta romslab

		; Summing can be done using normal use of MAP instruction,
		; since slow RAM is shadowed as ROM to $20000-$3FFFF

sumslab:
		; romcheckslab indicates which 16KB piece.
		; MAP uses 256-byte granularity, so we need to shift left
		; 6 bits into A, and right 2 bits into X.
		; We then set the upper two bits in X to indicate that the mapping
		; applies to blocks 2 and 3.
		; BUT MAP is relative, and since we are mapping at the 16KB mark,
		; we need to subtract 1 lot of 16KB from the result.
		; this is easy -- we just sbc #$01 from romslab before using it.
		;
		lda romslab
		sec 
		sbc #$01
		lsr
		lsr
		ora #$c0
		tax
		lda romslab
		sec
		sbc #$01
		asl
		asl
		asl
		asl
		asl
		asl
		ldy #$00   ; keep kickstart mapped at $8000-$BFFF
		ldz #$3f

		map
		eom
		
		; sum contents of 16KB slab
		;
		lda #$00
		sta <zptempv
		lda #$40
		sta <zptempv+1
		
sumpage:	ldy #$00
sumbyte:	lda checksum
		clc
		adc (<zptempv),y
		sta checksum
		bcc l6
		inc checksum+1
		bcc l6
		inc checksum+2
l6:		iny
		bne sumbyte
		inc <zptempv+1
		lda <zptempv+1
		cmp #$80
		bne sumpage
		
		inc romslab
		lda romslab
		cmp #$10
		bne sumslab

		jmp resetmemmap

;;; ----------------------------------------------------------------------------
;;; Display and basic IO routines
;;; ----------------------------------------------------------------------------

resetdisplay:
		; reset screen
		;
		lda #$40	; 0100 0000 = choose charset
		sta $d030	; VIC-III Control Register A

		lda $d031	; VIC-III Control Register B
		and #$40	; bit-6 is 4mhz
		sta $d031

		lda #$00	; black
		sta $D020	; border
		sta $D021	; background

		; Enable alpha blending and horizontal blending to smooth display
		; slightly
		lda #$28  ; XXX alpha blending has problems still
		sta $D054	;VIC-IV Control Register C

		; We use VIC-II style registers as this resets video frame in
		; least instructions, and 40 columns is fine for us.
		;
		lda #$14	; 0001 0100
		sta $D018	; VIC-II Character/Screen location

		lda #$1B	; 0001 1011
		sta $D011	; VIC-II Control Register

		lda #$C8	; 1100 1000
		sta $D016	; VIC-II Control Register

		; point VIC-IV to bottom 16KB of display memory
		;
		lda #$ff
		sta $DD01
		sta $DD00

		; Now switch to 16-bit text mode so that we can use proportional
		; characters and full-colour characters for chars >$FF for the logo
		;
		lda #$05	; 0000 0101
		tsb $d054	; VIC-IV Control Register C

		; and 80 bytes (40 16-bit characters) per row.
		;
		lda #<80
		sta $d058
		lda #>80
		sta $d059
		
		rts

;	========================

resetpalette:
		; reset VIC-IV palette to sensible defaults.
		; load C64 colours into palette bank 3 for use when
		; PAL bit in $D030 is set.
		;
		lda #$04
		tsb $D030	; enable PAL bit in $D030

		lda #$ff
		sta $D070	; select palette bank 3 for display and edit

		; C64 colours designed to look like C65 colours on an
		; RGBI screen.
		;
		; formatted in ASM to help visualise what each code is for.
		;
                lda #$00
	                sta $D100
			sta $D200
			sta $D300

		lda #$ff
			sta $D101
			sta $D201
			sta $D301

		lda #$ba
	                sta $D102
                lda #$13
	                sta $D202
                lda #$62
	                sta $D302

                lda #$66
	                sta $D103
                lda #$ad
	                sta $D203
                lda #$ff
	                sta $D303

                lda #$bb
	                sta $D104
                lda #$f3
	                sta $D204
                lda #$8b
	                sta $D304

                lda #$55
	                sta $D105
                lda #$ec
	                sta $D205
                lda #$85
	                sta $D305

                lda #$d1
	                sta $D106
                lda #$e0
	                sta $D206
                lda #$79
	                sta $D306

                lda #$ae
	                sta $D107
                lda #$5f
	                sta $D207
                lda #$c7
	                sta $D307

                lda #$9b
	                sta $D108
                lda #$47
	                sta $D208
                lda #$81
	                sta $D308

                lda #$87
	                sta $D109
                lda #$37
	                sta $D209
                lda #$00
	                sta $D309

                lda #$dd
	                sta $D10a
                lda #$39
	                sta $D20a
                lda #$78
	                sta $D30a

                lda #$b5
	                sta $D10b
	                sta $D20b
	                sta $D30b

                lda #$b8
	                sta $D10c
	                sta $D20c
	                sta $D30c

                lda #$0b
	                sta $D10d
                lda #$4f
	                sta $D20d
                lda #$ca
	                sta $D30d

                lda #$aa
	                sta $D10e
                lda #$d9
	                sta $D20e
                lda #$fe
	                sta $D30e

                lda #$8b
	                sta $D10f
	                sta $D20f
	                sta $D30f


	rts

;	========================

; erase standard 40-column screen
;
erasescreen:
		; bank in 2nd KB of colour RAM
		;
		lda #$01
		tsb $D030

		; use DMA to clear screen and colour RAM
		; The screen is in 16-bit bit mode, so we actually need to fill
		; with $20,$00, ...
		;
		; We will cheat by setting the first four bytes, and then copying from
		; there, and it will then read from the freshly written bytes.
		; (two bytes might not be enough to allow the write from the last DMA
		;  action to be avaialble for reading because of how the DMAgic is
		;  pipelined).
		;
		lda #$20
		sta $0400
		sta $0402
		lda #$00
		sta $0401
		sta $0403
		
		; Set bottom 22 bits of DMA list address as for C65
		; (8MB address range)
		;
		lda #$ff
		sta $d702

		; Kickstart ROM is at $FFFE000 - $FFFFFFF, so
		; we need to tell DMAgic that DMA list is in $FFxxxxx.
		; this has to be done AFTER writing to $d702, as $d702
		; clears bits 27 - 22 of the DMA list address to help with
		; compatibility.
		;
		lda #$ff
		sta $d704

		; copy from MB $00 for screen clearing
		;
		lda #$00
		sta $d705

		; destination MB is $00, since we are writing to C64 RAM space.
		;
		lda #$00
		sta $d706

		lda #>erasescreendmalist
		sta $d701

		; set bottom 8 bits of address and trigger DMA.
		;
		lda #<erasescreendmalist
		sta $d700

		; clear source/destination MB so that C65 ROM doesn't go bananas
		;
		lda #$00
		sta $d705

		; bank 2nd KB of colour RAM back out
		;
		lda #$01
		trb $D030

;	========================

		; move cursor back to top of the screen
		; (but leave 8 rows for logo and banner text)
		;
		lda #$08
		sta screenrow

		; draw 40x8 char block for banner
		;
		ldy #$00
		lda #$00
logo1:		sta $0400,y
		inc
		iny
		iny
		bne logo1		
logo1a:		sta $0500,y
		inc
		iny
		iny
		bne logo1a
logo1b:		sta $0600,y
		inc
		iny
		iny
		cpy #$80
		bne logo1b

		; then write the high bytes for these (all $01, so char range will be
		; $100-$140. $100 x $40 = $4000-$4FFF
		;
		ldx #$00
		lda #$01		
logo2:		sta $0401,x
		inc
		sta $0581,x
		dec
		sta $0501,x
		inx
		inx		
		bne logo2

		; finally set palette for banner using contents of memory at $3D00-$3FFF
setbannerpalette:
		ldx #$10
lo1:		lda $3d00,x
		sta $D100,x
		lda $3e00,x
		sta $d200,x
		lda $3f00,x
		sta $d300,x
		inx
		bne lo1
		; put nothing else here, as setbannerpalette also gets called after loading banner file
		rts


;	========================

erasescreendmalist:
		; Clear screen RAM
		;
		.byte $04   ; COPY + chained request
		.word 1996  ; 40x25x2-4 = 1996
		.word $0400 ; copy from start of screen at $0400
		.byte $00   ; source bank 00
		.word $0404 ; ... to screen at $0402
		.byte $00   ; screen is in bank $00
		.word $0000 ; modulo (unused)

		; Clear colour RAM
		;
		.byte $07     ; FILL + chained request
		.word 2000    ; 40x25x2 = 2000
		.byte $01     ; fill with white = $01
		.byte $00,$00 ; rest of source address is ignored in fill
		.word $d800   ; screen is at $0400
		.byte $80     ; screen is in IO, so bank IO in to DMA context
		.word $0000   ; modulo (unused)

		; Copy shadow RAM logo to chip RAM
		; XXX - We can get rid of this by preinitialising CHIPRAM as well as shadow RAM
		;
		.byte $00   ; COPY + end of chain
		.word $6000 ; 320x64 = $6000
		.word $4000 ; fill with white = $01
		.byte $00   ; rest of source address is ignored in fill
		.word $4000 ; screen is at $0400
		.byte $00   ; screen is in IO, so bank IO in to DMA context
		.word $0000 ; modulo (unused)

;	========================

printmessage:	;HELPER routine
		;
		; This subroutine takes inputs from the X and Y registers,
		; so set these registers before calling this subroutine,
		; The X and Y registers need to point to a message as shown below:
		;
		;	ldx #<msg_foundsdcard
		;	ldy #>msg_foundsdcard
		;	jsr printmessage
		;
		; Ie: the X is the high-byte of the 16-bit address, and
		;     the Y is the low-byte  of the 16-bit address.

		stx <zptempp	;zptempp is 16-bit pointer to message
		sty <zptempp+1

		lda #$00
		sta <zptempp2	;zptempp2 is 16-bit pointer to screen
		lda #$04
		sta <zptempp2+1

		ldx screenrow

		; Makesure we can't accidentally write on row zero
		bne pm22
		ldx #$08
pm22:

		; if we have reached the bottom of the screen, start writing again
		; from the top of the screen (but don't touch the top 8 rows for
		; logo and banner)
		cpx #25
		bne pm2
		ldx #$08
		stx screenrow

		; work out the screen address
		;
pm2:		cpx #$00
		beq pm1
		clc
		lda <zptempp2
		adc #$50          ; 40 columns x 16 bit
		sta <zptempp2
		lda <zptempp2+1
		adc #$00
		sta <zptempp2+1

		; if reached bottom of screen, then loop back to top of screen
		;
		cmp #$0b
		bcc pm5
		lda <zptempp2
		cmp #$d0
		bcc pm5
	
		lda #$80
		sta <zptempp2
		lda #$06
		sta <zptempp2+1
pm5:		dex
		bne pm2
pm1:

		; Clear line (16-bit chars, so write #$0020 to each word
		;
		ldy #$00
pm1b:		lda #$20
		sta (<zptempp2),y
		iny
		lda #$00
		sta (<zptempp2),y		
		iny
		cpy #$50
		bne pm1b		

writestring:
		phz
		ldy #$00
		ldz #$00
pm3:		lda (<zptempp),y
		beq endofmessage

		; convert ASCII/PETSCII to screen codes
		;
		cmp #$40
		bcc pm4
		and #$1f

pm4:		; write 16-bit character code
		;
		sta (<zptempp2),z
		inz
		pha
		lda #$00
		sta (<zptempp2),z
		pla
		iny
		inz
		bne pm3
endofmessage:
		inc screenrow

		plz
		rts

;	========================

printbanner:
		stx <zptempp
		sty <zptempp+1
		lda #<$0504
		sta zptempp2
		lda #>$0504
		sta zptempp2+1
		jsr writestring
		dec screenrow
		rts

;	========================
		
printhex:
		; helper function
		;	
		; seems to want to print the value if the z-reg onto the previous line written to the screen,
		; so currently the screen consists of say "mounted $$ images"
		; and this routine will go and change the "$$" to the value in the z-reg
		;
		; BG: surely this can be replaced with updating the "$$" before printing the string
		;
		; INPUT: .Y, BG seems to be an offset, should be set to zero?
		; INPUT: .Z, value in Z-reg to be displayed omn the screen
		;
		tza
		lsr
		lsr
		lsr
		lsr
		jsr printhexdigit		
		tza
		and #$0f
printhexdigit:
		; find next $ sign to replace with hex digit
		;
		tax
phd3:		lda (<zptempp2),y
		cmp #$24
		beq phd2
		iny
		iny
		cpy #$50
		bne phd3
		rts

phd2:		txa
		ora #$30
		cmp #$3a
		bcc phd1
		sbc #$39
phd1:		sta (<zptempp2),y
		iny
		iny
		rts

;	========================

go64:

; Transfer control to C64 kernel.
; (This also allows entry to C65 mode, because the
;  C64-mode kernel on the C65 checks if C65 mode
;  should be entered.)

		; Check if hold boot switch is set (switch 15)?
		;
		lda fpga_switches_high
		bpl l42      ; no, so continue		

		; yes, display message
		;
		ldx #<msg_releasesw15
		ldy #>msg_releasesw15
		jsr printmessage

l41:		lda fpga_switches_high
		bmi l41
l42:

		; unmap sector buffer so C64 can see CIAs
		;
		lda #$82
		sta $D680

		; copy routine to stack to switch to
		; C64 memory map and enter via reset
		; vector.  
	
		; erase kickstart ROM copy from RAM
		; (well, at least enough so that BASIC doesn't get upset)
		; XXX - use DMA
		;
		ldx #$00
		txa
g61:		sta $0800,x
		inx
		bne g61		

		; reset video mode to normal (but with PAL + compositing enabled)
		; and return CPU to slow speed for exit
		lda #$28    ; XXX no compositing for now, as it still has problems
		sta $d054

		lda #<40
		sta $d058
		lda #>40
		sta $d059

		; write protect ROM RAM
		lda #$04
		tsb hypervisor_feature_enables

		jsr task_set_c64_memorymap
		jsr task_set_pc_to_reset_vector
		jsr task_dummy_nmi_vector

		; This must happen last, so that the ultimax cartridge
		; reset vector is used, instead of the one in the loaded ROM
		jsr setup_for_ultimax_cartridge

		; exit from hypervisor to start machine
		sta hypervisor_enterexit_trigger

		.include "kickstart_ultimax.a65"		

;	========================

; BG: the longpeek subroutine does not get called from kickstart,
;     it gets called only from the kickstart_task file,
;     so i suggest moving this subroutine to that file.

longpeek:
		; Use DMAgic to read any byte of RAM in 28bit address space.
		; Value gets read into $BC00 (kickstart_scratchbyte0)
		; ($FFFBC00 - $FFFBDFF)

		; Patch DMA list
		;
		sta $d705 ; DMAgic source MB
		lda #$ff
		sta $d706 ; DMAgic destination MB
		stx longpeekdmalist+3
		sty longpeekdmalist+4
		stz longpeekdmalist+5

		; Set DMA list address
		;
		lda #>longpeekdmalist
		sta $d701
		lda #$0f
		sta $d702 ; DMA list address is $xxFxxxx
		lda #$ff
		sta $d704 ; DMA list address is $FFxxxxx

		; set bottom bits of DMA list address and trigger DMA
		;
		lda #<longpeekdmalist
		sta $d700
		rts

longpeekdmalist:
		.byte $00 ; COPY, no chain
		; 1 byte
		.word $0001
		; source address
		.word $0000
		.byte $00
		; destination address ($xxFBC00)
		.word kickstart_scratchbyte0
		.byte $0F 
		.byte $00,00 ; Modulo

longpoke:
		; Use DMAgic to write any byte of RAM in C65 1MB address space.
		; XXX - Which version of DMAgic does this assume!!?? 
		; A = value
		; X = Address LSB
		; Y = Address MidB
		; Z = Address Bank

		; Patch DMA list
		;
		sta longpokevalue
		stx longpokeaddress+0
		sty longpokeaddress+1
		stz longpokeaddress+2
		lda #$00
		sta $d706 ; DMAgic destination MB
		; and disable F108B enhanced mode
		sta $d703

		; Set DMA list address
		;
		lda #>longpokedmalist
		sta $d701
		lda #$0f
		sta $d702 ; DMA list address is $xxFxxxx
		lda #$ff
		sta $d704 ; DMA list address is $FFxxxxx

		; set bottom bits of DMA list address and trigger DMA
		;
		lda #<longpokedmalist
		sta $d700
		rts

longpokedmalist:
		.byte $03 ; FILL, no chain
		; 1 byte
		.word $0001
		; source address (LSB = fill value)
longpokevalue:	.byte $00
		.word $0000
		; destination address
longpokeaddress:
		.word $0000
		.byte $0F 
		.byte $00,00 ; Modulo


;	========================
		
; reset memory map to default
resetmemmap:
		; clear memory MAP MB offset register
		;
		lda #$00
		ldx #$0f
		ldy #$00   ; keep kickstart mapped at $8000-$BFFF
		ldz #$3f

		map

		; and clear all mapping
		;
		tax
		ldy #$00   ; keep kickstart mapped at $8000-$BFFF
		ldz #$3f

		map
		eom

		rts

;	========================

enhanced_io:

		; If C=1, enable enhanced IO bank,
		;   else, return to C64 standard IO map.
		;

		bcs l1
		; Return to VIC-II / C64 IO
		;
		lda #$00
		sta VICIV_MAGIC
		rts

l1:		; Enable VIC-IV / MEGA65 IO
		;
		lda #$47
		sta VICIV_MAGIC
		lda #$53
		sta VICIV_MAGIC
		RTS


;	========================
		.include "kickstart_keyboard.a65"

keyboardread:

; Check for keyboard activity, and change which ROM we intend to read
; based on that, i.e., holding any key down during boot will load MEGA65<that character>.ROM instead of MEGA65.ROM

		jsr scankeyboard		
		bcs kr2  ; if an error occured
		cmp #$20
		beq utility_menu
		cmp #$30
		bcc kr2
		cmp #$39
		bcs kr2
kr2:		lda #$20 ; default to space
kr1:
		; put character into 6th byte position of ROM file name.
		; so no key looks for MEGA65.ROM, where as 0-9 will look
		; for MEGA65x.ROM, where x is the number.
		ldx #6
		cmp #$20
		beq default_rom
		sta txt_MEGA65ROM,x
		inx
default_rom:
		lda #'.
		sta txt_MEGA65ROM,x
		inx
		lda #'R
		sta txt_MEGA65ROM,x
		inx
		lda #'O
		sta txt_MEGA65ROM,x
		inx
		lda #'M
		sta txt_MEGA65ROM,x
		inx
		lda #0
		sta txt_MEGA65ROM,x    

		rts

;	========================

hypervisor_nmi:
hypervisor_irq:
		; Default interrupt handlers for hypervisor: for now just mask the
		; interrupt source.  Later we can have raster splits in the boot
		; display if we so choose.
		sei
		rti

hypervisor_setup_copy_region:
	; Hypervisor copy region sit entirely within the first 32KB of
	; mapped address space. Since we allow a 256 byte copy region,
	; we limit the start address to the range $0000-$7EFF
	; XXX - We should also return an error if there is an IO
	; region mapped there, so that the hypervisor can't be tricked
	; into doing privileged IO operations as part of the copy-back
	
	lda hypervisor_y
	bmi hscr1
	cmp #$7f
	beq hscr1
	sta hypervisor_userspace_copy_vector +1
	lda #$00
	sta hypervisor_userspace_copy_vector +0

	jsr checkpoint
	.byte 0,"hypervisor_setup_copy_region <success>",0

	sec
	rts

hscr1:
	jsr checkpoint
	.byte 0,"hypervisor_setup_copy_region <failure>",0

	lda #dos_errorcode_invalid_address
	jmp dos_return_error		

;	========================

checkpoint:

	; Routine to record the progress of code through the hypervisor for
	; debugging problems in the hypervisor.
	; If the JSR checkpoint is followed by $00, then a text string describing the
	; checkpoint is inserted into the checkpoint log.
	; Checkpoint data is recorded in the 2nd 16KB of colour RAM.

	; Save all registers and CPU flags
	sta checkpoint_a
	stx checkpoint_x
	sty checkpoint_y
	stz checkpoint_z
	php
	pla
	sta checkpoint_p

	; pull PC return address from stack
	; (JSR pushes return_address-1, so add one)
	pla
	clc
	adc #$01
	sta checkpoint_pcl
	pla
	adc #$00
	sta checkpoint_pch

	; Only do checkpoints visibly if switch 12 is set
	lda fpga_switches_high
	and #$10
	beq cp9

	; Write checkpoint byte values out as hex into message template
	ldx checkpoint_a
	jsr checkpoint_bytetohex
	sty msg_checkpoint_a+0
	stx msg_checkpoint_a+1

	ldx checkpoint_x
	jsr checkpoint_bytetohex
	sty msg_checkpoint_x+0
	stx msg_checkpoint_x+1

	ldx checkpoint_y
	jsr checkpoint_bytetohex
	sty msg_checkpoint_y+0
	stx msg_checkpoint_y+1

	ldx checkpoint_z
	jsr checkpoint_bytetohex
	sty msg_checkpoint_z+0
	stx msg_checkpoint_z+1

	ldx checkpoint_p
	jsr checkpoint_bytetohex
	sty msg_checkpoint_p+0
	stx msg_checkpoint_p+1

	ldx checkpoint_pch
	jsr checkpoint_bytetohex
	sty msg_checkpoint_pc+0
	stx msg_checkpoint_pc+1

	ldx checkpoint_pcl
	jsr checkpoint_bytetohex
	sty msg_checkpoint_pc+2
	stx msg_checkpoint_pc+3

	; Clear out checkpoint message
	ldx #59
	lda #$20
cp4:	sta msg_checkpointmsg,x
	dex
	bpl cp4
cp9:
	; Read next byte following the return address to see if it is $00,
	; if so, then also store the $00-terminated text message that follows.
	; e.g.:
	;
	; jsr checkpoint
	; .byte 0,"OPEN DIRECTORY",0
	;
	; to record a checkpoint with the string "OPEN DIRECTORY"

	ldy #$00
	lda (<checkpoint_pcl),y

	bne nocheckpointmessage

	; Copy null-terminated checkpoint string
	ldx #$00
	iny
cp3:	lda (<checkpoint_pcl),y
	beq endofcheckpointmessage
	sta msg_checkpointmsg,x
	inx
	iny
	cpy #60
	bne cp3

	; flush out any excess bytes at end of message
cp44:	lda (<checkpoint_pcl),y
	beq endofcheckpointmessage
	iny
	bra cp44
	

endofcheckpointmessage:
	; Skip $00 at end of message
	iny
	
nocheckpointmessage:

	; Advance return address following any checkpoint message
	tya
	clc	
	adc checkpoint_pcl
	sta checkpoint_pcl
	lda checkpoint_pch
	adc #$00
	sta checkpoint_pch

	; Only do checkpoints visibly if switch 12 is set
	lda fpga_switches_high
	and #$10
	beq checkpoint_return

	; output checkpoint message to serial monitor
	ldx #0
	; do not adjust x-reg until label "checkpoint_return"
cp5:

	; wait for uart to be not busy
	lda hypervisor_write_char_to_serial_monitor	; LSB is busy status
	bne cp5		; branch if busy (LSB=1)

	; uart is not busy, so write the char
	lda msg_checkpoint,x
	sta hypervisor_write_char_to_serial_monitor
	inx



	cmp #10		; compare A-reg with "LineFeed"
	bne cp5

checkpoint_return:
	; restore registers
	lda checkpoint_p
	php
	lda checkpoint_a
	ldx checkpoint_x
	ldy checkpoint_y
	ldz checkpoint_z
	plp

	; return by jumping to the 
	jmp (checkpoint_pcl)

;	========================

checkpoint_bytetohex:

	; BG: this is a helper function to convert a HEX-byte to
	;     its equivalent two-byte char representation
	;
	;     input ".X", containing a HEX-byte to convert
	;   outputs ".X" & ".Y", Y is MSB, X is LSB, print YX

	txa
	and #$f0
	lsr
	lsr
	lsr
	lsr
	jsr checkpoint_nybltohex
	tay
	txa
	and #$0f
	jsr checkpoint_nybltohex
	tax	
	rts

;	========================

checkpoint_nybltohex:

	and #$0f
	ora #$30
	cmp #$3a
	bcs cpnth1
	rts

cpnth1:	adc #$06
	rts

;	========================
;       Scan the 32KB colour RAM looking for pre-loaded utilities.
;       Offer for the user to be able to launch one of them

utility_menu:
	ldx #<msg_utilitymenu
	ldy #>msg_utilitymenu
	jsr printmessage

	; First utility will be number 1
	lda #$30
	sta zptempv
	
	jsr utillist_rewind
um1:
	jsr utillist_validity_check
	bcc utility_end_of_list

	; Display utility and assign number
	ldy #39
	lda #$20
um2:	sta msg_utility_item,y
	dey
	cpy #2
	bne um2
	iny
	inc zptempv
	lda zptempv	
	sta msg_utility_item
	ldz #4
um4:	nop
	lda (<zptempv32),z
	sta msg_utility_item,y
	beq um3
	iny
	inz
	bra um4
um3:

	ldx #<msg_utility_item
	ldy #>msg_utility_item
	jsr printmessage

	jsr utillist_next

	bra um1
	

utility_end_of_list:
	; XXX Get input from user (accept only numbers 1 - 9)
	jsr scankeyboard
	cmp #$ff
	beq utility_end_of_list
	cmp #$31
	bcc utility_end_of_list
	cmp #$39
	bcs utility_end_of_list

	; XXX Based on input, find that utility
	and #$f
	tax
	dex ; input is 1-9, so subtract one for list beginning at 0
	jsr utillist_rewind
ueol2:	jsr utillist_validity_check
	; Select again if first choice invalid
	bcc utility_end_of_list
	dex
	bmi ueol1
	jsr utillist_next
	bra ueol2
ueol1:	

	inc $d021

	; XXX - Set hardware protection bits based on utility definition
	;       (and check that utility memory has not been modified. If modified.
	;        give an error instead of giving privileges, so that there is no
	;        privilege escalation vulnerability here.)
	; XXX - In fact, if the utility memory has been modified, we shouldn't even
	;       offer the menu at all perhaps?

	; Load selected utility into memory
	; length @ offset 36
	ldz #36
	nop
	lda (<zptempv32),z
	sta utility_dmalist+1
	inz
	nop
	lda (<zptempv32),z
	sta utility_dmalist+2
	lda <zptempv32+0
	clc
	adc #44 ; length of header structure
	sta utility_dmalist+3
	lda <zptempv32+1
	adc #0
	sta utility_dmalist+4
		
	; load address is always $07FF (to skip $0801 header)
	; start @ zptempv32 + 44
	; DMA list is from Hypervisor ROM, so DMA list address MB also = $FF
	lda #$ff
	sta $d702
	sta $d704
	; (colour RAM is at $FF8xxxx, so need to set DMA source MB to $FF)
	; lda #$ff
	sta $d705 
	; DMA destination is normal RAM, so DMA destination MB = $00
	; lda #$00
	inc
	sta $d706
	lda #>utility_dmalist
	sta $d701
	lda #<utility_dmalist
	sta $d700  ; Trigger DAM

	; clear 16-bit char mode
	lda #$05	; 0000 0101
	trb $d054	; VIC-IV Control Register C

	; and 40 bytes (40 8-bit characters) per row.
	lda #<40
	sta $d058
	lda #>40
	sta $d059

	; screen at $0800 for debug
	lda #$25
	sta $d018


	; Exit hypervisor, with PC set to entry point of utility
	ldz #38
	nop
	lda (<zptempv32),z
	sta hypervisor_pcl
	inz
	nop
	lda (<zptempv32),z
	sta hypervisor_pch

	jsr task_set_c64_memorymap
	lda #$3f
	sta hypervisor_cpuport00
	lda #$35 ; IO + Kernel ROM @ $E000 (although Kernel is blank)
	sta hypervisor_cpuport01

	; make $FFD2 safe for CC65 compiled programs that call
	; there to set lower case during initialisation.
	; We need to write $60 to $2FFD2
	lda #$60 ; RTS
	ldx #$d2
	ldy #$ff
	ldz #$02
	jsr longpoke

	; Next instruction exits hypervisor to user mode
	sta hypervisor_enterexit_trigger

utility_dmalist:
		; copy $FF8xxxx-$FF8yyyy to $00007FF-$000xxxx
		; (MB offsets get set in routine)
		.byte $00 ; copy + last request in chain
		.word $FFFF ; size of copy  (gets overwritten)
		.word $FFFF ; starting addr (gets overwritten)
		.byte $08   ; of bank $8
		.word $07FF ; destination address is $0801 - 2
		.byte $00   ; of bank $0
		.word $0000 ; modulo (unused)


msg_utility_item:
	.byte "1. 32 CHARACTERS OF UTILITY NAME...    ",0

utillist_next:

	; Advance pointer to the next pointer
	ldz #42
	nop
	lda (<zptempv32),z
	tax
	inz
	nop
	lda (<zptempv32),z
	; XXX - Make sure it can't point earlier into the colour RAM here

	sta <zptempv32+1
	stx <zptempv32
	rts

utillist_validity_check:
	; See if this is a valid utility entry
	ldz #0

	; Check for magic value
	nop ; 32-bit pointer access follows
	lda (<zptempv32),z
	cmp #'M
	bne ulvc_fail
	inz
	nop ; 32-bit pointer access follows
	lda (<zptempv32),z
	cmp #'6
	bne ulvc_fail
	inz
	nop ; 32-bit pointer access follows
	lda (<zptempv32),z
	cmp #'5
	bne ulvc_fail
	inz
	nop ; 32-bit pointer access follows
	lda (<zptempv32),z
	cmp #'U
	bne ulvc_fail

	; Check self address
	ldz #40
	nop ; 32-bit pointer access follows
	lda (<zptempv32),z
	cmp zptempv32
	bne ulvc_fail
	inz
	nop ; 32-bit pointer access follows
	lda (<zptempv32),z
	cmp zptempv32+1
	bne ulvc_fail

	; success
	sec
	rts

ulvc_fail:
	clc
	rts

utillist_rewind:
	; Set pointer to first entry in colour RAM ($0800)
	lda #<$0800
	sta <zptempv32
	lda #>$0800
	sta <zptempv32+1
	lda #<$0FF8
	sta <zptempv32+2
	lda #>$0FF8
	sta <zptempv32+3

	rts

msg_utilitymenu:
	.byte "SELECT UTILITY TO LAUNCH",0

;	========================

; checkpoint message

msg_checkpoint:	      .byte "$"
msg_checkpoint_pc:    .byte "%%%% A:"
msg_checkpoint_a:     .byte "%%, X:"
msg_checkpoint_x:     .byte "%%, Y:"
msg_checkpoint_y:     .byte "%%, Z:"
msg_checkpoint_z:     .byte "%%, P:"
msg_checkpoint_p:     .byte "%% :"
msg_checkpointmsg:    .byte "                                                             " ; END_OF_STRING
		      .byte 13,10  ; CR/LF

;	========================

msg_checkpoint_eom:

; messages all have to be <=40 bytes long

msg_retryreadmbr:     .byte "RE-TRYING TO READ MBR",0
msg_kickstart:        .byte "MEGA65 MEGAOS HYPERVISOR V00.11",0
msg_kickstarthelp:    .byte "SW15=HOLD-BOOT, SW12=DEBUG-COMMS",0
msg_romok:            .byte "ROM CHECKSUM OK - BOOTING",0
msg_rombad:	      .byte "ROM CHECKSUM FAIL - LOADING ROMS",0
msg_charrombad:	      .byte "COULD NOT LOAD CHARROM.M65",0
msg_charromloaded:    .byte "LOADED CHARROM.M65 ($$$$ PAGES)",0
msg_megaromloaded:    .byte "LOADED MEGA65ROM.M65 ($$$$ PAGES)",0
msg_tryingsdcard:     .byte "LOOKING FOR SDCARD...",0
msg_foundsdcard:      .byte "FOUND AND RESET SDCARD",0
msg_sdcarderror:      .byte "ERROR READING FROM SD CARD",0
msg_sdredoread:       .byte "RE-READING SDCARD",0

msg_badformat:	      .byte "BAD MBR OR DOS BOOT SECTOR.",0
msg_sdcardfound:      .byte "READ PARTITION TABLE FROM SDCARD",0
msg_foundromfile:     .byte "FOUND ROM FILE. START CLUSTER = $$$$$$$$",0
msg_diskcount:	      .byte "DISK-COUNT=$$, DEFAULT-DISK=$$",0
msg_diskdata0:	      .byte "DISK-TABLE:",0
msg_diskdata:	      .byte "BB$$:$$.$$.$$.$$.$$.$$.$$.$$",0

msg_filelengths:      .byte "LOOKING FOR $$ BYTES, I SEE $$ BYTES",0

msg_fileopenerror:    .byte "COULD NOT OPEN ROM FILE FOR READING",0
msg_readingfile:      .BYTE "READING ROM FILE...",0
msg_romfilelongerror: .byte "ROM TOO LONG: (READ $$$$ PAGES)",0
msg_romfileshorterror:.byte "ROM TOO SHORT: (READ $$$$ PAGES)",0
msg_clusternumber:    .byte "CURRENT CLUSTER=$$$$$$$$",0
msg_sectoraddress:    .byte "CURRENT SECTOR= $$$$$$$$",0
msg_nod81:	      .byte "CANNOT MOUNT MEGA65.D81 - (ERRNO: $$)",0
msg_d81mounted:	      .byte "MEGA65.D81 SUCCESSFULLY MOUNTED",0
msg_releasesw15:      .byte "RELEASE SW15 TO CONTINUE BOOTING.",0
msg_romnotfound:      .byte "COULD NOT FIND ROM MEGA65XXROM",0
msg_foundkickup:      .byte "LOADING KICKUP.M65 INTO HYPERVISOR",0
msg_nokickup:         .byte "NO KICKUP.M65 TO LOAD (OR BROKEN)",0
msg_kickuploaded:     .byte "KICKUP LOADED TO 00004000 - $$$$$$$$",0
msg_alreadykicked:    .byte "RUNNING KICKED HYPERVISOR",0
msg_lookingfornextsector:
		      .byte "LOOKING FOR NEXT SECTOR OF FILE",0
msg_nologo:	      .byte "COULD NOT LOAD BANNER.M65 (ERRNO:$$)",0
msg_cdrootfailed:     .byte "COULD NOT CHDIR TO / (ERRNO:$$)",0

			; include the GIT-STRING as a message
			;
			.include "version.a65"

msg_blankline:	      .byte 0

;	========================
			; filename of utility to pre-load at $C000
			; (typically the "disk menu" program)
txt_C000UTIL:		.byte "C000UTIL.BIN",0

			; filename of character ROM
			;
txt_CHARROMM65:		.byte "CHARROM.M65",0

			; filename of ROM we want to load in FAT directory format
			; (the two zero bytes are so that we can insert an extra digit after
			; the 5, when a user presses a key, so that they can choose a
			; different ROM to load).
			;
txt_MEGA65ROM:		.byte "MEGA65.ROM",0,0

			; filename of 1581 disk image we mount by default
			;
txt_MEGA65D81:		.byte "MEGA65.D81",0

			; filename of kickstart update file
			;
txt_KICKUPM65:		.byte "KICKUP.M65",0

			; filename containing boot logo
			;
txt_BOOTLOGOM65:	.byte "BANNER.M65",0

			; If this file is present, then machine starts up with video
			; mode set to NTSC (60Hz), else as PAL (50Hz).
			; This is to allow us to boot in PAL by default, except for
			; those who have a monitor that cannot do 50Hz.
txt_NTSC:		.byte "NTSC",0

;	========================

	.include "kickstart_debug.a65"

;	========================

		.checkpc $BB00
		.advance $BB00

; Table of available disks.
; This includes native FAT32 disks, as well as (in the future at least)
; mounted .D41, .D71, .D81 and .DHD files using Commodore DOS filesystems.
; But for now, we are supporting only FAT32 as the filesystem.
; See kickstart_dos.a65 for information on how the table is used.
; Entries are 32 bytes long, so we can have 8 of them.
;
dos_disk_table:

;;; ----------------------------------------------------------------------------
;;; Hypervisor DOS work area and scratch pad at $BC00-$BCFF
;;; ----------------------------------------------------------------------------

		.checkpc $BC00
		.advance $BC00

kickstart_scratchbyte0:
		.byte $00

		; The number of disks we have
		;
dos_disk_count:
		.byte $00

		; The default disk
		;
dos_default_disk:
		.byte $00

		; The current disk
		;
dos_disk_current_disk:
		.byte $00

		; Offset of current disk entry in disk table
		;
dos_disk_table_offset:
		.byte $00

		; cluster of current directory of current disk
		;
dos_disk_cwd_cluster:
		.byte 0,0,0,0

;	========================

		; Current point in open directory
		;
dos_opendir_cluster:
		.byte 0,0,0,0
dos_opendir_sector:
		.byte 0
dos_opendir_entry:
		.byte 0

;	========================

		; WARNING: dos_readdir_read_next_entry uses carnal knowledge about the following
		;          structure, particularly the length as calculated here:
		;
		.alias dos_dirent_structure_length 64+1+11+4+4+1

		; Current long filename (max 64 bytes)
		;
dos_dirent_longfilename:
		.byte "Venezualen casaba melon productio" ; 33-chars
		.byte "n statistics (2012-2015).txt  "    ; 30-chars
		.byte 0

dos_dirent_longfilename_length:
		.byte 0

dos_dirent_shortfilename:
		.byte "FILENAME.EXT",0		

dos_dirent_cluster:
		.byte 0,0,0,0

dos_dirent_length:
		.byte 0,0,0,0

dos_dirent_type_and_attribs:
		.byte 0

;	========================

		; Requested file name and length
		;
dos_requested_filename_len:
		.byte 0

dos_requested_filename:
		.byte "Venezualen casaba melon productio"
		.byte "n statistics (2007-2011).txt     "

;	========================

		; Details about current DOS request
		;
dos_sectorsread:		.word 0
dos_current_sector:		.word 0,0
dos_current_cluster:		.word 0,0
dos_current_sector_in_cluster:	.byte 0

; Current file descriptors
; Each descriptor has:
;   disk id : 1 byte ($00-$07 = file open, $FF = file closed)
;   access mode : 1 byte ($00 = read only)
;   start cluster : 4 bytes
;   current cluster : 4 bytes
;   current sector in cluster : 1 byte
;   offset in sector: 2 bytes
;   file offset / $100 : 3 bytes
;
    .alias dos_filedescriptor_max 4
    .alias dos_filedescriptor_offset_diskid 0    
    .alias dos_filedescriptor_offset_mode 1    
    .alias dos_filedescriptor_offset_startcluster 2    
    .alias dos_filedescriptor_offset_currentcluster 6
;
; These last three fields must be contiguous, as dos_open_current_file
; relies on it.
;
    .alias dos_filedescriptor_offset_sectorincluster 10
    .alias dos_filedescriptor_offset_offsetinsector 11
    .alias dos_filedescriptor_offset_fileoffset 13

dos_file_descriptors:
	.byte $FF,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0	; each is 16 bytes
	.byte $FF,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	.byte $FF,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	.byte $FF,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0

	; The current file descriptor
	;
dos_current_file_descriptor:
	.byte 0

	; Offset of current file descriptor
	;
dos_current_file_descriptor_offset:
	.byte 0

;	========================

	; For providing feedback on why DOS calls have failed
	; There is a set of error codes defined in kickstart_dos.a65
dos_error_code:
		.byte $00

;;; ----------------------------------------------------------------------------
;;; reserved space for Hypervisor Process work area $BD00-$BDFF
;;; ----------------------------------------------------------------------------

		.checkpc $BD00
		.advance $BD00,$00

		.include "kickstart_process_descriptor.a65"

;;; ----------------------------------------------------------------------------
;;; reserved space for Kickstart stack (8-bit) $BE00-$BEFF
;;; ----------------------------------------------------------------------------

		.checkpc $BE00
		.advance $BE00,$3d

;;; ----------------------------------------------------------------------------
;;; reserved space for Kickstart ZP at $BF00-$BFFF
;;; ----------------------------------------------------------------------------

		.checkpc $BF00
		.advance $BF00,$3e

		; Temporary vector storage for DOS
		;
dos_scratch_vector: .word 0,0
dos_scratch_byte_1: .byte 0
dos_scratch_byte_2: .byte 0

		; Vectors for copying data between hypervisor and user-space
		;
hypervisor_userspace_copy_vector:    .word 0
    
		; general kickstart temporary variables
		;
zptempv:		.word 0
zptempv2:		.word 0
zptempp:		.word 0
zptempp2:		.word 0
zptempv32:		.word 0,0
zptempv32b:		.word 0,0
dos_file_loadaddress:	.word 0,0

		; Keyboard scan routine
		
    ; // ZERO PAGE Varibles
ScanResult:   	    .byte 0,0,0,0,0,0,0,0
BufferNew:    	    .byte 0,0,0
KeyQuantity:  	    .byte 0
NonAlphaFlagX: 	    .byte 0
NonAlphaFlagY: 	    .byte 0
TempZP: 	    .byte 0
SimultaneousKeys:   .byte 0

    ; // Operational Variables
   .alias MaxKeyRollover 3

		; Used for checkpoint debug system of hypervisor
		;
checkpoint_a:	      .byte 0
checkpoint_x:	      .byte 0
checkpoint_y:	      .byte 0
checkpoint_z:	      .byte 0
checkpoint_p:	      .byte 0
checkpoint_pcl:	      .byte 0
checkpoint_pch:	      .byte 0

		; SD card timeout handling
		;
sdcounter:		.byte 0,0,0

;;; ----------------------------------------------------------------------------
;;; end of KICKUP-rom
;;; ----------------------------------------------------------------------------

			.checkpc $C000
			.advance $C000, $3f

			.outfile "bin/KICKUP.M65"

