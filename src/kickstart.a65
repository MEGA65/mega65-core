; MEGA65 Kick Start ROM.
; Paul Gardner-Stephen, 2014-2016.
;
; Purpose: 
; 1. Verify checksum of ROM area of slow RAM.
; 1. If checksum fails, load complete ROM from SD card.
; 2. Select default disk image for F011 emulation.
;
; The kickstart ROM is 16KB in length, and maps at $8000-$BFFF
; in hypervisor mode.
;
; Kickstart modifies RAM from $0000-$07FFF (ZP, stack, 40-column
; screen, 16-bit text mode) during normal boot.
;
;
; BG: is the below true still, I dont think so.
; If Kickstart needs to load the ROM from SD card, then it may
; modify the first 64KB of fast ram.
;
;
; We will use the convention of C=0 means failure, ie CLC/RTS,
;                           and C=1 means success, ie SEC/RTS.
;
;
;	; this included file defines many of the alias used throughout
;	; it also suggests some memory-map definitions
;	;

	.include "kickstart_machine.a65"

;
; scratch space in ZP space usually used by kernel
; we try to use address space not normally used by C64 kernel, so that
; it is possible to make calls to kickstart after boot.  Eventually
; the desire is to have an SYS call that brings up a menu that lets
; you choose a disk image from a list.
;
	.data 

;	========================
	.org $ce00
;	========================

	.space romslab 1
	.space screenrow 1

	.space checksum 4
	.space file_pagesread 2

	; variables for testing of D81 boot image
	;
	.space d81_clusternumber 4
	.space d81_clustersneeded 2
	.space d81_clustercount 2

	; make sure that we don't go past the 256 byte page reserved for hypervisor scratch space
	;
	.checkpc $CEFF

	.text

;	========================
	.org $8000
;	========================

;;; ----------------------------------------------------------------------------
;;; CPU Hypervisor Trap entry points.
;;; 64 x 4 byte entries for user-land traps.
;;; some more x 4 byte entries for system traps (reset, page fault etc)
;;; ----------------------------------------------------------------------------

trap_entry_points:

	; Traps $00-$07 (user callable)
	;
	jmp dos_and_process_trap	; Trap #$00 (unsure what to call it)
	nop				; refer: kickstart_dos
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop

	; Traps $08-$0F (user callable)
	;
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop

	; Traps $10-$17 (user callable)
	;
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop

	; Traps $18-$1F (user callable)
	;
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop

	; Traps $20-$27 (user callable)
	;
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop

	; Traps $28-$2F (user callable)
	;
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop

	; Traps $30-$37
	;
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop

	; Traps $38-$3F (user callable)
	;
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop

;	========================

	; Traps $40-$4F (reset, page fault and other system-generated traps)
	jmp reset_entry_allow_etherkick	; Trap #$40 (power on / reset)
	nop				; refer: below in this file

	jmp page_fault			; Trap #$41 (page fault)
	nop				; refer: kickstart_mem

	jmp double_restore_trap		; Trap #$42 (double-tap RESTORE key)
	nop				; refer: kickstart_task 

	jmp nosuchtrap			; common-trap (catch all)
	nop				; refer: below in this file
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop


	; Leave room for traps to $7E (BG: why 7E ?)
	;
	.checkpc $81F8
	.advance $81F8

	; Then we have relocated CPU vectors
	;
	.word reset_entry_allow_etherkick ; unused vector
	.word hypervisor_nmi ; NMI
	.word reset_entry_allow_etherkick ; RESET
	.word hypervisor_irq ; IRQ

	.checkpc $8200
	.advance $8200

;;; ----------------------------------------------------------------------------
;;; Hypervisor traps
;;; ----------------------------------------------------------------------------
	

;;; ----------------------------------------------------------------------------
;;; Illegal trap / trap sub-function handlers
;;; ----------------------------------------------------------------------------
;
; Traps are triggered by writing to $D640-$D67F
; and trap to $8000+((address & $3F)*4) in the hypervisor

; Routine for unimplemented/reserved traps
; (Consider replacing with trap to hypervisor error screen with option
;  to return?)
;
nosuchtrap:

	; Clear C flag for caller to indicate failure
	;
	lda hypervisor_flags
	and #$FE   ; C flag is bit 0
	sta hypervisor_flags

	; set A to $FF
	;
	lda #$ff
	sta hypervisor_a

	; return from hypervisor
	;
	sta hypervisor_enterexit_trigger

;	========================

return_from_trap_with_success:

	; Return from trap with C flag clear to indicate success

	jsr sd_unmap_sectorbuffer	

	; set C flag for caller to indicate success
	;
	lda hypervisor_flags
	ora #$01   ; C flag is bit 0
	sta hypervisor_flags

	jsr checkpoint
	.byte 0,"return_from_trap_with_success",0

	; return from hypervisor
	sta hypervisor_enterexit_trigger

;	========================

return_from_trap_with_failure:

	jsr sd_unmap_sectorbuffer	

	; report error in A
	;
	sta hypervisor_a
	lda hypervisor_flags
	and #$fe   ; C flag is bit 0 (ie clear bit-0)
	sta hypervisor_flags

	jsr checkpoint
	.byte 0,"return_from_trap_with_failure",0

	; return from hypervisor
	sta hypervisor_enterexit_trigger	

;	========================

invalid_subfunction:

	jmp nosuchtrap

;	========================

;;; ----------------------------------------------------------------------------
;;; DOS, process control and related functions trap
;;; ----------------------------------------------------------------------------
		.include "kickstart_dos.a65"

;;; ----------------------------------------------------------------------------
;;; Virtual memory and memory management
;;; ----------------------------------------------------------------------------
		.include "kickstart_mem.a65"

;;; ----------------------------------------------------------------------------
;;; Task (process) management
;;; ----------------------------------------------------------------------------
		.include "kickstart_task.a65"

;;; ----------------------------------------------------------------------------
;;; sdcard and fat32 related functions
;;; ----------------------------------------------------------------------------
		.include "kickstart_sdfat.a65"

;;; ----------------------------------------------------------------------------
;;; CPU Hypervisor Entry Point on reset
;;; ----------------------------------------------------------------------------

reset_machine_state:
		; get CPU state sensible
		sei
		cld
		see

		; disable IRQ/NMI sources
		lda #$7f
		sta $DC0D
		sta $DD0D
		LDA #$00
		STA $D019

		sec
		; determine VIC mode and set it accordingly in VICIV_MAGIC
		jsr enhanced_io

		lda $d60d

		; switch to fast mode
		; 1. C65 fast-mode enable
		lda $d031
		ora #$40
		sta $d031
		; 2. MEGA65 48MHz enable (requires C65 or C128 fast mode to truly enable, hence the above)
		lda $d054
		ora #$40
		sta $d054

		; sprites off
		lda #$00
		sta $d017

		lda #$7f
		sta $DC0D
		sta $DD0D
		lda #$00
		sta $D01A

		; We DO NOT need to mess with $01, because
		; the 4510 starts up with kickstart mapped at $8000-$BFFF 
		; enhanced ($FFD3xxx) IO page mapped at $D000,
		; and fast RAM elsewhere.

		; Disable reset watchdog, enable flat 32-bit addressing, don't engage
		; ROM write protect (yet), do make ASC/DIN / CAPS LOCK control CPU speed.
		; also force 4502 CPU personality (6502 personality is still incomplete)
		; and clear any pending IRQ or NMI event.
		; (The watchdog was added to catch reset problems where the machine
		; would run off somewhere odd instead of resetting properly. Now it
		; will auto-reset after 65535 cycles if the watchdog is not cleared).
		;
		lda #$6a
		sta hypervisor_feature_enables

		jsr resetdisplay
		jsr erasescreen
		jsr resetpalette

;note that this first message does not get displayed correctly
		jsr checkpoint
		.byte 0,"reset_machine_state",0
;but this second message does
		jsr checkpoint
		.byte 0,"reset_machine_state",0

		rts

;;; ----------------------------------------------------------------------------
;;; CPU Hypervisor reset/trap routines
;;; ----------------------------------------------------------------------------
;
reset_entry_allow_etherkick:
		sei
		lda #$00
		sta kickstart_boot_flags
		jmp reset_entry_common

reset_entry_no_etherkick:
		sei
		lda #$80
		sta kickstart_boot_flags
		jmp reset_entry_common

reset_entry_common:

		jsr reset_machine_state

		; display welcome screen
		;
		ldx #<msg_kickstart
		ldy #>msg_kickstart
		jsr printbanner

		; leave a blank line below kickstart banner
		;
		ldx #<msg_blankline
		ldy #>msg_blankline
		jsr printmessage

		; Display GIT commit
		;
		ldx #<msg_gitcommit
		ldy #>msg_gitcommit
		jsr printmessage

		; Display help text
		;
		ldx #<msg_kickstarthelp
		ldy #>msg_kickstarthelp
		jsr printmessage

		; check keyboard for 0-9 down to select alternate rom
		;
		jsr keyboardread

		; If switch 8 and 9 are set, and etherkick mode is not disabled
		; then wait forever for ethernet packets
		;
		lda kickstart_boot_flags
		bmi normalboot
		lda $d6f1
		and #$02
		beq normalboot
etherboot:
		ldx #<msg_etherkick
		ldy #>msg_etherkick
		jsr printmessage
		jsr setupethernet
etherloop:
		jsr checkethernet
		.byte 0,"etherloop",0
		jmp etherloop

;	========================

normalboot:

	jsr dump_disk_count	; debugging to Checkpoint
	jsr dumpcurrentfd	; debugging to Checkpoint

		; Try to read the MBR from the SD card to ensure SD card is happy
		;
		ldx #<msg_tryingsdcard
		ldy #>msg_tryingsdcard
		jsr printmessage

tryreadmbr:
		jsr readmbr
		bcs gotmbr

		; Oops, cant read MBR
		; display debug message to screen
		;
		ldx #<msg_retryreadmbr
		ldy #>msg_retryreadmbr
		jsr printmessage

		; display debug message to uart
		;
		jsr checkpoint
		.byte 0,"re-try reading MBR of sdcard",0

		jmp tryreadmbr

;	========================
		
gotmbr:
		; good, was able to read the MBR

		; Scan SD card for partitions and mount them.
		;
		jsr dos_clearall
		jsr dos_read_partitiontable

		; then print out some useful information
		;
		ldx #<msg_diskcount
		ldy #>msg_diskcount
		jsr printmessage
		;
		ldy #$00
		ldz dos_disk_count
		jsr printhex
		;
		ldy #$00
		ldz dos_default_disk
		jsr printhex

	jsr dump_disk_count	; debugging to Checkpoint
	jsr dumpcurrentfd	; debugging to Checkpoint
;	jsr print_disk_table	; debugging to Screen

;	========================


		; Go to root directory on default disk
		;
		ldx dos_default_disk
		jsr dos_cdroot
		bcs mountsystemdiskok

		; failed
		;
		ldx #<msg_cdrootfailed
		ldy #>msg_cdrootfailed
		jsr printmessage
		ldy #$00
		ldz dos_error_code
		jsr printhex

		jsr checkpoint
		.byte 0,"FAILED CDROOT",0
		;
		; BG: should probably JMP to reset or something, and not fall through

		
mountsystemdiskok:

		; Load and display boot logo
		; Prepare 32-bit pointer for loading boot logo @ $0004000
		lda #$00
		sta <dos_file_loadaddress+0
		lda #$40
		sta <dos_file_loadaddress+1
		lda #$00
		sta <dos_file_loadaddress+2
		lda #$00
		sta <dos_file_loadaddress+3

		ldx #<txt_BOOTLOGOM65
		ldy #>txt_BOOTLOGOM65
		jsr dos_setname

		; print debug message
		;
		jsr checkpoint
		.byte 0,"  try-loading BOOTLOGO",0
	
		jsr dos_readfileintomemory
		bcs logook
		
;	========================

		; FAILED: print debug message
		;
		jsr checkpoint
		.byte 0,"  FAILED-loading BOOTLOGO",0

		; print debug message
		;
		ldx #<msg_nologo
		ldy #>msg_nologo
		jsr printmessage
		ldy #$00
		ldz dos_error_code
		jsr printhex

		jsr checkpoint
		.byte 0,"FAILED loading BOOTLOGO",0

;	========================

logook:
		; iterate through directory entries looking for ordinary file 
		; KICKUP.M65 to load into hypervisor memory ...
		; ... but only if we are not running a kick-up'd kickstart now.
		;
		lda hypervisor_kickedup_flag	;$d67e = register for kickup-state (00=virgin, else already-kicked)
		beq allowkickup

		; already kicked
		;
		ldx #<msg_alreadykicked
		ldy #>msg_alreadykicked
		jsr printmessage

		jmp postkickup

;	========================

allowkickup:	; BG was label nextdirectoryentry3:

		; Prepare 32-bit pointer for loading kickup @ $0004000
		;
		; BG: and why load at $4000 again?
		;
		lda #$00
		sta <dos_file_loadaddress+0
		lda #$40
		sta <dos_file_loadaddress+1
		lda #$00
		sta <dos_file_loadaddress+2
		lda #$00
		sta <dos_file_loadaddress+3

		ldx #<txt_KICKUPM65
		ldy #>txt_KICKUPM65
		jsr dos_setname

		; print debug message
		;
		jsr checkpoint
		.byte 0,"  try-loading KICKUP",0

		jsr dos_readfileintomemory
		bcc nokickup

;	========================

		; We have loaded a kickup file, so jump into it.


		; print debug message
		;
		jsr checkpoint
		.byte 0,"  loaded OK KICKUP",0


		ldx #<msg_kickuploaded
		ldy #>msg_kickuploaded
		jsr printmessage

		ldy #$00
		ldz <zptempv32+3	; BG what is in this register? Where is the data set?
		jsr printhex
		ldz <zptempv32+2
		jsr printhex
		ldz <zptempv32+1
		jsr printhex
		ldz <zptempv32+0
		jsr printhex

		; Use DMAgic to copy $0004000-$0007FFF to $FFF8000-$FFFBFFF
		; (We have to copy the routine to do this to RAM, since we will
		; be replacing ourselves)
		ldx #$00
krc:		lda kickuproutine,x
		sta $3000,x
		inx
		bne krc
		jmp $3000

;	========================

kickuproutine:
		; The following routine gets copied as-is to $3000 and run from there.
		; The DMA list is still available in the kickstart ROM when it gets
		; called, so we can just use it there, instead of working out where
		; it gets copied to

		; NOTE that only 256-bytes are copied, so the kickuproutine and kickupdmalist
		;      cannot exceed this limit, else revise the krc routine.

		; Set bottom 22 bits of DMA list address as for C65
		; (8MB address range).  Kickstart ROM is at $FFF8000, so $FF goes
		; in high-byte area
		;
		lda #$ff
		sta $d702
		lda #$ff   
		sta $d704  ; dma list is in top MB of address space
		sta $d706  ; similarly destination of copy is top MB of address space
		lda #$00
		sta $d705  ; source of copy is bottom MB of address space
		lda #>kickupdmalist
		sta $d701
		lda #<kickupdmalist
		sta $d700
		; clear source/destination MB so that C65 ROM doesn't go bananas
		lda #$00
		sta $d706

		; copy complete, so mark ourselves upgraded, and jump into hypervisor
		; as though we were just reset.

		; BG: here we should store non-zero, not ZERO ?
		;
		sta hypervisor_kickedup_flag	; mark ourselves as having kicked up, (00=virgin, else already-kicked)
		jmp $8100

;	========================

kickupdmalist:
		; copy $0004000-$0007FFF to $FFF8000-$FFFBFFF
		; (MB offsets get set in routine)
		.byte $00 ; copy + last request in chain
		.word $4000 ; size of copy is 16KB
		.word $4000 ; starting at $4000
		.byte $00   ; of bank $0
		.word $8000 ; destination address is $8000
		.byte $0F   ; of bank $F
		.word $0000 ; modulo (unused)

;	========================

couldntopenkickup:

nokickup:
		ldx #<msg_nokickup
		ldy #>msg_nokickup
		jsr printmessage

postkickup:

		; MILESTONE: Have file system properties.

		; Look for MEGA65.D81 to mount for F011 emulation

		; print debug message
		;
		jsr checkpoint
		.byte 0,"  Here we are POST-KICKUP",0

	jsr dumpcurrentfd	; debugging to Checkpoint
		
		; for now indicate that there is no disk in drive
		;
		lda #$00
		sta $d68b	; f011 emulation, BG: should have an alias

		; Go to root directory on default disk
		;
		ldx dos_default_disk
		jsr dos_cdroot
		bcc sdcarderror

		; set name of file we are looking for
		;
		ldx #<txt_MEGA65D81
		ldy #>txt_MEGA65D81
		jsr dos_setname

		; print debug message
		;
		jsr checkpoint
		.byte 0,"  try-mounting MEGA65.D81",0

		jsr dos_findfile
		bcc d81attachfail
		jsr dos_closefile

		jsr dos_d81attach
		bcc d81attachfail
		
		ldx #<msg_d81mounted
		ldy #>msg_d81mounted
		jsr printmessage

		; print debug message
		;
		jsr checkpoint
		.byte 0,"  mounted MEGA65.D81",0

		; all done, move on to loading the ROM
		;

		jmp findrom

;	========================

d81attachfail:
		; we couldn't find the D81 file, so tell the user
		;
		ldx #<msg_nod81
		ldy #>msg_nod81
		jsr printmessage
		ldy #$00
		ldz dos_error_code
		jsr printhex

	; debug
	jsr checkpoint
	.byte 0," couldnt mount/attach MEGA65.D81",0

findrom:
		; Check state of current ROM
		;
		jsr checkromok
		bcc loadrom

		; ROM is loaded and ready, so transfer control to it.
		;
		ldx #<msg_romok
		ldy #>msg_romok
		jsr printmessage

		jsr checkpoint
		.byte 0,"JUMPing into ROM-code",0

		jmp go64

;	========================

loadrom:

	jsr dumpcurrentfd	; debugging to Checkpoint

		; ROMs are not loaded, so try to load them, or prompt
		; for user to insert SD card
		;
		ldx #<msg_rombad
		ldy #>msg_rombad
		jsr printmessage

		; print debug message
		;
		jsr checkpoint
		.byte 0,"  try-loading CHAR-ROM",0

		; Load CHARROM.M65 into character ROM
		;
		ldx #<txt_CHARROMM65
		ldy #>txt_CHARROMM65
		jsr dos_setname
		
		; Prepare 32-bit pointer for loading whole ROM ($FF7E000)
		;
		lda #$00
		sta <dos_file_loadaddress+0
		lda #$E0
		sta <dos_file_loadaddress+1
		lda #$F7
		sta <dos_file_loadaddress+2
		lda #$0F
		sta <dos_file_loadaddress+3

		jsr dos_readfileintomemory
		bcs loadedcharromok

;	========================

		; FAILED
		ldx #<msg_charrombad
		ldy #>msg_charrombad
		jsr printmessage

		; print debug message
		;
		jsr checkpoint
		.byte 0," couldnt load CHARROM.M65",0

		jmp loadc65rom

;	========================

loadedcharromok:
		; print debug message
		;
		jsr checkpoint
		.byte 0,"  OK-loading CHARROM",0

		; prepare debug message
		;
		ldx dos_current_file_descriptor_offset
		lda dos_file_descriptors + dos_filedescriptor_offset_fileoffset+0,x
		sta file_pagesread
		lda dos_file_descriptors + dos_filedescriptor_offset_fileoffset+1,x
		sta file_pagesread+1

		ldx #<msg_charromloaded
		ldy #>msg_charromloaded
		jsr printmessage
		ldy #$00
		ldz file_pagesread+1
		jsr printhex
		ldz file_pagesread
		jsr printhex

loadc65rom:

	jsr dumpcurrentfd	; debugging to Checkpoint

		; print debug message
		;
		jsr checkpoint
		.byte 0,"  try-loading MEGA65-ROM",0

		ldx #<txt_MEGA65ROM
		ldy #>txt_MEGA65ROM
		jsr dos_setname

		; Prepare 32-bit pointer for loading whole ROM ($0020000)
		;
		lda #$00
		sta <dos_file_loadaddress+0
		sta <dos_file_loadaddress+1
		sta <dos_file_loadaddress+3
		lda #$02
		sta <dos_file_loadaddress+2

		jsr dos_readfileintomemory
		bcs loadedok

;	========================

		; ROM not found: indicate which ROM we were looking for
		;
		ldx #$0b
l17d:		lda txt_MEGA65ROM,x
		sta msg_romnotfound+19,x
		dex
		bne l17d
		ldx #<msg_romnotfound
		ldy #>msg_romnotfound
		jsr printmessage

		jsr sdwaitawhile
		jsr sdwaitawhile
		jsr sdwaitawhile
		jsr sdwaitawhile

		jmp sdcarderror

;	========================

		; ROM was found and loaded
loadedok:
		ldx dos_current_file_descriptor_offset
		lda dos_file_descriptors + dos_filedescriptor_offset_fileoffset +0,x
		sta file_pagesread
		lda dos_file_descriptors + dos_filedescriptor_offset_fileoffset +1,x
		sta file_pagesread+1

		; check the size of the loaded file
		;
		; BG need to ascertain which is HB and which is LB
		lda file_pagesread
		bne romfiletooshort
		lda file_pagesread+1
		cmp #$00
		beq romfiletooshort
		cmp #$02
		bne romfiletoolong

		; the loaded ROM was OK in size
		; need to store checksum
		;
		jsr storeromsum

loadedmegaromok:
		; print debug message
		;
		jsr checkpoint
		.byte 0,"  OK-loading CHARROM",0

		; prepare debug message
		;
		ldx dos_current_file_descriptor_offset
		lda dos_file_descriptors + dos_filedescriptor_offset_fileoffset+0,x
		sta file_pagesread
		lda dos_file_descriptors + dos_filedescriptor_offset_fileoffset+1,x
		sta file_pagesread+1

		ldx #<msg_megaromloaded
		ldy #>msg_megaromloaded
		jsr printmessage
		ldy #$00
		ldz file_pagesread+1
		jsr printhex
		ldz file_pagesread
		jsr printhex
		
		; ROM file loaded, transfer control
		;
		ldx #<msg_romok
		ldy #>msg_romok
		jsr printmessage

		; print debug message
		;
		jsr checkpoint
		.byte 0,"  OK-loading MEGA65-ROM",0

		; print debug message
		;
		jsr checkpoint
		.byte 0,"JUMPing into ROM-code",0

	jsr dumpcurrentfd	; debugging to Checkpoint

		jmp go64		

;	========================

romfiletoolong:
		ldx #<msg_romfilelongerror
		ldy #>msg_romfilelongerror
		jsr printmessage
		ldz file_pagesread+1
		jsr printhex
		ldz file_pagesread
		jsr printhex
		jsr sdwaitawhile
		jmp reset_entry_allow_etherkick

romfiletooshort:
		ldx #<msg_romfileshorterror
		ldy #>msg_romfileshorterror
		jsr printmessage
		ldz file_pagesread+1
		jsr printhex
		ldz file_pagesread
		jsr printhex
		jsr sdwaitawhile
		jmp reset_entry_allow_etherkick

;	========================

fileopenerror:
		ldx #<msg_fileopenerror
		ldy #>msg_fileopenerror
		jsr printmessage

sdcarderror:	ldx #<msg_sdcarderror
		ldy #>msg_sdcarderror
		jsr printmessage

		jsr sdwaitawhile
		jmp reset_entry_allow_etherkick

;	========================

badfs:		ldx #<msg_badformat
		ldy #>msg_badformat
		jsr printmessage

		jsr sdwaitawhile
		jmp reset_entry_allow_etherkick

;;; ----------------------------------------------------------------------------
;;; ROM loading and manipulation routines
;;; ----------------------------------------------------------------------------

checkromok:
		; read switch 13.  If set, assume ROM is invalid
		;
		lda $d6f1
		and #$20
		bne checksumfails

		; or if loading a ROM other than MEGA65.ROM, then assume ROM
		; is invalid
		;
		lda txt_MEGA65ROM+6
		cmp #'.
		bne checksumfails
	
		; calculate checksum of loaded ROM ...
		;
		jsr calcromsum
		; ... then fall through to testing it
testromsum:
		; have checksum for all slabs.

		jsr mapromchecksumrecord

		lda $4000
		cmp checksum
		bne checksumfails
		lda $4001
		cmp checksum+1
		bne checksumfails
		lda $4002
		cmp checksum+2
		bne checksumfails

		jsr resetmemmap

		sec
		rts

;	========================

		; check failed
checksumfails:	clc
		rts

;	========================

storeromsum:
		jsr mapromchecksumrecord

		lda checksum
		sta $4000
		lda checksum+1
		sta $4001
		lda checksum+2
		sta $4002
		rts

;	========================

mapromchecksumrecord:

		; Map in ROM load record, and compare checksum
		; Here we have to use our extension to MAP to access >1MB
		; as only 128KB of slow ram is shadowed to $20000.
		;
		; Again, we have to take the relative nature of MAP, so
		; we ask for $FC000 to be mapped at $0000, which means that
		; $4000 will correspond to $0000 (MAP instruction address
		; space wraps around at the 1MB mark)
		
		; select 128MB mark for mapping lower 32KB of address space
		;
		lda #$80
		ldx #$0f
		ldy #$00   ; keep kickstart mapped at $8000-$BFFF
		ldz #$3f

		map

		; then map $FC000 + $4000 = $00000 at $4000-$7FFF
		;
		lda #$c0
		ldx #$cf
		ldy #$00   ; keep kickstart mapped at $8000-$BFFF
		ldz #$3f
		map
		eom
		
		rts

;	========================

calcromsum:	; calculate checksum of 128KB ROM
		
		; use MAP to map C65 ROM address space in 16KB
		; slabs at $4000-$7FFF.  Check sum each, and
		; then compare checksum to ROM load record.
		;
		; ROMs get loaded into slow RAM at $8020000-$803FFFF,
		; which is shadowed for reading using C65 MAP instruction to
		; C65 address space $20000-$3FFFF.
		;
		; Checksum and ROM load record are stored in
		; $8000000 - $800FFFF, i.e., the first 64KB of
		; slow RAM.
		;
		; The 4510 MAP instruction does not normally provide access to the
		; full 28-bit address space, so we need to use a trick.
		;
		; We do this by interpretting a MAP instruction that says to
		; map none of the 8KB pages, but provides an offset in the range
		; $F0000 - $FFF00 to set the "super page" register for that 32KB
		; moby to bits 8 to 15 of the offset.  In practice, this means
		; to allow mapping of memory above 1MB, the MB of memory being
		; selected is chosen by the contents of A and Y registers when 
		; X and Z = $0F.
		; 
				
		; reset checksum
		; checksum is not all zeroes, so that if RAM initialises with
		; all zeroes, including in the checksum field, the checksum will
		; not pass.
		;
		lda #$03
		sta checksum
		sta checksum+1
		sta checksum+2
		sta checksum+3

		; start with bottom 16KB of ROM
		; we count in 16KB slabs, and ROM starts at 128KB mark,
		; so we want to check from the 8th to 15th slabs inclusive.
		;
		lda #$08
		sta romslab

		; Summing can be done using normal use of MAP instruction,
		; since slow RAM is shadowed as ROM to $20000-$3FFFF

sumslab:
		; romcheckslab indicates which 16KB piece.
		; MAP uses 256-byte granularity, so we need to shift left
		; 6 bits into A, and right 2 bits into X.
		; We then set the upper two bits in X to indicate that the mapping
		; applies to blocks 2 and 3.
		; BUT MAP is relative, and since we are mapping at the 16KB mark,
		; we need to subtract 1 lot of 16KB from the result.
		; this is easy -- we just sbc #$01 from romslab before using it.
		;
		lda romslab
		sec 
		sbc #$01
		lsr
		lsr
		ora #$c0
		tax
		lda romslab
		sec
		sbc #$01
		asl
		asl
		asl
		asl
		asl
		asl
		ldy #$00   ; keep kickstart mapped at $8000-$BFFF
		ldz #$3f

		map
		eom
		
		; sum contents of 16KB slab
		;
		lda #$00
		sta <zptempv
		lda #$40
		sta <zptempv+1
		
sumpage:	ldy #$00
sumbyte:	lda checksum
		clc
		adc (<zptempv),y
		sta checksum
		bcc l6
		inc checksum+1
		bcc l6
		inc checksum+2
l6:		iny
		bne sumbyte
		inc <zptempv+1
		lda <zptempv+1
		cmp #$80
		bne sumpage
		
		inc romslab
		lda romslab
		cmp #$10
		bne sumslab

		jmp resetmemmap

;;; ----------------------------------------------------------------------------
;;; Display and basic IO routines
;;; ----------------------------------------------------------------------------

resetdisplay:
		; reset screen
		;
		lda #$40	; 0100 0000 = choose charset
		sta $d030	; VIC-III Control Register A

		lda $d031	; VIC-III Control Register B
		and #$40	; bit-6 is 4mhz
		sta $d031

		lda #$00	; black
		sta $D020	; border
		sta $D021	; background

		lda #$00
		sta $D054	;VIC-IV Control Register C

		; We use VIC-II style registers as this resets video frame in
		; least instructions, and 40 columns is fine for us.
		;
		lda #$14	; 0001 0100
		sta $D018	; VIC-II Character/Screen location

		lda #$1B	; 0001 1011
		sta $D011	; VIC-II Control Register

		lda #$C8	; 1100 1000
		sta $D016	; VIC-II Control Register

		; point VIC-IV to bottom 16KB of display memory
		;
		lda #$ff
		sta $DD01
		sta $DD00

		; Now switch to 16-bit text mode so that we can use proportional
		; characters and full-colour characters for chars >$FF for the logo
		;
		lda #$05	; 0000 0101
		sta $d054	; VIC-IV Control Register C

		; and 80 bytes (40 16-bit characters) per row.
		;
		lda #<80
		sta $d058
		lda #>80
		sta $d059
		
		rts

;	========================

resetpalette:
		; reset VIC-IV palette to sensible defaults.
		; load C64 colours into palette bank 3 for use when
		; PAL bit in $D030 is set.
		;
		lda #$04
		sta $D030	; enable PAL bit in $D030

		lda #$ff
		sta $D070	; select palette bank 3 for display and edit

		; C64 colours designed to look like C65 colours on an
		; RGBI screen.
		;
		; formatted in ASM to help visualise what each code is for.
		;
                lda #$00
	                sta $D100
			sta $D200
			sta $D300

		lda #$ff
			sta $D101
			sta $D201
			sta $D301

		lda #$ba
	                sta $D102
                lda #$13
	                sta $D202
                lda #$62
	                sta $D302

                lda #$66
	                sta $D103
                lda #$ad
	                sta $D203
                lda #$ff
	                sta $D303

                lda #$bb
	                sta $D104
                lda #$f3
	                sta $D204
                lda #$8b
	                sta $D304

                lda #$55
	                sta $D105
                lda #$ec
	                sta $D205
                lda #$85
	                sta $D305

                lda #$d1
	                sta $D106
                lda #$e0
	                sta $D206
                lda #$79
	                sta $D306

                lda #$ae
	                sta $D107
                lda #$5f
	                sta $D207
                lda #$c7
	                sta $D307

                lda #$9b
	                sta $D108
                lda #$47
	                sta $D208
                lda #$81
	                sta $D308

                lda #$87
	                sta $D109
                lda #$37
	                sta $D209
                lda #$00
	                sta $D309

                lda #$dd
	                sta $D10a
                lda #$39
	                sta $D20a
                lda #$78
	                sta $D30a

                lda #$b5
	                sta $D10b
	                sta $D20b
	                sta $D30b

                lda #$b8
	                sta $D10c
	                sta $D20c
	                sta $D30c

                lda #$0b
	                sta $D10d
                lda #$4f
	                sta $D20d
                lda #$ca
	                sta $D30d

                lda #$aa
	                sta $D10e
                lda #$d9
	                sta $D20e
                lda #$fe
	                sta $D30e

                lda #$8b
	                sta $D10f
	                sta $D20f
	                sta $D30f

;	========================

		; put a colour cube in other entries
		;
		ldx #$10
paletteloop:
		; R = upper 3 bits
		txa
		lsr
		lsr
		lsr
		and #$0e
		sta $d100,x

		; G = next 3 bits
		txa
		lsr
		and #$0e
		sta $d200,x
		
		; B = lowest 2 bits
		txa
		asl
		asl
		and #$0c
		sta $d300,x

		inx
		bne paletteloop

		rts

;	========================

; erase standard 40-column screen
;
erasescreen:
		; bank in 2nd KB of colour RAM
		;
		lda #$01
		tsb $D030

		; use DMA to clear screen and colour RAM
		; The screen is in 16-bit bit mode, so we actually need to fill
		; with $20,$00, ...
		;
		; We will cheat by setting the first four bytes, and then copying from
		; there, and it will then read from the freshly written bytes.
		; (two bytes might not be enough to allow the write from the last DMA
		;  action to be avaialble for reading because of how the DMAgic is
		;  pipelined).
		;
		lda #$20
		sta $0400
		sta $0402
		lda #$00
		sta $0401
		sta $0403
		
		; Set bottom 22 bits of DMA list address as for C65
		; (8MB address range)
		;
		lda #$ff
		sta $d702

		; Kickstart ROM is at $FFFE000 - $FFFFFFF, so
		; we need to tell DMAgic that DMA list is in $FFxxxxx.
		; this has to be done AFTER writing to $d702, as $d702
		; clears bits 27 - 22 of the DMA list address to help with
		; compatibility.
		;
		lda #$ff
		sta $d704

		; copy from MB $00 for screen clearing
		;
		lda #$00
		sta $d705

		; destination MB is $00, since we are writing to C64 RAM space.
		;
		lda #$00
		sta $d706

		lda #>erasescreendmalist
		sta $d701

		; set bottom 8 bits of address and trigger DMA.
		;
		lda #<erasescreendmalist
		sta $d700

		; Kickstart ROM is at $FFFE000 - $FFFFFFF, so
		; we need to tell DMAgic that DMA list is in $FFxxxxx.
		; this has to be done AFTER writing to $d702, as $d702
		; clears bits 27 - 22 of the DMA list address to help with
		; compatibility.
		;
		lda #$ff
		sta $d704

		; similarly we need to tell DMAgic that we are copying data
		; from MB $FF (this is for copying the disk chooser)
		;
		sta $d705

		; destination MB is $00, since we are writing to C64 RAM space.
		;
		lda #$00
		sta $d706

		lda #>copydiskchooserdmalist
		sta $d701

		; set bottom 8 bits of address and trigger DMA.
		;
		lda #<copydiskchooserdmalist
		sta $d700

		; clear source/destination MB so that C65 ROM doesn't go bananas
		;
		lda #$00
		sta $d705

		; bank 2nd KB of colour RAM back out
		;
		lda #$01
		trb $D030

;	========================

		; move cursor back to top of the screen
		; (but leave 8 rows for logo and banner text)
		;
		lda #$08
		sta screenrow

		; draw 8x8 char block for logo
		;
		ldx #$00
		ldy #$00
logo1:		txa
		sta $0400+[80*0],y
		ora #$08
		sta $0400+[80*1],y
		txa
		ora #$10
		sta $0400+[80*2],y
		txa
		ora #$18
		sta $0400+[80*3],y
		txa
		ora #$20
		sta $0400+[80*4],y
		txa
		ora #$28
		sta $0400+[80*5],y
		txa
		ora #$30
		sta $0400+[80*6],y
		txa
		ora #$38
		sta $0400+[80*7],y
		iny
		iny
		inx
		cpx #$08		
		bne logo1

		; then write the high bytes for these (all $01, so char range will be
		; $100-$140. $100 x $40 = $4000-$4FFF
		;
		ldx #$00
		lda #$01
logo2:		sta $0401+[80*0],x
		sta $0401+[80*1],x
		sta $0401+[80*2],x
		sta $0401+[80*3],x
		sta $0401+[80*4],x
		sta $0401+[80*5],x
		sta $0401+[80*6],x
		sta $0401+[80*7],x
		inx
		inx
		cpx #$10
		bne logo2

		; finally work around the VIC-IV bug where the first normal character
		; following a full-colour character gets skipped by inserting early
		; end of line terminator markers on the lines. Without this, the first
		; character of the next line would show
		;
		lda #$ff
		sta $044e
		sta $044f
		sta $049e
		sta $049f
		sta $04ee
		sta $04ef
		sta $053e
		sta $053f
		sta $058e
		sta $058f
		sta $05de
		sta $05df
		sta $062e
		sta $062f
		sta $067e
		sta $067f

		rts

;	========================

erasescreendmalist:
		; Clear screen RAM
		;
		.byte $04 ; COPY + chained request
		.word 1996 ; 40x25x2-4 = 1996
		.word $0400 ; copy from start of screen at $0400
		.byte $00 ; source bank 00
		.word $0404 ; ... to screen at $0402
		.byte $00   ; screen is in bank $00
		.word $0000 ; modulo (unused)

		; Clear colour RAM
		;
		.byte $07 ; fill + chained request
		.word 2000 ; 40x25x2 = 2000
		.byte $01 ; fill with white = $01
		.byte $00,$00 ; rest of source address is ignored in fill
		.word $d800 ; screen is at $0400
		.byte $80   ; screen is in IO, so bank IO in to DMA context
		.word $0000 ; modulo (unused)

		; Clear $4000-$4FFF (for logo display) 
		;
		.byte $03 ; fill + last request
		.word $1000 ; 64x64 = $1000
		.byte $00 ; fill with black = $00
		.byte $00,$00 ; rest of source address is ignored in fill
		.word $4000 ; logo sits at $4000
		.byte $00   ; ... in bottom half of chipram, so bank $00
		.word $0000 ; modulo (unused)

copydiskchooserdmalist:
		; also copy diskchooser from $FFFE000-$FFFEFFF to $000C000-$000CFFF
		.byte $00 ; copy + last request in chain
		.word $1000
		.word diskchooserstart ; source address 
		.byte $0F ; source bank
		.word $c000 ; destination address
		.byte $00   ; destination bank
		.word $0000 ; modulo (unused)

;	========================

printmessage:	;HELPER routine
		;
		; This subroutine takes inputs from the X and Y registers,
		; so set these registers before calling this subroutine,
		; The X and Y registers need to point to a message as shown below:
		;
		;	ldx #<msg_foundsdcard
		;	ldy #>msg_foundsdcard
		;	jsr printmessage
		;
		; Ie: the X is the high-byte of the 16-bit address, and
		;     the Y is the low-byte  of the 16-bit address.

		stx <zptempp	;zptempp is 16-bit pointer to message
		sty <zptempp+1

		lda #$00
		sta <zptempp2	;zptempp2 is 16-bit pointer to screen
		lda #$04
		sta <zptempp2+1

		ldx screenrow
		; if we have reached the bottom of the screen, start writing again
		; from the top of the screen (but don't touch the top 8 rows for
		; logo and banner)
		cpx #25
		bne pm2
		ldx #$08
		stx screenrow

		; work out the screen address
		;
pm2:		cpx #$00
		beq pm1
		clc
		lda <zptempp2
		adc #$50          ; 40 columns x 16 bit
		sta <zptempp2
		lda <zptempp2+1
		adc #$00
		sta <zptempp2+1

		; if reached bottom of screen, then loop back to top of screen
		;
		cmp #$0b
		bcc pm5
		lda <zptempp2
		cmp #$d0
		bcc pm5
	
		lda #$80
		sta <zptempp2
		lda #$06
		sta <zptempp2+1
pm5:		dex
		bne pm2
pm1:

		; Clear line (16-bit chars, so write #$0020 to each word
		;
		ldy #$00
pm1b:		lda #$20
		sta (<zptempp2),y
		iny
		lda #$00
		sta (<zptempp2),y		
		iny
		cpy #$50
		bne pm1b		

writestring:
		phz
		ldy #$00
		ldz #$00
pm3:		lda (<zptempp),y
		beq endofmessage

		; convert ASCII/PETSCII to screen codes
		;
		cmp #$40
		bcc pm4
		and #$1f

pm4:		; write 16-bit character code
		;
		sta (<zptempp2),z
		inz
		pha
		lda #$00
		sta (<zptempp2),z
		pla
		iny
		inz
		bne pm3
endofmessage:
		inc screenrow

		plz
		rts

;	========================

printbanner:
		stx <zptempp
		sty <zptempp+1
		lda #<$0504
		sta zptempp2
		lda #>$0504
		sta zptempp2+1
		jsr writestring
		dec screenrow
		rts

;	========================
		
printhex:
		; helper function
		;	
		; seems to want to print the value if the z-reg onto the previous line written to the screen,
		; so currently the screen consists of say "mounted $$ images"
		; and this routine will go and change the "$$" to the value in the z-reg
		;
		; BG: surely this can be replaced with updating the "$$" before printing the string
		;
		; INPUT: .Y, BG seems to be an offset, should be set to zero?
		; INPUT: .Z, value in Z-reg to be displayed omn the screen
		;
		tza
		lsr
		lsr
		lsr
		lsr
		jsr printhexdigit		
		tza
		and #$0f
printhexdigit:
		; find next $ sign to replace with hex digit
		;
		tax
phd3:		lda (<zptempp2),y
		cmp #$24
		beq phd2
		iny
		iny
		cpy #$50
		bne phd3
		rts

phd2:		txa
		ora #$30
		cmp #$3a
		bcc phd1
		sbc #$39
phd1:		sta (<zptempp2),y
		iny
		iny
		rts

;	========================

go64:

; Transfer control to C64 kernel.
; (This also allows entry to C65 mode, because the
;  C64-mode kernel on the C65 checks if C65 mode
;  should be entered.)

		; Check if hold boot switch is set (switch 15)?
		;
		lda $d6f1
		bpl l42      ; no, so continue		

		; yes, display message
		;
		ldx #<msg_releasesw15
		ldy #>msg_releasesw15
		jsr printmessage

l41:		lda $d6f1
		bmi l41
l42:

		; unmap sector buffer so C64 can see CIAs
		;
		lda #$82
		sta $D680

		; copy routine to stack to switch to
		; C64 memory map and enter via reset
		; vector.  
	
		; erase kickstart ROM copy from RAM
		; (well, at least enough so that BASIC doesn't get upset)
		; XXX - use DMA
		;
		ldx #$00
		txa
g61:		sta $0800,x
		inx
		bne g61		

		; reset video mode to normal
		lda #$00
		sta $d054

		lda #<40
		sta $d058
		lda #>40
		sta $d059

		jsr task_set_c64_memorymap
		jsr task_set_pc_to_reset_vector
		jsr task_dummy_nmi_vector

		; Exit hypervisor and transfer control to ROM
		;
		sta hypervisor_enterexit_trigger

		; BG: i think the line above causes the HYP to take control,
		;     and so execution does not continue to the next line.

;	========================

; BG: the longpeek subroutine does not get called from kickstart,
;     it gets called only from the kickstart_task file,
;     so i suggest moving this subroutine to that file.

longpeek:
		; Use DMAgic to read any byte of RAM in 28bit address space.
		; Value gets read into $BC00 (kickstart_scratchbyte0)
		; ($FFFBC00 - $FFFBDFF)

		; Patch DMA list
		;
		sta $d705 ; DMAgic source MB
		lda #$ff
		sta $d706 ; DMAgic destination MB
		stx longpeekdmalist+3
		sty longpeekdmalist+4
		stz longpeekdmalist+5

		; Set DMA list address
		;
		lda #>longpeekdmalist
		sta $d701
		lda #$0f
		sta $d702 ; DMA list address is $xxFxxxx
		lda #$ff
		sta $d704 ; DMA list address is $FFxxxxx

		; set bottom bits of DMA list address and trigger DMA
		;
		lda #<longpeekdmalist
		sta $d700
		rts

longpeekdmalist:
		.byte $00 ; COPY, no chain
		; 1 byte
		.word $0001
		; source address
		.word $0000
		.byte $00
		; destination address ($xxFBC00)
		.word kickstart_scratchbyte0
		.byte $0F 
		.byte $00,00 ; Modulo

;	========================
		
; reset memory map to default
resetmemmap:
		; clear memory MAP MB offset register
		;
		lda #$00
		ldx #$0f
		ldy #$00   ; keep kickstart mapped at $8000-$BFFF
		ldz #$3f

		map

		; and clear all mapping
		;
		tax
		ldy #$00   ; keep kickstart mapped at $8000-$BFFF
		ldz #$3f

		map
		eom

		rts

;	========================

enhanced_io:

		; If C=1, enable enhanced IO bank,
		;   else, return to C64 standard IO map.
		;

		bcs l1
		; Return to VIC-II / C64 IO
		;
		lda #$00
		sta VICIV_MAGIC
		rts

l1:		; Enable VIC-IV / MEGA65 IO
		;
		lda #$47
		sta VICIV_MAGIC
		lda #$53
		sta VICIV_MAGIC
		RTS


;	========================

keyboardread:

; Check for digits 0 - 9 on keyboard, and change which ROM we intend to read
; based on that.

		lda #$ff
		sta $dc03
		lda #$00
		sta $dc02
		lda #$fe
		sta $dc01
		lda #$20
		ldx $dc00
		cpx #$7f
		bne k1
		lda #$31
k1:		cpx #$ef
		bne k9
		lda #$39
k9:		cpx #$f7
		bne k7
		lda #$37
k7:		cpx #$fb
		bne k5
		lda #$35
k5:		cpx #$fd
		bne k3
		lda #$33
k3:		ldx #$f7
		stx $dc01
		ldx $dc00
		cpx #$7f
		bne k0
		lda #$32
k0:		cpx #$ef
		bne k8
		lda #$30
k8:		cpx #$f7
		bne k6
		lda #$38
k6:		cpx #$fb
		bne k4
		lda #$36
k4:		cpx #$fd
		bne k2
		lda #$34
k2:		
		; put character into 6th byte position of ROM file name.
		; so no key looks for MEGA65.ROM, where as 0-9 will look
		; for MEGA65x.ROM, where x is the number.
		ldx #6
		cmp #$20
		beq default_rom
		sta txt_MEGA65ROM,x
		inx
default_rom:
		lda #'.
		sta txt_MEGA65ROM,x
		inx
		lda #'R
		sta txt_MEGA65ROM,x
		inx
		lda #'O
		sta txt_MEGA65ROM,x
		inx
		lda #'M
		sta txt_MEGA65ROM,x
		inx
		lda #0
		sta txt_MEGA65ROM,x    

		rts

;-----------------------------------------------------------------------------
	; This is an adaption of the etherload code, to allow loading of memory
	; while waiting at the kickstart ROM.  Since this is an amazing security
	; hole, we only do it if switch 8 is set.

setupethernet:
	; only do it if switch 8 is on
	lda $d6f1
	and #$01
	bne e1
	rts
e1:
	; C65GS io
	lda #$47
	sta viciv_magic
	lda #$53
	sta viciv_magic

	; Map ethernet registers at $6000 - $7FFF
	
	; Ethernet controller really lives $FFDE000 - $FFDEFFF, so select $FF megabyte section for MAP LO
	lda #$ff
	ldx #$0f
	ldy #$00   ; keep kickstart mapped at $8000-$BFFF
	ldz #$3f
	map
	eom

	; now enable mapping of $DE000-$DFFFF at $6000
	; MAPs are offset based, so we need to subtract $6000 from the target address
	; $DE000 - $6000 = $D8000
	lda #$80
	ldx #$8d
	ldy #$00   ; keep kickstart mapped at $8000-$BFFF
	ldz #$3f
	map
	eom

	; Ethernet registers should now be visible from $6000 - $6FFF
	; read buffer will be at $6800 - $6FFF
	; length of frame is in $6FFE / $6FFF in little-endian byte order
	; so LDA $6FFE ; LDX $6FFF ; jsr $BDCD should print packet length to screen

	; make sure ethernet transceiver is on and not generating IRQs
	; (we will poll it).
	; also make sure that we acknowledge the last received packet so that the
	; ethernet controller knows it can receive.
	lda $d6e1
	lsr
	and #$02
	ora #$01
	sta $d6e1

	rts

checkethernet:
	; only do it if switch 8 is on
	lda $d6f1
	and #$01
	bne e2
	rts
e2:

	lda $d6e1
	and #$20
	bne gotpacket
	rts
gotpacket:
	; clear eth RX signal, and leave ethernet tranceiver on
	; and make last used RX buffer visible
	lda $d6e1
	and #$04
	lsr
	ora #$01
	sta $d6e1


	; Got a packet.
	; check whether it is UDP port 4510
	; or whether it is an ARP request

	; Here we want to check that $680E - $6817 =
	; 08 06 00 01 08 00 06 04 00 01

	ldx #$09
arploop0:
	lda $680e,x
	cmp arptemplate,x
	bne notarp
	dex
	bpl arploop0

	; check that IP address asked for ends in .65
	lda $682b
	cmp #65
	bne notarp

	; ok, so we have an ARP request.
	; now we need to build the ARP reply and send it.
	; We should copy the sender's 

	; XXX for now just increment border colour

	; set output packet size
	; 6+6+2 bytes ethernet header + 28 bytes of ARP reply = 42
	lda #<42
	sta $d6e2
	lda #>42
	sta $d6e3

	; copy fixed ARP fields (we will overwrite some later)
	; (note that TX buffer lacks 2 byte RX buffer header)
	ldx #$14
arploop1:
	lda $6802,x
	sta $6800,x
	dex
	bpl arploop1
	; Copy ethernet source to ethernet destination in TX buffer
	; Set our mac address in ethernet source address field in TX buffer
	ldx #$05
arploop2:
	lda $6808,x    ; requestors mac from RX ethernet header
	sta $6800,x    ; requestors mac into TX ethernet header
	lda #$40
	sta $6806,x    ; our mac in ethernet header
	sta $6816,x    ; our mac in ARP payload
	dex
	bpl arploop2
	; set packet as ARP reply
	lda #$02     ; $02 = reply, $01 = request
	sta $6815

	ldx #$03
	; copy requested IP address into reply IP address field
arploop3:
	lda $6828,x
	sta $681c,x
	dex
	bpl arploop3
	; copy requestors MAC+IP into target MAC+IP fields
	ldx #9
arploop4:
	lda $6818,x
	sta $6820,x
	dex
	bpl arploop4
	
	; packet should now all be ready - hit TX button
	lda #$01
	sta $d6e4
notarp:

	; is it IPv4?
	lda $6810
	cmp #$45
	bne badpacket
	; is it UDP?
	lda $6819
	cmp #$11
	bne badpacket
	; UDP port #4510
	lda $6826
	cmp #>4511
	bne badpacket
	lda $6827
	cmp #<4511
	bne badpacket

	; packet body begins at $0444 / $682C.
	; if it begins with $A9 = LDA immediate, then jsr to the packet body.
	; packet body can do whatever is required to load data, keeping this
	; programme very simple.
	lda $682c
	cmp #$a9
	bne badpacket
	jsr $682C

badpacket:
	rts

arptemplate:
	.byte $08,$06,$00,$01,$08,$00,$06,$04,$00,$01

nybltohex:
	cmp #$a
	bcs nth1
	ora #$30
	rts
nth1:	sec
	sbc #9
	rts

;	========================

hypervisor_nmi:
hypervisor_irq:
		; Default interrupt handlers for hypervisor: for now just mask the
		; interrupt source.  Later we can have raster splits in the boot
		; display if we so choose.
		sei
		rti

hypervisor_setup_copy_region:
	; Hypervisor copy region sit entirely within the first 32KB of
	; mapped address space. Since we allow a 256 byte copy region,
	; we limit the start address to the range $0000-$7EFF
	; XXX - We should also return an error if there is an IO
	; region mapped there, so that the hypervisor can't be tricked
	; into doing privileged IO operations as part of the copy-back
	
	lda hypervisor_y
	bmi hscr1
	cmp #$7f
	beq hscr1
	sta hypervisor_userspace_copy_vector +1
	lda #$00
	sta hypervisor_userspace_copy_vector +0

	jsr checkpoint
	.byte 0,"hypervisor_setup_copy_region <success>",0

	sec
	rts

hscr1:
	jsr checkpoint
	.byte 0,"hypervisor_setup_copy_region <failure>",0

	lda #dos_errorcode_invalid_address
	jmp dos_return_error		

;	========================

checkpoint:

	; Routine to record the progress of code through the hypervisor for
	; debugging problems in the hypervisor.
	; If the JSR checkpoint is followed by $00, then a text string describing the
	; checkpoint is inserted into the checkpoint log.
	; Checkpoint data is recorded in the 2nd 16KB of colour RAM.

	; Save all registers and CPU flags
	sta checkpoint_a
	stx checkpoint_x
	sty checkpoint_y
	stz checkpoint_z
	php
	pla
	sta checkpoint_p

	; pull PC return address from stack
	; (JSR pushes return_address-1, so add one)
	pla
	clc
	adc #$01
	sta checkpoint_pcl
	pla
	adc #$00
	sta checkpoint_pch

	; Only do checkpoints visibly if switch 12 is set
	lda $d6f1
	and #$10
	beq cp9

	inc $d020

	; Write checkpoint byte values out as hex into message template
	ldx checkpoint_a
	jsr checkpoint_bytetohex
	sty msg_checkpoint_a+0
	stx msg_checkpoint_a+1

	ldx checkpoint_x
	jsr checkpoint_bytetohex
	sty msg_checkpoint_x+0
	stx msg_checkpoint_x+1

	ldx checkpoint_y
	jsr checkpoint_bytetohex
	sty msg_checkpoint_y+0
	stx msg_checkpoint_y+1

	ldx checkpoint_z
	jsr checkpoint_bytetohex
	sty msg_checkpoint_z+0
	stx msg_checkpoint_z+1

	ldx checkpoint_p
	jsr checkpoint_bytetohex
	sty msg_checkpoint_p+0
	stx msg_checkpoint_p+1

	ldx checkpoint_pch
	jsr checkpoint_bytetohex
	sty msg_checkpoint_pc+0
	stx msg_checkpoint_pc+1

	ldx checkpoint_pcl
	jsr checkpoint_bytetohex
	sty msg_checkpoint_pc+2
	stx msg_checkpoint_pc+3

	; Clear out checkpoint message
	ldx #59
	lda #$20
cp4:	sta msg_checkpointmsg,x
	dex
	bpl cp4
cp9:
	; Read next byte following the return address to see if it is $00,
	; if so, then also store the $00-terminated text message that follows.
	; e.g.:
	;
	; jsr checkpoint
	; .byte 0,"OPEN DIRECTORY",0
	;
	; to record a checkpoint with the string "OPEN DIRECTORY"

	ldy #$00
	lda (<checkpoint_pcl),y

	bne nocheckpointmessage

	; Copy null-terminated checkpoint string
	ldx #$00
	iny
cp3:	lda (<checkpoint_pcl),y
	beq endofcheckpointmessage
	sta msg_checkpointmsg,x
	inx
	iny
	cpy #60
	bne cp3

	; flush out any excess bytes at end of message
cp44:	lda (<checkpoint_pcl),y
	beq endofcheckpointmessage
	iny
	bra cp44
	

endofcheckpointmessage:
	; Skip $00 at end of message
	iny
	
nocheckpointmessage:

	; Advance return address following any checkpoint message
	tya
	clc	
	adc checkpoint_pcl
	sta checkpoint_pcl
	lda checkpoint_pch
	adc #$00
	sta checkpoint_pch

	; Only do checkpoints visibly if switch 12 is set
	lda $d6f1
	and #$10
	beq checkpoint_return

	; output checkpoint message to serial monitor
	ldx #0
cp5:	lda msg_checkpoint,x
	sta hypervisor_write_char_to_serial_monitor
	inx

	; BG this should not blindly send, but to wait until the char has been sent
	;
	; delay at least 2,000 cycles to allow character to be written
	; each inner loop is 2 + 256 * (2+3) = ~1,250 cycles
	; so 2 such loops should take long enough
	ldy #2
	ldz #0
cp6:	inz
	bne cp6
	dey
	bpl cp6

	cmp #10
	bne cp5

checkpoint_return:
	; restore registers
	lda checkpoint_p
	php
	lda checkpoint_a
	ldx checkpoint_x
	ldy checkpoint_y
	ldz checkpoint_z
	plp

	; return by jumping to the 
	jmp (checkpoint_pcl)

;	========================

checkpoint_bytetohex:

	; BG: this is a helper function to convert a HEX-byte to
	;     its equivalent two-byte char representation
	;
	;     input ".X", containing a HEX-byte to convert
	;   outputs ".X" & ".Y", Y is MSB, X is LSB, print YX

	txa
	and #$f0
	lsr
	lsr
	lsr
	lsr
	jsr checkpoint_nybltohex
	tay
	txa
	and #$0f
	jsr checkpoint_nybltohex
	tax	
	rts

;	========================

checkpoint_nybltohex:

	and #$0f
	ora #$30
	cmp #$3a
	bcs cpnth1
	rts

cpnth1:	adc #$06
	rts

;	========================

; checkpoint message

msg_checkpoint:	      .byte "Checkpoint @ $"
msg_checkpoint_pc:    .byte "%%%% A:$"
msg_checkpoint_a:     .byte "%%, X:$"
msg_checkpoint_x:     .byte "%%, Y:$"
msg_checkpoint_y:     .byte "%%, Z:$"
msg_checkpoint_z:     .byte "%%, P:$"
msg_checkpoint_p:     .byte "%% :"
msg_checkpointmsg:    .byte "                                                             " ; END_OF_STRING
		      .byte 13,10  ; CR/LF

;	========================

msg_checkpoint_eom:

; messages all have to be <=40 bytes long

msg_retryreadmbr:     .byte "RE-TRYING TO READ MBR",0
msg_kickstart:        .byte "MEGA65 KICKSTART V00.08",0
msg_kickstarthelp:    .byte "SW15=HOLD-BOOT, SW12=DEBUG-COMMS",0
msg_romok:            .byte "ROM CHECKSUM OK - BOOTING",0
msg_rombad:	      .byte "ROM CHECKSUM FAIL - LOADING ROMS",0
msg_charrombad:	      .byte "COULD NOT LOAD CHARROM.M65",0
msg_charromloaded:    .byte "LOADED CHARROM.M65 ($$$$ PAGES)",0
msg_megaromloaded:    .byte "LOADED MEGA65ROM.M65 ($$$$ PAGES)",0
msg_tryingsdcard:     .byte "LOOKING FOR SDCARD...",0
msg_foundsdcard:      .byte "FOUND AND RESET SDCARD",0
msg_sdcarderror:      .byte "ERROR READING FROM SD CARD",0
msg_sdredoread:       .byte "RE-READING SDCARD",0

msg_badformat:	      .byte "BAD MBR OR DOS BOOT SECTOR.",0
msg_sdcardfound:      .byte "READ PARTITION TABLE FROM SDCARD",0
msg_foundromfile:     .byte "FOUND ROM FILE. START CLUSTER = $$$$$$$$",0
msg_diskcount:	      .byte "DISK-COUNT=$$, DEFAULT-DISK=$$",0
msg_diskdata0:	      .byte "DISK-TABLE:",0
msg_diskdata:	      .byte "BB$$:$$.$$.$$.$$.$$.$$.$$.$$",0

msg_filelengths:      .byte "LOOKING FOR $$ BYTES, I SEE $$ BYTES",0

msg_fileopenerror:    .byte "COULD NOT OPEN ROM FILE FOR READING",0
msg_readingfile:      .BYTE "READING ROM FILE...",0
msg_romfilelongerror: .byte "ROM TOO LONG: (READ $$$$ PAGES)",0
msg_romfileshorterror:.byte "ROM TOO SHORT: (READ $$$$ PAGES)",0
msg_clusternumber:    .byte "CURRENT CLUSTER=$$$$$$$$",0
msg_sectoraddress:    .byte "CURRENT SECTOR= $$$$$$$$",0
msg_nod81:	      .byte "CANNOT MOUNT MEGA65.D81 - (ERRNO: $$)",0
msg_d81mounted:	      .byte "MEGA65.D81 SUCCESSFULLY MOUNTED",0
msg_releasesw15:      .byte "RELEASE SW15 TO CONTINUE BOOTING.",0
msg_romnotfound:      .byte "COULD NOT FIND ROM MEGA65XXROM",0
msg_foundkickup:      .byte "LOADING KICKUP.M65 INTO HYPERVISOR",0
msg_nokickup:         .byte "NO KICKUP.M65 TO LOAD (OR BROKEN)",0
msg_kickuploaded:     .byte "KICKUP LOADED TO 00004000 - $$$$$$$$",0
msg_alreadykicked:    .byte "RUNNING KICKED HYPERVISOR",0
msg_etherkick:	      .byte "BOOTING VIA ETHERKICK: UDP PORT 4511",0
msg_lookingfornextsector:
		      .byte "LOOKING FOR NEXT SECTOR OF FILE",0
msg_nologo:	      .byte "COULD NOT LOAD BOOTLOGO.M65 (ERRNO:$$)",0
msg_cdrootfailed:     .byte "COULD NOT CHDIR TO / (ERRNO:$$)",0

			; include the GIT-STRING as a message
			;
			.include "version.a65"

msg_blankline:	      .byte 0

;	========================

			; filename of character ROM
			;
txt_CHARROMM65:		.byte "CHARROM.M65",0

			; filename of ROM we want to load in FAT directory format
			; (the two zero bytes are so that we can insert an extra digit after
			; the 5, when a user presses a key, so that they can choose a
			; different ROM to load).
			;
txt_MEGA65ROM:		.byte "MEGA65.ROM",0,0

			; filename of 1581 disk image we mount by default
			;
txt_MEGA65D81:		.byte "MEGA65.D81",0

			; filename of kickstart update file
			;
txt_KICKUPM65:		.byte "KICKUP.M65",0

			; filename containing boot logo
			;
txt_BOOTLOGOM65:	.byte "BOOTLOGO.M65",0

;	========================

	.include "kickstart_debug.a65"

;	========================

diskchooserstart:
	; Pre-compiled disk menu
;	.incbin "diskmenu_c000.bin"

diskchooserend:

;	========================

		.checkpc $BB00
		.advance $BB00

; Table of available disks.
; This includes native FAT32 disks, as well as (in the future at least)
; mounted .D41, .D71, .D81 and .DHD files using Commodore DOS filesystems.
; But for now, we are supporting only FAT32 as the filesystem.
; See kickstart_dos.a65 for information on how the table is used.
; Entries are 32 bytes long, so we can have 8 of them.
;
dos_disk_table:

;;; ----------------------------------------------------------------------------
;;; Hypervisor DOS work area and scratch pad at $BC00-$BCFF
;;; ----------------------------------------------------------------------------

		.checkpc $BC00
		.advance $BC00

kickstart_scratchbyte0:
		.byte $00

		; The number of disks we have
		;
dos_disk_count:
		.byte $00

		; The default disk
		;
dos_default_disk:
		.byte $00

		; The current disk
		;
dos_disk_current_disk:
		.byte $00

		; Offset of current disk entry in disk table
		;
dos_disk_table_offset:
		.byte $00

		; cluster of current directory of current disk
		;
dos_disk_cwd_cluster:
		.byte 0,0,0,0

;	========================

		; Current point in open directory
		;
dos_opendir_cluster:
		.byte 0,0,0,0
dos_opendir_sector:
		.byte 0
dos_opendir_entry:
		.byte 0

;	========================

		; WARNING: dos_readdir_read_next_entry uses carnal knowledge about the following
		;          structure, particularly the length as calculated here:
		;
		.alias dos_dirent_structure_length 64+1+11+4+4+1

		; Current long filename (max 64 bytes)
		;
dos_dirent_longfilename:
		.byte "Venezualen casaba melon productio" ; 33-chars
		.byte "n statistics (2012-2015).txt  "    ; 30-chars
		.byte 0

dos_dirent_longfilename_length:
		.byte 0

dos_dirent_shortfilename:
		.byte "FILENAME.EXT",0		

dos_dirent_cluster:
		.byte 0,0,0,0

dos_dirent_length:
		.byte 0,0,0,0

dos_dirent_type_and_attribs:
		.byte 0

;	========================

		; Requested file name and length
		;
dos_requested_filename_len:
		.byte 0

dos_requested_filename:
		.byte "Venezualen casaba melon productio"
		.byte "n statistics (2007-2011).txt     "

;	========================

		; Details about current DOS request
		;
dos_sectorsread:		.word 0
dos_current_sector:		.word 0,0
dos_current_cluster:		.word 0,0
dos_current_sector_in_cluster:	.byte 0

; Current file descriptors
; Each descriptor has:
;   disk id : 1 byte ($00-$07 = file open, $FF = file closed)
;   access mode : 1 byte ($00 = read only)
;   start cluster : 4 bytes
;   current cluster : 4 bytes
;   current sector in cluster : 1 byte
;   offset in sector: 2 bytes
;   file offset / $100 : 3 bytes
;
    .alias dos_filedescriptor_max 4
    .alias dos_filedescriptor_offset_diskid 0    
    .alias dos_filedescriptor_offset_mode 1    
    .alias dos_filedescriptor_offset_startcluster 2    
    .alias dos_filedescriptor_offset_currentcluster 6
;
; These last three fields must be contiguous, as dos_open_current_file
; relies on it.
;
    .alias dos_filedescriptor_offset_sectorincluster 10
    .alias dos_filedescriptor_offset_offsetinsector 11
    .alias dos_filedescriptor_offset_fileoffset 13

dos_file_descriptors:
	.byte $FF,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0	; each is 16 bytes
	.byte $FF,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	.byte $FF,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	.byte $FF,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0

	; The current file descriptor
	;
dos_current_file_descriptor:
	.byte 0

	; Offset of current file descriptor
	;
dos_current_file_descriptor_offset:
	.byte 0

;	========================

	; For providing feedback on why DOS calls have failed
	; There is a set of error codes defined in kickstart_dos.a65
dos_error_code:
		.byte $00

;;; ----------------------------------------------------------------------------
;;; reserved space for Hypervisor Process work area $BD00-$BDFF
;;; ----------------------------------------------------------------------------

		.checkpc $BD00
		.advance $BD00,$00

		.include "kickstart_process_descriptor.a65"

;;; ----------------------------------------------------------------------------
;;; reserved space for Kickstart stack (8-bit) $BE00-$BEFF
;;; ----------------------------------------------------------------------------

		.checkpc $BE00
		.advance $BE00,$3d

;;; ----------------------------------------------------------------------------
;;; reserved space for Kickstart ZP at $BF00-$BFFF
;;; ----------------------------------------------------------------------------

		.checkpc $BF00
		.advance $BF00,$3e

kickstart_boot_flags:
			; $80 = disable etherkick this boot only
			.byte 0
			
		; Temporary vector storage for DOS
		;
dos_scratch_vector: .word 0,0
dos_scratch_byte_1: .byte 0
dos_scratch_byte_2: .byte 0

		; Vectors for copying data between hypervisor and user-space
		;
hypervisor_userspace_copy_vector:    .word 0
    
		; general kickstart temporary variables
		;
zptempv:		.word 0
zptempv2:		.word 0
zptempp:		.word 0
zptempp2:		.word 0
zptempv32:		.word 0,0
zptempv32b:		.word 0,0
dos_file_loadaddress:	.word 0,0

		; Used for checkpoint debug system of hypervisor
		;
checkpoint_a:	      .byte 0
checkpoint_x:	      .byte 0
checkpoint_y:	      .byte 0
checkpoint_z:	      .byte 0
checkpoint_p:	      .byte 0
checkpoint_pcl:	      .byte 0
checkpoint_pch:	      .byte 0

		; SD card timeout handling
		;
sdcounter:		.byte 0,0,0

;;; ----------------------------------------------------------------------------
;;; end of KICKUP-rom
;;; ----------------------------------------------------------------------------

			.checkpc $C000
			.advance $C000, $3f

			.outfile "KICKUP.M65"

