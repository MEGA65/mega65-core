/*
  Use libpcap to fetch raw video packets from C65GS, and then present them
  via a UDP socket for reading by the C65GS vncserver.  The idea is to
  separate the packet sniffer which needs root, from the part that listens
  to connections from the internet.

  (C) Paul Gardner-Stephen 2014, 2018.

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <sys/socket.h>
// #include <sys/filio.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <linux/types.h>
#include <fcntl.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <netinet/ip.h>
#include <string.h>
#include <strings.h>
#include <signal.h>
#include <netdb.h>
#include <time.h>
#include <pcap.h>

int client_sock = -1;

int create_listen_socket(int port)
{
  int sock = socket(AF_INET, SOCK_STREAM, 0);
  if (sock == -1)
    return -1;

  int on = 1;
  if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char *)&on, sizeof(on)) == -1) {
    close(sock);
    return -1;
  }
  if (ioctl(sock, FIONBIO, (char *)&on) == -1) {
    close(sock);
    return -1;
  }

  /* Bind it to the next port we want to try. */
  struct sockaddr_in address;
  bzero((char *)&address, sizeof(address));
  address.sin_family = AF_INET;
  address.sin_addr.s_addr = INADDR_ANY;
  address.sin_port = htons(port);
  if (bind(sock, (struct sockaddr *)&address, sizeof(address)) == -1) {
    close(sock);
    return -1;
  }

  if (listen(sock, 20) != -1)
    return sock;

  close(sock);
  return -1;
}

int accept_incoming(int sock)
{
  struct sockaddr addr;
  unsigned int addr_len = sizeof addr;
  int asock;
  if ((asock = accept(sock, &addr, &addr_len)) != -1) {
    return asock;
  }

  return -1;
}

int main(int argc, char **argv)
{
  char *dev;
  char errbuf[PCAP_ERRBUF_SIZE];
  pcap_t *descr;
  //    struct bpf_program fp;        /* to hold compiled program */
  bpf_u_int32 pMask; /* subnet mask */
  bpf_u_int32 pNet;  /* ip address*/
  pcap_if_t *alldevs;

  // Prepare a list of all the devices
  if (pcap_findalldevs(&alldevs, errbuf) == -1) {
    fprintf(stderr, "Error in pcap_findalldevs: %s\n", errbuf);
    exit(1);
  }

  if (argv[1])
    dev = argv[1];
  else {
    fprintf(stderr, "You must specify the interface to listen on.\n");
    exit(-1);
  }

  // If something was not provided
  // return error.
  if (dev == NULL) {
    printf("\n[%s]\n", errbuf);
    return -1;
  }

  // fetch the network address and network mask
  pcap_lookupnet(dev, &pNet, &pMask, errbuf);

  // Now, open device for sniffing with big snaplen and
  // promiscuous mode enabled.
  descr = pcap_open_live(dev, 3000, 1, 10, errbuf);
  if (descr == NULL) {
    printf("pcap_open_live() failed due to [%s]\n", errbuf);
    return -1;
  }

  printf("Started.\n");
  fflush(stdout);

  int listen_sock = create_listen_socket(6565);

  while (1) {
    if (client_sock == -1) {
      client_sock = accept_incoming(listen_sock);
    }

    struct pcap_pkthdr hdr;
    hdr.caplen = 0;
    const unsigned char *packet = pcap_next(descr, &hdr);
    if (packet) {
      if (hdr.caplen == 2132) {
        // probably a C65GS compressed video frame.
        if (client_sock != -1)
          write(client_sock, packet, 2132);
      }
    }
  }
  printf("Exiting.\n");

  return 0;
}
