; HDMI I2C setup / test program

; Include C65 BASIC program load header

	 .word $2001
	 .org $2001

	 .scope
	 .word _next, 10                       ; Next line and current line number
	 .byte $FE,$02,"0:", $9e, " 8151", $AA, "65",0      ; BANK 0: SYS 8151+65 (=8216)
_next:	 .word 0

	 .checkpc 8216
	 .advance 8216

programentrypoint:

	; C65 BASIC defaults to BANK 0, which is RAM bank 0, with no ROM or IO
	; banked in. So we have to fix that ourselves.

	lda #0
	tax
	tay
	taz
	map
	eom

	; Bank IO back in
	lda #$37
	sta $01
	; Bank ROM in at $E000-$FFFF
	lda #$80
	tsb $d030

	sei

	lda #0
	sta $d020
	
	; Enable C65GS io
	lda #$47
	sta $d02f
	lda #$53
	sta $D02f

	; 50MHz CPU
	lda #65
	sta 0

	; clear screen, lower case
	lda #$93
	jsr $ffd2
	lda #$0e
	jsr $ffd2

	; Setup pointer to memory mapped HDMI I2C registers
	lda #<$7200
	sta $fc
	lda #>$7200
	sta $fd
	lda #<$0FFD
	sta $fe
	lda #>$0FFD
	sta $ff

	; Re-read register $fe to get constant rotation of register phase
	; (this is because of a bug in hdmi_i2c.vhdl where the I2C read
	; operation isnt being forced to register $00 each time.)
	lda #$00
	ldz #$fe
	nop
	sta ($fc),z

	; Wait a while to let register writing complete
	lda #$40
@l1:	cmp $d012
	bne @l1
	lda #$30
@l2:	cmp $d012
	bne @l2

@main_loop:
	ldz #0
@reg_read_loop:
	; Re-read I2C register values
	tza
	tax   
	dex  ; shift around by 1, to make up for register rotation problem described above 
	nop
	lda ($fc),z
	sta $1400,x
	inz
	bne @reg_read_loop

	; Home cursor
	lda #$13
	jsr $ffd2

	jsr print_inline
	.byte "cHIP IS adv",0
	lda $14f5
	jsr print_hexbyte
	lda $14f6
	jsr print_hexbyte
	jsr print_inline
	.byte ", REV ",0
	lda $1400
	jsr print_hexbyte
	jsr print_inline
	.byte 13,"aUDIO N=",0
	ldx $1402
	ldy $1403
	jsr print_dec

	jmp @main_loop

print_inline:
	; Get return address from stack to get string address
	pla
	sta $50
	pla
	sta $51
	inw $50
@print_inline_char:
	ldy #$00
	lda ($50),y
	beq @done_print_inline
	jsr $ffd2
	inw $50
	jmp @print_inline_char


@done_print_inline:
	; skip $00 at end of string
	inw $50
	jmp ($0050)

print_hexbyte:
	pha
	lsr
	lsr
	lsr
	lsr
	jsr print_hexdigit
	pla
	and #$f
	jsr print_hexdigit
	rts

print_hexdigit:
	phy
	tay
	lda hexdigits,y
	jsr $ffd2
	ply
	rts

hexdigits:
	.byte "0123456789ABCDEF"

print_dec:
	; print the number in YYXX as a decimal number
	phy

	lda #0
	sta dec_buffer+0
	sta dec_buffer+1
	sta dec_buffer+2
	sta dec_buffer+3
	sta dec_buffer+4
	ldz #0
@pdl0:
	ldy #8
	txa
@pdl1:
	pha
	tya
	tax
	pla
	ror
	bcc @pdc1
	pha
	tza
	tax
	lda values+0,x
	and #$f
	clc
	adc dec_buffer+0
	sta dec_buffer+0
	lda values+1,x
	and #$f
	clc
	adc dec_buffer+1
	sta dec_buffer+1
	lda values+2,x
	and #$f
	clc
	adc dec_buffer+2
	sta dec_buffer+2
	lda values+3,x
	and #$f
	clc
	adc dec_buffer+3
	sta dec_buffer+3
	lda values+4,x
	and #$f
	clc
	adc dec_buffer+4
	sta dec_buffer+4
	pla
@pdc1:
	inz
	inz
	inz
	inz
	inz
	dey
	bne @pdl1
	
	cpz #80
	beq @pdnormalise
	plx
	jmp @pdl0

@pdnormalise:
	ldx #4
@pdn0:
	lda dec_buffer+0,x
	cmp #9
	bcc @pdn1
	inc dec_buffer-1,x
	sec
	sbc #10
	sta dec_buffer+0,x
	jmp @pdn0
@pdn1:	dex
	bpl @pdn0

	lda dec_buffer+0
	ora #$30
	jsr $ffd2
	lda dec_buffer+1
	ora #$30
	jsr $ffd2
	lda dec_buffer+2
	ora #$30
	jsr $ffd2
	lda dec_buffer+3
	ora #$30
	jsr $ffd2
	lda dec_buffer+4
	ora #$30
	jsr $ffd2
	rts

dec_buffer:
	.byte 0,0,0,0,0

values:
	.byte "00001","00002","00004","00008","00016","00032"
	.byte "00064","00128","00256","00512","01024","02048"
	.byte "04096","08192","16384","32768"

	.scend

	.outfile "hdmistatus.prg"
